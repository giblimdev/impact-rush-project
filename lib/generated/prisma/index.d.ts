
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * /////////////////////
 * //  auth model  /////
 * /////////////////////
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model adress
 * 
 */
export type adress = $Result.DefaultSelection<Prisma.$adressPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model MediaAsset
 * 
 */
export type MediaAsset = $Result.DefaultSelection<Prisma.$MediaAssetPayload>
/**
 * Model CodeSnippet
 * 
 */
export type CodeSnippet = $Result.DefaultSelection<Prisma.$CodeSnippetPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model PostsOnTags
 * 
 */
export type PostsOnTags = $Result.DefaultSelection<Prisma.$PostsOnTagsPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model PostsOnCategories
 * 
 */
export type PostsOnCategories = $Result.DefaultSelection<Prisma.$PostsOnCategoriesPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Reaction
 * 
 */
export type Reaction = $Result.DefaultSelection<Prisma.$ReactionPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectMember
 * 
 */
export type ProjectMember = $Result.DefaultSelection<Prisma.$ProjectMemberPayload>
/**
 * Model ProjectUpdate
 * 
 */
export type ProjectUpdate = $Result.DefaultSelection<Prisma.$ProjectUpdatePayload>
/**
 * Model ProjectReward
 * 
 */
export type ProjectReward = $Result.DefaultSelection<Prisma.$ProjectRewardPayload>
/**
 * Model ProjectDonation
 * 
 */
export type ProjectDonation = $Result.DefaultSelection<Prisma.$ProjectDonationPayload>
/**
 * Model ProjectInvestment
 * 
 */
export type ProjectInvestment = $Result.DefaultSelection<Prisma.$ProjectInvestmentPayload>
/**
 * Model ProjectLoan
 * 
 */
export type ProjectLoan = $Result.DefaultSelection<Prisma.$ProjectLoanPayload>
/**
 * Model Circle
 * 
 */
export type Circle = $Result.DefaultSelection<Prisma.$CirclePayload>
/**
 * Model CircleMember
 * 
 */
export type CircleMember = $Result.DefaultSelection<Prisma.$CircleMemberPayload>
/**
 * Model CircleProject
 * 
 */
export type CircleProject = $Result.DefaultSelection<Prisma.$CircleProjectPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model UserXP
 * 
 */
export type UserXP = $Result.DefaultSelection<Prisma.$UserXPPayload>
/**
 * Model Badge
 * 
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>
/**
 * Model UserBadge
 * 
 */
export type UserBadge = $Result.DefaultSelection<Prisma.$UserBadgePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  DEV: 'DEV',
  AUTHOR: 'AUTHOR',
  MODERATOR: 'MODERATOR',
  OWNER: 'OWNER',
  MEMBER: 'MEMBER',
  VISITOR: 'VISITOR'
};

export type Role = (typeof Role)[keyof typeof Role]


export const PostStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  SCHEDULED: 'SCHEDULED',
  ARCHIVED: 'ARCHIVED'
};

export type PostStatus = (typeof PostStatus)[keyof typeof PostStatus]


export const PostVisibility: {
  PUBLIC: 'PUBLIC',
  UNLISTED: 'UNLISTED',
  PRIVATE: 'PRIVATE'
};

export type PostVisibility = (typeof PostVisibility)[keyof typeof PostVisibility]


export const MediaType: {
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  AUDIO: 'AUDIO',
  FILE: 'FILE',
  EMBED: 'EMBED',
  CODE: 'CODE'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]


export const ReactionType: {
  LIKE: 'LIKE',
  CLAP: 'CLAP',
  UPVOTE: 'UPVOTE',
  DOWNVOTE: 'DOWNVOTE',
  LOVE: 'LOVE'
};

export type ReactionType = (typeof ReactionType)[keyof typeof ReactionType]


export const CommentStatus: {
  VISIBLE: 'VISIBLE',
  HIDDEN: 'HIDDEN',
  SPAM: 'SPAM',
  DELETED: 'DELETED'
};

export type CommentStatus = (typeof CommentStatus)[keyof typeof CommentStatus]


export const ProjectType: {
  DONATION: 'DONATION',
  REWARD: 'REWARD',
  EQUITY: 'EQUITY',
  CROWDLENDING: 'CROWDLENDING',
  KITTY: 'KITTY',
  IMPACT_SPRINT: 'IMPACT_SPRINT'
};

export type ProjectType = (typeof ProjectType)[keyof typeof ProjectType]


export const ProjectStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  SUCCESSFUL: 'SUCCESSFUL',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  SUSPENDED: 'SUSPENDED'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const ProjectCategory: {
  ECOLOGY: 'ECOLOGY',
  SOCIAL: 'SOCIAL',
  EDUCATION: 'EDUCATION',
  TECHNOLOGY: 'TECHNOLOGY',
  HEALTH: 'HEALTH',
  CULTURE: 'CULTURE',
  INNOVATION: 'INNOVATION',
  OTHER: 'OTHER'
};

export type ProjectCategory = (typeof ProjectCategory)[keyof typeof ProjectCategory]


export const ProjectImpactType: {
  ENVIRONMENTAL: 'ENVIRONMENTAL',
  SOCIAL: 'SOCIAL',
  ECONOMIC: 'ECONOMIC'
};

export type ProjectImpactType = (typeof ProjectImpactType)[keyof typeof ProjectImpactType]


export const CircleType: {
  THEMATIC: 'THEMATIC',
  SUPPORT: 'SUPPORT',
  SYNERGY: 'SYNERGY'
};

export type CircleType = (typeof CircleType)[keyof typeof CircleType]


export const CircleMemberRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MEMBER: 'MEMBER',
  FACILITATOR: 'FACILITATOR',
  SECRETARY: 'SECRETARY',
  PROJECT_REFERENT: 'PROJECT_REFERENT',
  ETHICS_GUARDIAN: 'ETHICS_GUARDIAN'
};

export type CircleMemberRole = (typeof CircleMemberRole)[keyof typeof CircleMemberRole]


export const CircleParticipationMode: {
  SYNCHRONOUS: 'SYNCHRONOUS',
  ASYNCHRONOUS: 'ASYNCHRONOUS'
};

export type CircleParticipationMode = (typeof CircleParticipationMode)[keyof typeof CircleParticipationMode]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type PostStatus = $Enums.PostStatus

export const PostStatus: typeof $Enums.PostStatus

export type PostVisibility = $Enums.PostVisibility

export const PostVisibility: typeof $Enums.PostVisibility

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

export type ReactionType = $Enums.ReactionType

export const ReactionType: typeof $Enums.ReactionType

export type CommentStatus = $Enums.CommentStatus

export const CommentStatus: typeof $Enums.CommentStatus

export type ProjectType = $Enums.ProjectType

export const ProjectType: typeof $Enums.ProjectType

export type ProjectStatus = $Enums.ProjectStatus

export const ProjectStatus: typeof $Enums.ProjectStatus

export type ProjectCategory = $Enums.ProjectCategory

export const ProjectCategory: typeof $Enums.ProjectCategory

export type ProjectImpactType = $Enums.ProjectImpactType

export const ProjectImpactType: typeof $Enums.ProjectImpactType

export type CircleType = $Enums.CircleType

export const CircleType: typeof $Enums.CircleType

export type CircleMemberRole = $Enums.CircleMemberRole

export const CircleMemberRole: typeof $Enums.CircleMemberRole

export type CircleParticipationMode = $Enums.CircleParticipationMode

export const CircleParticipationMode: typeof $Enums.CircleParticipationMode

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adress`: Exposes CRUD operations for the **adress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Adresses
    * const adresses = await prisma.adress.findMany()
    * ```
    */
  get adress(): Prisma.adressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mediaAsset`: Exposes CRUD operations for the **MediaAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaAssets
    * const mediaAssets = await prisma.mediaAsset.findMany()
    * ```
    */
  get mediaAsset(): Prisma.MediaAssetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.codeSnippet`: Exposes CRUD operations for the **CodeSnippet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodeSnippets
    * const codeSnippets = await prisma.codeSnippet.findMany()
    * ```
    */
  get codeSnippet(): Prisma.CodeSnippetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postsOnTags`: Exposes CRUD operations for the **PostsOnTags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostsOnTags
    * const postsOnTags = await prisma.postsOnTags.findMany()
    * ```
    */
  get postsOnTags(): Prisma.PostsOnTagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postsOnCategories`: Exposes CRUD operations for the **PostsOnCategories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostsOnCategories
    * const postsOnCategories = await prisma.postsOnCategories.findMany()
    * ```
    */
  get postsOnCategories(): Prisma.PostsOnCategoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reaction`: Exposes CRUD operations for the **Reaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reactions
    * const reactions = await prisma.reaction.findMany()
    * ```
    */
  get reaction(): Prisma.ReactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectMember`: Exposes CRUD operations for the **ProjectMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMembers
    * const projectMembers = await prisma.projectMember.findMany()
    * ```
    */
  get projectMember(): Prisma.ProjectMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectUpdate`: Exposes CRUD operations for the **ProjectUpdate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectUpdates
    * const projectUpdates = await prisma.projectUpdate.findMany()
    * ```
    */
  get projectUpdate(): Prisma.ProjectUpdateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectReward`: Exposes CRUD operations for the **ProjectReward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectRewards
    * const projectRewards = await prisma.projectReward.findMany()
    * ```
    */
  get projectReward(): Prisma.ProjectRewardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectDonation`: Exposes CRUD operations for the **ProjectDonation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectDonations
    * const projectDonations = await prisma.projectDonation.findMany()
    * ```
    */
  get projectDonation(): Prisma.ProjectDonationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectInvestment`: Exposes CRUD operations for the **ProjectInvestment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectInvestments
    * const projectInvestments = await prisma.projectInvestment.findMany()
    * ```
    */
  get projectInvestment(): Prisma.ProjectInvestmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectLoan`: Exposes CRUD operations for the **ProjectLoan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectLoans
    * const projectLoans = await prisma.projectLoan.findMany()
    * ```
    */
  get projectLoan(): Prisma.ProjectLoanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.circle`: Exposes CRUD operations for the **Circle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Circles
    * const circles = await prisma.circle.findMany()
    * ```
    */
  get circle(): Prisma.CircleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.circleMember`: Exposes CRUD operations for the **CircleMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CircleMembers
    * const circleMembers = await prisma.circleMember.findMany()
    * ```
    */
  get circleMember(): Prisma.CircleMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.circleProject`: Exposes CRUD operations for the **CircleProject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CircleProjects
    * const circleProjects = await prisma.circleProject.findMany()
    * ```
    */
  get circleProject(): Prisma.CircleProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userXP`: Exposes CRUD operations for the **UserXP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserXPS
    * const userXPS = await prisma.userXP.findMany()
    * ```
    */
  get userXP(): Prisma.UserXPDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.BadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userBadge`: Exposes CRUD operations for the **UserBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBadges
    * const userBadges = await prisma.userBadge.findMany()
    * ```
    */
  get userBadge(): Prisma.UserBadgeDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    Profile: 'Profile',
    adress: 'adress',
    Post: 'Post',
    MediaAsset: 'MediaAsset',
    CodeSnippet: 'CodeSnippet',
    Tag: 'Tag',
    PostsOnTags: 'PostsOnTags',
    Category: 'Category',
    PostsOnCategories: 'PostsOnCategories',
    Comment: 'Comment',
    Reaction: 'Reaction',
    Project: 'Project',
    ProjectMember: 'ProjectMember',
    ProjectUpdate: 'ProjectUpdate',
    ProjectReward: 'ProjectReward',
    ProjectDonation: 'ProjectDonation',
    ProjectInvestment: 'ProjectInvestment',
    ProjectLoan: 'ProjectLoan',
    Circle: 'Circle',
    CircleMember: 'CircleMember',
    CircleProject: 'CircleProject',
    Transaction: 'Transaction',
    UserXP: 'UserXP',
    Badge: 'Badge',
    UserBadge: 'UserBadge'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "account" | "verification" | "profile" | "adress" | "post" | "mediaAsset" | "codeSnippet" | "tag" | "postsOnTags" | "category" | "postsOnCategories" | "comment" | "reaction" | "project" | "projectMember" | "projectUpdate" | "projectReward" | "projectDonation" | "projectInvestment" | "projectLoan" | "circle" | "circleMember" | "circleProject" | "transaction" | "userXP" | "badge" | "userBadge"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      adress: {
        payload: Prisma.$adressPayload<ExtArgs>
        fields: Prisma.adressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.adressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.adressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adressPayload>
          }
          findFirst: {
            args: Prisma.adressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.adressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adressPayload>
          }
          findMany: {
            args: Prisma.adressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adressPayload>[]
          }
          create: {
            args: Prisma.adressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adressPayload>
          }
          createMany: {
            args: Prisma.adressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.adressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adressPayload>[]
          }
          delete: {
            args: Prisma.adressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adressPayload>
          }
          update: {
            args: Prisma.adressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adressPayload>
          }
          deleteMany: {
            args: Prisma.adressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.adressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.adressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adressPayload>[]
          }
          upsert: {
            args: Prisma.adressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adressPayload>
          }
          aggregate: {
            args: Prisma.AdressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdress>
          }
          groupBy: {
            args: Prisma.adressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdressGroupByOutputType>[]
          }
          count: {
            args: Prisma.adressCountArgs<ExtArgs>
            result: $Utils.Optional<AdressCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      MediaAsset: {
        payload: Prisma.$MediaAssetPayload<ExtArgs>
        fields: Prisma.MediaAssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaAssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaAssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          findFirst: {
            args: Prisma.MediaAssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaAssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          findMany: {
            args: Prisma.MediaAssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>[]
          }
          create: {
            args: Prisma.MediaAssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          createMany: {
            args: Prisma.MediaAssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaAssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>[]
          }
          delete: {
            args: Prisma.MediaAssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          update: {
            args: Prisma.MediaAssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          deleteMany: {
            args: Prisma.MediaAssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaAssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaAssetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>[]
          }
          upsert: {
            args: Prisma.MediaAssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaAssetPayload>
          }
          aggregate: {
            args: Prisma.MediaAssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaAsset>
          }
          groupBy: {
            args: Prisma.MediaAssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaAssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaAssetCountArgs<ExtArgs>
            result: $Utils.Optional<MediaAssetCountAggregateOutputType> | number
          }
        }
      }
      CodeSnippet: {
        payload: Prisma.$CodeSnippetPayload<ExtArgs>
        fields: Prisma.CodeSnippetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CodeSnippetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSnippetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CodeSnippetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSnippetPayload>
          }
          findFirst: {
            args: Prisma.CodeSnippetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSnippetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CodeSnippetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSnippetPayload>
          }
          findMany: {
            args: Prisma.CodeSnippetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSnippetPayload>[]
          }
          create: {
            args: Prisma.CodeSnippetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSnippetPayload>
          }
          createMany: {
            args: Prisma.CodeSnippetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CodeSnippetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSnippetPayload>[]
          }
          delete: {
            args: Prisma.CodeSnippetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSnippetPayload>
          }
          update: {
            args: Prisma.CodeSnippetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSnippetPayload>
          }
          deleteMany: {
            args: Prisma.CodeSnippetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CodeSnippetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CodeSnippetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSnippetPayload>[]
          }
          upsert: {
            args: Prisma.CodeSnippetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CodeSnippetPayload>
          }
          aggregate: {
            args: Prisma.CodeSnippetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCodeSnippet>
          }
          groupBy: {
            args: Prisma.CodeSnippetGroupByArgs<ExtArgs>
            result: $Utils.Optional<CodeSnippetGroupByOutputType>[]
          }
          count: {
            args: Prisma.CodeSnippetCountArgs<ExtArgs>
            result: $Utils.Optional<CodeSnippetCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      PostsOnTags: {
        payload: Prisma.$PostsOnTagsPayload<ExtArgs>
        fields: Prisma.PostsOnTagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostsOnTagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnTagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostsOnTagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnTagsPayload>
          }
          findFirst: {
            args: Prisma.PostsOnTagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnTagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostsOnTagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnTagsPayload>
          }
          findMany: {
            args: Prisma.PostsOnTagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnTagsPayload>[]
          }
          create: {
            args: Prisma.PostsOnTagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnTagsPayload>
          }
          createMany: {
            args: Prisma.PostsOnTagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostsOnTagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnTagsPayload>[]
          }
          delete: {
            args: Prisma.PostsOnTagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnTagsPayload>
          }
          update: {
            args: Prisma.PostsOnTagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnTagsPayload>
          }
          deleteMany: {
            args: Prisma.PostsOnTagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostsOnTagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostsOnTagsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnTagsPayload>[]
          }
          upsert: {
            args: Prisma.PostsOnTagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnTagsPayload>
          }
          aggregate: {
            args: Prisma.PostsOnTagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostsOnTags>
          }
          groupBy: {
            args: Prisma.PostsOnTagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostsOnTagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostsOnTagsCountArgs<ExtArgs>
            result: $Utils.Optional<PostsOnTagsCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      PostsOnCategories: {
        payload: Prisma.$PostsOnCategoriesPayload<ExtArgs>
        fields: Prisma.PostsOnCategoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostsOnCategoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnCategoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostsOnCategoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnCategoriesPayload>
          }
          findFirst: {
            args: Prisma.PostsOnCategoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnCategoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostsOnCategoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnCategoriesPayload>
          }
          findMany: {
            args: Prisma.PostsOnCategoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnCategoriesPayload>[]
          }
          create: {
            args: Prisma.PostsOnCategoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnCategoriesPayload>
          }
          createMany: {
            args: Prisma.PostsOnCategoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostsOnCategoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnCategoriesPayload>[]
          }
          delete: {
            args: Prisma.PostsOnCategoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnCategoriesPayload>
          }
          update: {
            args: Prisma.PostsOnCategoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnCategoriesPayload>
          }
          deleteMany: {
            args: Prisma.PostsOnCategoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostsOnCategoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostsOnCategoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnCategoriesPayload>[]
          }
          upsert: {
            args: Prisma.PostsOnCategoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsOnCategoriesPayload>
          }
          aggregate: {
            args: Prisma.PostsOnCategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostsOnCategories>
          }
          groupBy: {
            args: Prisma.PostsOnCategoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostsOnCategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostsOnCategoriesCountArgs<ExtArgs>
            result: $Utils.Optional<PostsOnCategoriesCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Reaction: {
        payload: Prisma.$ReactionPayload<ExtArgs>
        fields: Prisma.ReactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          findFirst: {
            args: Prisma.ReactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          findMany: {
            args: Prisma.ReactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>[]
          }
          create: {
            args: Prisma.ReactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          createMany: {
            args: Prisma.ReactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>[]
          }
          delete: {
            args: Prisma.ReactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          update: {
            args: Prisma.ReactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          deleteMany: {
            args: Prisma.ReactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>[]
          }
          upsert: {
            args: Prisma.ReactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          aggregate: {
            args: Prisma.ReactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReaction>
          }
          groupBy: {
            args: Prisma.ReactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReactionCountArgs<ExtArgs>
            result: $Utils.Optional<ReactionCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectMember: {
        payload: Prisma.$ProjectMemberPayload<ExtArgs>
        fields: Prisma.ProjectMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findFirst: {
            args: Prisma.ProjectMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findMany: {
            args: Prisma.ProjectMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          create: {
            args: Prisma.ProjectMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          createMany: {
            args: Prisma.ProjectMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          delete: {
            args: Prisma.ProjectMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          update: {
            args: Prisma.ProjectMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          deleteMany: {
            args: Prisma.ProjectMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          upsert: {
            args: Prisma.ProjectMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          aggregate: {
            args: Prisma.ProjectMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMember>
          }
          groupBy: {
            args: Prisma.ProjectMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberCountAggregateOutputType> | number
          }
        }
      }
      ProjectUpdate: {
        payload: Prisma.$ProjectUpdatePayload<ExtArgs>
        fields: Prisma.ProjectUpdateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectUpdateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectUpdateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
          }
          findFirst: {
            args: Prisma.ProjectUpdateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectUpdateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
          }
          findMany: {
            args: Prisma.ProjectUpdateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>[]
          }
          create: {
            args: Prisma.ProjectUpdateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
          }
          createMany: {
            args: Prisma.ProjectUpdateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectUpdateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>[]
          }
          delete: {
            args: Prisma.ProjectUpdateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
          }
          update: {
            args: Prisma.ProjectUpdateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
          }
          deleteMany: {
            args: Prisma.ProjectUpdateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpdateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
          }
          aggregate: {
            args: Prisma.ProjectUpdateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectUpdate>
          }
          groupBy: {
            args: Prisma.ProjectUpdateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectUpdateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectUpdateCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectUpdateCountAggregateOutputType> | number
          }
        }
      }
      ProjectReward: {
        payload: Prisma.$ProjectRewardPayload<ExtArgs>
        fields: Prisma.ProjectRewardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectRewardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectRewardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRewardPayload>
          }
          findFirst: {
            args: Prisma.ProjectRewardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectRewardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRewardPayload>
          }
          findMany: {
            args: Prisma.ProjectRewardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRewardPayload>[]
          }
          create: {
            args: Prisma.ProjectRewardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRewardPayload>
          }
          createMany: {
            args: Prisma.ProjectRewardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectRewardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRewardPayload>[]
          }
          delete: {
            args: Prisma.ProjectRewardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRewardPayload>
          }
          update: {
            args: Prisma.ProjectRewardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRewardPayload>
          }
          deleteMany: {
            args: Prisma.ProjectRewardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectRewardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectRewardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRewardPayload>[]
          }
          upsert: {
            args: Prisma.ProjectRewardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRewardPayload>
          }
          aggregate: {
            args: Prisma.ProjectRewardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectReward>
          }
          groupBy: {
            args: Prisma.ProjectRewardGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectRewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectRewardCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectRewardCountAggregateOutputType> | number
          }
        }
      }
      ProjectDonation: {
        payload: Prisma.$ProjectDonationPayload<ExtArgs>
        fields: Prisma.ProjectDonationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectDonationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDonationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectDonationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDonationPayload>
          }
          findFirst: {
            args: Prisma.ProjectDonationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDonationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectDonationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDonationPayload>
          }
          findMany: {
            args: Prisma.ProjectDonationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDonationPayload>[]
          }
          create: {
            args: Prisma.ProjectDonationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDonationPayload>
          }
          createMany: {
            args: Prisma.ProjectDonationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectDonationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDonationPayload>[]
          }
          delete: {
            args: Prisma.ProjectDonationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDonationPayload>
          }
          update: {
            args: Prisma.ProjectDonationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDonationPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDonationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectDonationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectDonationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDonationPayload>[]
          }
          upsert: {
            args: Prisma.ProjectDonationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDonationPayload>
          }
          aggregate: {
            args: Prisma.ProjectDonationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectDonation>
          }
          groupBy: {
            args: Prisma.ProjectDonationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectDonationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectDonationCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectDonationCountAggregateOutputType> | number
          }
        }
      }
      ProjectInvestment: {
        payload: Prisma.$ProjectInvestmentPayload<ExtArgs>
        fields: Prisma.ProjectInvestmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectInvestmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvestmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectInvestmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvestmentPayload>
          }
          findFirst: {
            args: Prisma.ProjectInvestmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvestmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectInvestmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvestmentPayload>
          }
          findMany: {
            args: Prisma.ProjectInvestmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvestmentPayload>[]
          }
          create: {
            args: Prisma.ProjectInvestmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvestmentPayload>
          }
          createMany: {
            args: Prisma.ProjectInvestmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectInvestmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvestmentPayload>[]
          }
          delete: {
            args: Prisma.ProjectInvestmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvestmentPayload>
          }
          update: {
            args: Prisma.ProjectInvestmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvestmentPayload>
          }
          deleteMany: {
            args: Prisma.ProjectInvestmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectInvestmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectInvestmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvestmentPayload>[]
          }
          upsert: {
            args: Prisma.ProjectInvestmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectInvestmentPayload>
          }
          aggregate: {
            args: Prisma.ProjectInvestmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectInvestment>
          }
          groupBy: {
            args: Prisma.ProjectInvestmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectInvestmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectInvestmentCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectInvestmentCountAggregateOutputType> | number
          }
        }
      }
      ProjectLoan: {
        payload: Prisma.$ProjectLoanPayload<ExtArgs>
        fields: Prisma.ProjectLoanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectLoanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLoanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectLoanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLoanPayload>
          }
          findFirst: {
            args: Prisma.ProjectLoanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLoanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectLoanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLoanPayload>
          }
          findMany: {
            args: Prisma.ProjectLoanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLoanPayload>[]
          }
          create: {
            args: Prisma.ProjectLoanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLoanPayload>
          }
          createMany: {
            args: Prisma.ProjectLoanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectLoanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLoanPayload>[]
          }
          delete: {
            args: Prisma.ProjectLoanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLoanPayload>
          }
          update: {
            args: Prisma.ProjectLoanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLoanPayload>
          }
          deleteMany: {
            args: Prisma.ProjectLoanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectLoanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectLoanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLoanPayload>[]
          }
          upsert: {
            args: Prisma.ProjectLoanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectLoanPayload>
          }
          aggregate: {
            args: Prisma.ProjectLoanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectLoan>
          }
          groupBy: {
            args: Prisma.ProjectLoanGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectLoanGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectLoanCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectLoanCountAggregateOutputType> | number
          }
        }
      }
      Circle: {
        payload: Prisma.$CirclePayload<ExtArgs>
        fields: Prisma.CircleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CircleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CircleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirclePayload>
          }
          findFirst: {
            args: Prisma.CircleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CircleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirclePayload>
          }
          findMany: {
            args: Prisma.CircleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirclePayload>[]
          }
          create: {
            args: Prisma.CircleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirclePayload>
          }
          createMany: {
            args: Prisma.CircleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CircleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirclePayload>[]
          }
          delete: {
            args: Prisma.CircleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirclePayload>
          }
          update: {
            args: Prisma.CircleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirclePayload>
          }
          deleteMany: {
            args: Prisma.CircleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CircleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CircleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirclePayload>[]
          }
          upsert: {
            args: Prisma.CircleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirclePayload>
          }
          aggregate: {
            args: Prisma.CircleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCircle>
          }
          groupBy: {
            args: Prisma.CircleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CircleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CircleCountArgs<ExtArgs>
            result: $Utils.Optional<CircleCountAggregateOutputType> | number
          }
        }
      }
      CircleMember: {
        payload: Prisma.$CircleMemberPayload<ExtArgs>
        fields: Prisma.CircleMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CircleMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CircleMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleMemberPayload>
          }
          findFirst: {
            args: Prisma.CircleMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CircleMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleMemberPayload>
          }
          findMany: {
            args: Prisma.CircleMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleMemberPayload>[]
          }
          create: {
            args: Prisma.CircleMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleMemberPayload>
          }
          createMany: {
            args: Prisma.CircleMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CircleMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleMemberPayload>[]
          }
          delete: {
            args: Prisma.CircleMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleMemberPayload>
          }
          update: {
            args: Prisma.CircleMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleMemberPayload>
          }
          deleteMany: {
            args: Prisma.CircleMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CircleMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CircleMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleMemberPayload>[]
          }
          upsert: {
            args: Prisma.CircleMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleMemberPayload>
          }
          aggregate: {
            args: Prisma.CircleMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCircleMember>
          }
          groupBy: {
            args: Prisma.CircleMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<CircleMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.CircleMemberCountArgs<ExtArgs>
            result: $Utils.Optional<CircleMemberCountAggregateOutputType> | number
          }
        }
      }
      CircleProject: {
        payload: Prisma.$CircleProjectPayload<ExtArgs>
        fields: Prisma.CircleProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CircleProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CircleProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleProjectPayload>
          }
          findFirst: {
            args: Prisma.CircleProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CircleProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleProjectPayload>
          }
          findMany: {
            args: Prisma.CircleProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleProjectPayload>[]
          }
          create: {
            args: Prisma.CircleProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleProjectPayload>
          }
          createMany: {
            args: Prisma.CircleProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CircleProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleProjectPayload>[]
          }
          delete: {
            args: Prisma.CircleProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleProjectPayload>
          }
          update: {
            args: Prisma.CircleProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleProjectPayload>
          }
          deleteMany: {
            args: Prisma.CircleProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CircleProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CircleProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleProjectPayload>[]
          }
          upsert: {
            args: Prisma.CircleProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CircleProjectPayload>
          }
          aggregate: {
            args: Prisma.CircleProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCircleProject>
          }
          groupBy: {
            args: Prisma.CircleProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<CircleProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.CircleProjectCountArgs<ExtArgs>
            result: $Utils.Optional<CircleProjectCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      UserXP: {
        payload: Prisma.$UserXPPayload<ExtArgs>
        fields: Prisma.UserXPFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserXPFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserXPPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserXPFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserXPPayload>
          }
          findFirst: {
            args: Prisma.UserXPFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserXPPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserXPFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserXPPayload>
          }
          findMany: {
            args: Prisma.UserXPFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserXPPayload>[]
          }
          create: {
            args: Prisma.UserXPCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserXPPayload>
          }
          createMany: {
            args: Prisma.UserXPCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserXPCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserXPPayload>[]
          }
          delete: {
            args: Prisma.UserXPDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserXPPayload>
          }
          update: {
            args: Prisma.UserXPUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserXPPayload>
          }
          deleteMany: {
            args: Prisma.UserXPDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserXPUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserXPUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserXPPayload>[]
          }
          upsert: {
            args: Prisma.UserXPUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserXPPayload>
          }
          aggregate: {
            args: Prisma.UserXPAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserXP>
          }
          groupBy: {
            args: Prisma.UserXPGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserXPGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserXPCountArgs<ExtArgs>
            result: $Utils.Optional<UserXPCountAggregateOutputType> | number
          }
        }
      }
      Badge: {
        payload: Prisma.$BadgePayload<ExtArgs>
        fields: Prisma.BadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findFirst: {
            args: Prisma.BadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findMany: {
            args: Prisma.BadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          create: {
            args: Prisma.BadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          createMany: {
            args: Prisma.BadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          delete: {
            args: Prisma.BadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          update: {
            args: Prisma.BadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          deleteMany: {
            args: Prisma.BadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          upsert: {
            args: Prisma.BadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.BadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      UserBadge: {
        payload: Prisma.$UserBadgePayload<ExtArgs>
        fields: Prisma.UserBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findFirst: {
            args: Prisma.UserBadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findMany: {
            args: Prisma.UserBadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          create: {
            args: Prisma.UserBadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          createMany: {
            args: Prisma.UserBadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          delete: {
            args: Prisma.UserBadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          update: {
            args: Prisma.UserBadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          deleteMany: {
            args: Prisma.UserBadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserBadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          upsert: {
            args: Prisma.UserBadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          aggregate: {
            args: Prisma.UserBadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBadge>
          }
          groupBy: {
            args: Prisma.UserBadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBadgeCountArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
    profile?: ProfileOmit
    adress?: adressOmit
    post?: PostOmit
    mediaAsset?: MediaAssetOmit
    codeSnippet?: CodeSnippetOmit
    tag?: TagOmit
    postsOnTags?: PostsOnTagsOmit
    category?: CategoryOmit
    postsOnCategories?: PostsOnCategoriesOmit
    comment?: CommentOmit
    reaction?: ReactionOmit
    project?: ProjectOmit
    projectMember?: ProjectMemberOmit
    projectUpdate?: ProjectUpdateOmit
    projectReward?: ProjectRewardOmit
    projectDonation?: ProjectDonationOmit
    projectInvestment?: ProjectInvestmentOmit
    projectLoan?: ProjectLoanOmit
    circle?: CircleOmit
    circleMember?: CircleMemberOmit
    circleProject?: CircleProjectOmit
    transaction?: TransactionOmit
    userXP?: UserXPOmit
    badge?: BadgeOmit
    userBadge?: UserBadgeOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    Profile: number
    adress: number
    Post: number
    Project: number
    Circle: number
    Reaction: number
    Comment: number
    ProjectMember: number
    ProjectDonation: number
    ProjectInvestment: number
    ProjectLoan: number
    CircleMember: number
    ProjectUpdate: number
    ProjectReward: number
    UserBadge: number
    UserXP: number
    Transaction: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    Profile?: boolean | UserCountOutputTypeCountProfileArgs
    adress?: boolean | UserCountOutputTypeCountAdressArgs
    Post?: boolean | UserCountOutputTypeCountPostArgs
    Project?: boolean | UserCountOutputTypeCountProjectArgs
    Circle?: boolean | UserCountOutputTypeCountCircleArgs
    Reaction?: boolean | UserCountOutputTypeCountReactionArgs
    Comment?: boolean | UserCountOutputTypeCountCommentArgs
    ProjectMember?: boolean | UserCountOutputTypeCountProjectMemberArgs
    ProjectDonation?: boolean | UserCountOutputTypeCountProjectDonationArgs
    ProjectInvestment?: boolean | UserCountOutputTypeCountProjectInvestmentArgs
    ProjectLoan?: boolean | UserCountOutputTypeCountProjectLoanArgs
    CircleMember?: boolean | UserCountOutputTypeCountCircleMemberArgs
    ProjectUpdate?: boolean | UserCountOutputTypeCountProjectUpdateArgs
    ProjectReward?: boolean | UserCountOutputTypeCountProjectRewardArgs
    UserBadge?: boolean | UserCountOutputTypeCountUserBadgeArgs
    UserXP?: boolean | UserCountOutputTypeCountUserXPArgs
    Transaction?: boolean | UserCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCircleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CircleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectDonationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectDonationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectInvestmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectInvestmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectLoanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectLoanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCircleMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CircleMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectUpdateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectRewardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectRewardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserBadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserXPArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserXPWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    children: number
    attachments: number
    codeSnippets: number
    tags: number
    categories: number
    comments: number
    reactions: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | PostCountOutputTypeCountChildrenArgs
    attachments?: boolean | PostCountOutputTypeCountAttachmentsArgs
    codeSnippets?: boolean | PostCountOutputTypeCountCodeSnippetsArgs
    tags?: boolean | PostCountOutputTypeCountTagsArgs
    categories?: boolean | PostCountOutputTypeCountCategoriesArgs
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
    reactions?: boolean | PostCountOutputTypeCountReactionsArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaAssetWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCodeSnippetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CodeSnippetWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostsOnTagsWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostsOnCategoriesWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    posts: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | TagCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostsOnTagsWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    children: number
    posts: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CategoryCountOutputTypeCountChildrenArgs
    posts?: boolean | CategoryCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostsOnCategoriesWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    children: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CommentCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    members: number
    posts: number
    updates: number
    rewards: number
    donations: number
    investments: number
    loans: number
    Transaction: number
    CircleProject: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ProjectCountOutputTypeCountMembersArgs
    posts?: boolean | ProjectCountOutputTypeCountPostsArgs
    updates?: boolean | ProjectCountOutputTypeCountUpdatesArgs
    rewards?: boolean | ProjectCountOutputTypeCountRewardsArgs
    donations?: boolean | ProjectCountOutputTypeCountDonationsArgs
    investments?: boolean | ProjectCountOutputTypeCountInvestmentsArgs
    loans?: boolean | ProjectCountOutputTypeCountLoansArgs
    Transaction?: boolean | ProjectCountOutputTypeCountTransactionArgs
    CircleProject?: boolean | ProjectCountOutputTypeCountCircleProjectArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountUpdatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectUpdateWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectRewardWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDonationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectDonationWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountInvestmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectInvestmentWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountLoansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectLoanWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCircleProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CircleProjectWhereInput
  }


  /**
   * Count Type ProjectUpdateCountOutputType
   */

  export type ProjectUpdateCountOutputType = {
    User: number
  }

  export type ProjectUpdateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | ProjectUpdateCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * ProjectUpdateCountOutputType without action
   */
  export type ProjectUpdateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdateCountOutputType
     */
    select?: ProjectUpdateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectUpdateCountOutputType without action
   */
  export type ProjectUpdateCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type ProjectRewardCountOutputType
   */

  export type ProjectRewardCountOutputType = {
    ProjectDonation: number
    User: number
  }

  export type ProjectRewardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProjectDonation?: boolean | ProjectRewardCountOutputTypeCountProjectDonationArgs
    User?: boolean | ProjectRewardCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * ProjectRewardCountOutputType without action
   */
  export type ProjectRewardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRewardCountOutputType
     */
    select?: ProjectRewardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectRewardCountOutputType without action
   */
  export type ProjectRewardCountOutputTypeCountProjectDonationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectDonationWhereInput
  }

  /**
   * ProjectRewardCountOutputType without action
   */
  export type ProjectRewardCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type CircleCountOutputType
   */

  export type CircleCountOutputType = {
    members: number
    projects: number
    Transaction: number
  }

  export type CircleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | CircleCountOutputTypeCountMembersArgs
    projects?: boolean | CircleCountOutputTypeCountProjectsArgs
    Transaction?: boolean | CircleCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * CircleCountOutputType without action
   */
  export type CircleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleCountOutputType
     */
    select?: CircleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CircleCountOutputType without action
   */
  export type CircleCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CircleMemberWhereInput
  }

  /**
   * CircleCountOutputType without action
   */
  export type CircleCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CircleProjectWhereInput
  }

  /**
   * CircleCountOutputType without action
   */
  export type CircleCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type BadgeCountOutputType
   */

  export type BadgeCountOutputType = {
    users: number
  }

  export type BadgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | BadgeCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeCountOutputType
     */
    select?: BadgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    roles: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    roles?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string
    emailVerified: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    roles: $Enums.Role[]
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roles?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    Profile?: boolean | User$ProfileArgs<ExtArgs>
    adress?: boolean | User$adressArgs<ExtArgs>
    Post?: boolean | User$PostArgs<ExtArgs>
    Project?: boolean | User$ProjectArgs<ExtArgs>
    Circle?: boolean | User$CircleArgs<ExtArgs>
    Reaction?: boolean | User$ReactionArgs<ExtArgs>
    Comment?: boolean | User$CommentArgs<ExtArgs>
    ProjectMember?: boolean | User$ProjectMemberArgs<ExtArgs>
    ProjectDonation?: boolean | User$ProjectDonationArgs<ExtArgs>
    ProjectInvestment?: boolean | User$ProjectInvestmentArgs<ExtArgs>
    ProjectLoan?: boolean | User$ProjectLoanArgs<ExtArgs>
    CircleMember?: boolean | User$CircleMemberArgs<ExtArgs>
    ProjectUpdate?: boolean | User$ProjectUpdateArgs<ExtArgs>
    ProjectReward?: boolean | User$ProjectRewardArgs<ExtArgs>
    UserBadge?: boolean | User$UserBadgeArgs<ExtArgs>
    UserXP?: boolean | User$UserXPArgs<ExtArgs>
    Transaction?: boolean | User$TransactionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roles?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roles?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roles?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "createdAt" | "updatedAt" | "roles", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    Profile?: boolean | User$ProfileArgs<ExtArgs>
    adress?: boolean | User$adressArgs<ExtArgs>
    Post?: boolean | User$PostArgs<ExtArgs>
    Project?: boolean | User$ProjectArgs<ExtArgs>
    Circle?: boolean | User$CircleArgs<ExtArgs>
    Reaction?: boolean | User$ReactionArgs<ExtArgs>
    Comment?: boolean | User$CommentArgs<ExtArgs>
    ProjectMember?: boolean | User$ProjectMemberArgs<ExtArgs>
    ProjectDonation?: boolean | User$ProjectDonationArgs<ExtArgs>
    ProjectInvestment?: boolean | User$ProjectInvestmentArgs<ExtArgs>
    ProjectLoan?: boolean | User$ProjectLoanArgs<ExtArgs>
    CircleMember?: boolean | User$CircleMemberArgs<ExtArgs>
    ProjectUpdate?: boolean | User$ProjectUpdateArgs<ExtArgs>
    ProjectReward?: boolean | User$ProjectRewardArgs<ExtArgs>
    UserBadge?: boolean | User$UserBadgeArgs<ExtArgs>
    UserXP?: boolean | User$UserXPArgs<ExtArgs>
    Transaction?: boolean | User$TransactionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      Profile: Prisma.$ProfilePayload<ExtArgs>[]
      adress: Prisma.$adressPayload<ExtArgs>[]
      Post: Prisma.$PostPayload<ExtArgs>[]
      Project: Prisma.$ProjectPayload<ExtArgs>[]
      Circle: Prisma.$CirclePayload<ExtArgs>[]
      Reaction: Prisma.$ReactionPayload<ExtArgs>[]
      Comment: Prisma.$CommentPayload<ExtArgs>[]
      ProjectMember: Prisma.$ProjectMemberPayload<ExtArgs>[]
      ProjectDonation: Prisma.$ProjectDonationPayload<ExtArgs>[]
      ProjectInvestment: Prisma.$ProjectInvestmentPayload<ExtArgs>[]
      ProjectLoan: Prisma.$ProjectLoanPayload<ExtArgs>[]
      CircleMember: Prisma.$CircleMemberPayload<ExtArgs>[]
      ProjectUpdate: Prisma.$ProjectUpdatePayload<ExtArgs>[]
      ProjectReward: Prisma.$ProjectRewardPayload<ExtArgs>[]
      UserBadge: Prisma.$UserBadgePayload<ExtArgs>[]
      UserXP: Prisma.$UserXPPayload<ExtArgs>[]
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string
      emailVerified: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
      roles: $Enums.Role[]
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Profile<T extends User$ProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$ProfileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adress<T extends User$adressArgs<ExtArgs> = {}>(args?: Subset<T, User$adressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Post<T extends User$PostArgs<ExtArgs> = {}>(args?: Subset<T, User$PostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Project<T extends User$ProjectArgs<ExtArgs> = {}>(args?: Subset<T, User$ProjectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Circle<T extends User$CircleArgs<ExtArgs> = {}>(args?: Subset<T, User$CircleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CirclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Reaction<T extends User$ReactionArgs<ExtArgs> = {}>(args?: Subset<T, User$ReactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Comment<T extends User$CommentArgs<ExtArgs> = {}>(args?: Subset<T, User$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProjectMember<T extends User$ProjectMemberArgs<ExtArgs> = {}>(args?: Subset<T, User$ProjectMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProjectDonation<T extends User$ProjectDonationArgs<ExtArgs> = {}>(args?: Subset<T, User$ProjectDonationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDonationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProjectInvestment<T extends User$ProjectInvestmentArgs<ExtArgs> = {}>(args?: Subset<T, User$ProjectInvestmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectInvestmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProjectLoan<T extends User$ProjectLoanArgs<ExtArgs> = {}>(args?: Subset<T, User$ProjectLoanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectLoanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CircleMember<T extends User$CircleMemberArgs<ExtArgs> = {}>(args?: Subset<T, User$CircleMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CircleMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProjectUpdate<T extends User$ProjectUpdateArgs<ExtArgs> = {}>(args?: Subset<T, User$ProjectUpdateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProjectReward<T extends User$ProjectRewardArgs<ExtArgs> = {}>(args?: Subset<T, User$ProjectRewardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserBadge<T extends User$UserBadgeArgs<ExtArgs> = {}>(args?: Subset<T, User$UserBadgeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserXP<T extends User$UserXPArgs<ExtArgs> = {}>(args?: Subset<T, User$UserXPArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserXPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transaction<T extends User$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, User$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly roles: FieldRef<"User", 'Role[]'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.Profile
   */
  export type User$ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    cursor?: ProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * User.adress
   */
  export type User$adressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adress
     */
    select?: adressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the adress
     */
    omit?: adressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adressInclude<ExtArgs> | null
    where?: adressWhereInput
    orderBy?: adressOrderByWithRelationInput | adressOrderByWithRelationInput[]
    cursor?: adressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdressScalarFieldEnum | AdressScalarFieldEnum[]
  }

  /**
   * User.Post
   */
  export type User$PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * User.Project
   */
  export type User$ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.Circle
   */
  export type User$CircleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circle
     */
    select?: CircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circle
     */
    omit?: CircleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleInclude<ExtArgs> | null
    where?: CircleWhereInput
    orderBy?: CircleOrderByWithRelationInput | CircleOrderByWithRelationInput[]
    cursor?: CircleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CircleScalarFieldEnum | CircleScalarFieldEnum[]
  }

  /**
   * User.Reaction
   */
  export type User$ReactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    cursor?: ReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * User.Comment
   */
  export type User$CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.ProjectMember
   */
  export type User$ProjectMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * User.ProjectDonation
   */
  export type User$ProjectDonationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDonation
     */
    select?: ProjectDonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDonation
     */
    omit?: ProjectDonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDonationInclude<ExtArgs> | null
    where?: ProjectDonationWhereInput
    orderBy?: ProjectDonationOrderByWithRelationInput | ProjectDonationOrderByWithRelationInput[]
    cursor?: ProjectDonationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectDonationScalarFieldEnum | ProjectDonationScalarFieldEnum[]
  }

  /**
   * User.ProjectInvestment
   */
  export type User$ProjectInvestmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvestment
     */
    select?: ProjectInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvestment
     */
    omit?: ProjectInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvestmentInclude<ExtArgs> | null
    where?: ProjectInvestmentWhereInput
    orderBy?: ProjectInvestmentOrderByWithRelationInput | ProjectInvestmentOrderByWithRelationInput[]
    cursor?: ProjectInvestmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectInvestmentScalarFieldEnum | ProjectInvestmentScalarFieldEnum[]
  }

  /**
   * User.ProjectLoan
   */
  export type User$ProjectLoanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLoan
     */
    select?: ProjectLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLoan
     */
    omit?: ProjectLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLoanInclude<ExtArgs> | null
    where?: ProjectLoanWhereInput
    orderBy?: ProjectLoanOrderByWithRelationInput | ProjectLoanOrderByWithRelationInput[]
    cursor?: ProjectLoanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectLoanScalarFieldEnum | ProjectLoanScalarFieldEnum[]
  }

  /**
   * User.CircleMember
   */
  export type User$CircleMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleMember
     */
    select?: CircleMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleMember
     */
    omit?: CircleMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleMemberInclude<ExtArgs> | null
    where?: CircleMemberWhereInput
    orderBy?: CircleMemberOrderByWithRelationInput | CircleMemberOrderByWithRelationInput[]
    cursor?: CircleMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CircleMemberScalarFieldEnum | CircleMemberScalarFieldEnum[]
  }

  /**
   * User.ProjectUpdate
   */
  export type User$ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    where?: ProjectUpdateWhereInput
    orderBy?: ProjectUpdateOrderByWithRelationInput | ProjectUpdateOrderByWithRelationInput[]
    cursor?: ProjectUpdateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectUpdateScalarFieldEnum | ProjectUpdateScalarFieldEnum[]
  }

  /**
   * User.ProjectReward
   */
  export type User$ProjectRewardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectReward
     */
    select?: ProjectRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectReward
     */
    omit?: ProjectRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRewardInclude<ExtArgs> | null
    where?: ProjectRewardWhereInput
    orderBy?: ProjectRewardOrderByWithRelationInput | ProjectRewardOrderByWithRelationInput[]
    cursor?: ProjectRewardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectRewardScalarFieldEnum | ProjectRewardScalarFieldEnum[]
  }

  /**
   * User.UserBadge
   */
  export type User$UserBadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    cursor?: UserBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * User.UserXP
   */
  export type User$UserXPArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserXP
     */
    select?: UserXPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserXP
     */
    omit?: UserXPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserXPInclude<ExtArgs> | null
    where?: UserXPWhereInput
    orderBy?: UserXPOrderByWithRelationInput | UserXPOrderByWithRelationInput[]
    cursor?: UserXPWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserXPScalarFieldEnum | UserXPScalarFieldEnum[]
  }

  /**
   * User.Transaction
   */
  export type User$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "ipAddress" | "userAgent" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    idToken: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    idToken: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    accountId: number
    providerId: number
    accessToken: number
    refreshToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    idToken: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    idToken?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    idToken?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    idToken?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    accountId: string
    providerId: string
    accessToken: string | null
    refreshToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    idToken: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "accountId" | "providerId" | "accessToken" | "refreshToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "idToken" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountId: string
      providerId: string
      accessToken: string | null
      refreshToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      idToken: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    age: number | null
  }

  export type ProfileSumAggregateOutputType = {
    age: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    age: number | null
    profession: string | null
    motivation: string | null
    experience: string | null
    disponibility: string | null
    bio: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    phoneVerified: boolean | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    age: number | null
    profession: string | null
    motivation: string | null
    experience: string | null
    disponibility: string | null
    bio: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    phoneVerified: boolean | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    age: number
    profession: number
    motivation: number
    interests: number
    experience: number
    disponibility: number
    bio: number
    firstName: number
    lastName: number
    phone: number
    phoneVerified: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    age?: true
  }

  export type ProfileSumAggregateInputType = {
    age?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    age?: true
    profession?: true
    motivation?: true
    experience?: true
    disponibility?: true
    bio?: true
    firstName?: true
    lastName?: true
    phone?: true
    phoneVerified?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    age?: true
    profession?: true
    motivation?: true
    experience?: true
    disponibility?: true
    bio?: true
    firstName?: true
    lastName?: true
    phone?: true
    phoneVerified?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    age?: true
    profession?: true
    motivation?: true
    interests?: true
    experience?: true
    disponibility?: true
    bio?: true
    firstName?: true
    lastName?: true
    phone?: true
    phoneVerified?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    age: number | null
    profession: string | null
    motivation: string | null
    interests: string[]
    experience: string | null
    disponibility: string | null
    bio: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    phoneVerified: boolean
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    age?: boolean
    profession?: boolean
    motivation?: boolean
    interests?: boolean
    experience?: boolean
    disponibility?: boolean
    bio?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    phoneVerified?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    age?: boolean
    profession?: boolean
    motivation?: boolean
    interests?: boolean
    experience?: boolean
    disponibility?: boolean
    bio?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    phoneVerified?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    age?: boolean
    profession?: boolean
    motivation?: boolean
    interests?: boolean
    experience?: boolean
    disponibility?: boolean
    bio?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    phoneVerified?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    age?: boolean
    profession?: boolean
    motivation?: boolean
    interests?: boolean
    experience?: boolean
    disponibility?: boolean
    bio?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    phoneVerified?: boolean
  }

  export type ProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "age" | "profession" | "motivation" | "interests" | "experience" | "disponibility" | "bio" | "firstName" | "lastName" | "phone" | "phoneVerified", ExtArgs["result"]["profile"]>
  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      age: number | null
      profession: string | null
      motivation: string | null
      interests: string[]
      experience: string | null
      disponibility: string | null
      bio: string | null
      firstName: string | null
      lastName: string | null
      phone: string | null
      phoneVerified: boolean
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {ProfileUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly age: FieldRef<"Profile", 'Int'>
    readonly profession: FieldRef<"Profile", 'String'>
    readonly motivation: FieldRef<"Profile", 'String'>
    readonly interests: FieldRef<"Profile", 'String[]'>
    readonly experience: FieldRef<"Profile", 'String'>
    readonly disponibility: FieldRef<"Profile", 'String'>
    readonly bio: FieldRef<"Profile", 'String'>
    readonly firstName: FieldRef<"Profile", 'String'>
    readonly lastName: FieldRef<"Profile", 'String'>
    readonly phone: FieldRef<"Profile", 'String'>
    readonly phoneVerified: FieldRef<"Profile", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile updateManyAndReturn
   */
  export type ProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to delete.
     */
    limit?: number
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model adress
   */

  export type AggregateAdress = {
    _count: AdressCountAggregateOutputType | null
    _min: AdressMinAggregateOutputType | null
    _max: AdressMaxAggregateOutputType | null
  }

  export type AdressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    street: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
  }

  export type AdressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    street: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
  }

  export type AdressCountAggregateOutputType = {
    id: number
    userId: number
    street: number
    city: number
    state: number
    postalCode: number
    country: number
    _all: number
  }


  export type AdressMinAggregateInputType = {
    id?: true
    userId?: true
    street?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
  }

  export type AdressMaxAggregateInputType = {
    id?: true
    userId?: true
    street?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
  }

  export type AdressCountAggregateInputType = {
    id?: true
    userId?: true
    street?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    _all?: true
  }

  export type AdressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which adress to aggregate.
     */
    where?: adressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of adresses to fetch.
     */
    orderBy?: adressOrderByWithRelationInput | adressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: adressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` adresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned adresses
    **/
    _count?: true | AdressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdressMaxAggregateInputType
  }

  export type GetAdressAggregateType<T extends AdressAggregateArgs> = {
        [P in keyof T & keyof AggregateAdress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdress[P]>
      : GetScalarType<T[P], AggregateAdress[P]>
  }




  export type adressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adressWhereInput
    orderBy?: adressOrderByWithAggregationInput | adressOrderByWithAggregationInput[]
    by: AdressScalarFieldEnum[] | AdressScalarFieldEnum
    having?: adressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdressCountAggregateInputType | true
    _min?: AdressMinAggregateInputType
    _max?: AdressMaxAggregateInputType
  }

  export type AdressGroupByOutputType = {
    id: string
    userId: string
    street: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    _count: AdressCountAggregateOutputType | null
    _min: AdressMinAggregateOutputType | null
    _max: AdressMaxAggregateOutputType | null
  }

  type GetAdressGroupByPayload<T extends adressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdressGroupByOutputType[P]>
            : GetScalarType<T[P], AdressGroupByOutputType[P]>
        }
      >
    >


  export type adressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adress"]>

  export type adressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adress"]>

  export type adressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adress"]>

  export type adressSelectScalar = {
    id?: boolean
    userId?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
  }

  export type adressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "street" | "city" | "state" | "postalCode" | "country", ExtArgs["result"]["adress"]>
  export type adressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type adressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type adressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $adressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "adress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      street: string | null
      city: string | null
      state: string | null
      postalCode: string | null
      country: string | null
    }, ExtArgs["result"]["adress"]>
    composites: {}
  }

  type adressGetPayload<S extends boolean | null | undefined | adressDefaultArgs> = $Result.GetResult<Prisma.$adressPayload, S>

  type adressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<adressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdressCountAggregateInputType | true
    }

  export interface adressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['adress'], meta: { name: 'adress' } }
    /**
     * Find zero or one Adress that matches the filter.
     * @param {adressFindUniqueArgs} args - Arguments to find a Adress
     * @example
     * // Get one Adress
     * const adress = await prisma.adress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends adressFindUniqueArgs>(args: SelectSubset<T, adressFindUniqueArgs<ExtArgs>>): Prisma__adressClient<$Result.GetResult<Prisma.$adressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Adress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {adressFindUniqueOrThrowArgs} args - Arguments to find a Adress
     * @example
     * // Get one Adress
     * const adress = await prisma.adress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends adressFindUniqueOrThrowArgs>(args: SelectSubset<T, adressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__adressClient<$Result.GetResult<Prisma.$adressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Adress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adressFindFirstArgs} args - Arguments to find a Adress
     * @example
     * // Get one Adress
     * const adress = await prisma.adress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends adressFindFirstArgs>(args?: SelectSubset<T, adressFindFirstArgs<ExtArgs>>): Prisma__adressClient<$Result.GetResult<Prisma.$adressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Adress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adressFindFirstOrThrowArgs} args - Arguments to find a Adress
     * @example
     * // Get one Adress
     * const adress = await prisma.adress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends adressFindFirstOrThrowArgs>(args?: SelectSubset<T, adressFindFirstOrThrowArgs<ExtArgs>>): Prisma__adressClient<$Result.GetResult<Prisma.$adressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Adresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Adresses
     * const adresses = await prisma.adress.findMany()
     * 
     * // Get first 10 Adresses
     * const adresses = await prisma.adress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adressWithIdOnly = await prisma.adress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends adressFindManyArgs>(args?: SelectSubset<T, adressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Adress.
     * @param {adressCreateArgs} args - Arguments to create a Adress.
     * @example
     * // Create one Adress
     * const Adress = await prisma.adress.create({
     *   data: {
     *     // ... data to create a Adress
     *   }
     * })
     * 
     */
    create<T extends adressCreateArgs>(args: SelectSubset<T, adressCreateArgs<ExtArgs>>): Prisma__adressClient<$Result.GetResult<Prisma.$adressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Adresses.
     * @param {adressCreateManyArgs} args - Arguments to create many Adresses.
     * @example
     * // Create many Adresses
     * const adress = await prisma.adress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends adressCreateManyArgs>(args?: SelectSubset<T, adressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Adresses and returns the data saved in the database.
     * @param {adressCreateManyAndReturnArgs} args - Arguments to create many Adresses.
     * @example
     * // Create many Adresses
     * const adress = await prisma.adress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Adresses and only return the `id`
     * const adressWithIdOnly = await prisma.adress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends adressCreateManyAndReturnArgs>(args?: SelectSubset<T, adressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Adress.
     * @param {adressDeleteArgs} args - Arguments to delete one Adress.
     * @example
     * // Delete one Adress
     * const Adress = await prisma.adress.delete({
     *   where: {
     *     // ... filter to delete one Adress
     *   }
     * })
     * 
     */
    delete<T extends adressDeleteArgs>(args: SelectSubset<T, adressDeleteArgs<ExtArgs>>): Prisma__adressClient<$Result.GetResult<Prisma.$adressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Adress.
     * @param {adressUpdateArgs} args - Arguments to update one Adress.
     * @example
     * // Update one Adress
     * const adress = await prisma.adress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends adressUpdateArgs>(args: SelectSubset<T, adressUpdateArgs<ExtArgs>>): Prisma__adressClient<$Result.GetResult<Prisma.$adressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Adresses.
     * @param {adressDeleteManyArgs} args - Arguments to filter Adresses to delete.
     * @example
     * // Delete a few Adresses
     * const { count } = await prisma.adress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends adressDeleteManyArgs>(args?: SelectSubset<T, adressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Adresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Adresses
     * const adress = await prisma.adress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends adressUpdateManyArgs>(args: SelectSubset<T, adressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Adresses and returns the data updated in the database.
     * @param {adressUpdateManyAndReturnArgs} args - Arguments to update many Adresses.
     * @example
     * // Update many Adresses
     * const adress = await prisma.adress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Adresses and only return the `id`
     * const adressWithIdOnly = await prisma.adress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends adressUpdateManyAndReturnArgs>(args: SelectSubset<T, adressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Adress.
     * @param {adressUpsertArgs} args - Arguments to update or create a Adress.
     * @example
     * // Update or create a Adress
     * const adress = await prisma.adress.upsert({
     *   create: {
     *     // ... data to create a Adress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Adress we want to update
     *   }
     * })
     */
    upsert<T extends adressUpsertArgs>(args: SelectSubset<T, adressUpsertArgs<ExtArgs>>): Prisma__adressClient<$Result.GetResult<Prisma.$adressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Adresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adressCountArgs} args - Arguments to filter Adresses to count.
     * @example
     * // Count the number of Adresses
     * const count = await prisma.adress.count({
     *   where: {
     *     // ... the filter for the Adresses we want to count
     *   }
     * })
    **/
    count<T extends adressCountArgs>(
      args?: Subset<T, adressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Adress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdressAggregateArgs>(args: Subset<T, AdressAggregateArgs>): Prisma.PrismaPromise<GetAdressAggregateType<T>>

    /**
     * Group by Adress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends adressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: adressGroupByArgs['orderBy'] }
        : { orderBy?: adressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, adressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the adress model
   */
  readonly fields: adressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for adress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__adressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the adress model
   */
  interface adressFieldRefs {
    readonly id: FieldRef<"adress", 'String'>
    readonly userId: FieldRef<"adress", 'String'>
    readonly street: FieldRef<"adress", 'String'>
    readonly city: FieldRef<"adress", 'String'>
    readonly state: FieldRef<"adress", 'String'>
    readonly postalCode: FieldRef<"adress", 'String'>
    readonly country: FieldRef<"adress", 'String'>
  }
    

  // Custom InputTypes
  /**
   * adress findUnique
   */
  export type adressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adress
     */
    select?: adressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the adress
     */
    omit?: adressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adressInclude<ExtArgs> | null
    /**
     * Filter, which adress to fetch.
     */
    where: adressWhereUniqueInput
  }

  /**
   * adress findUniqueOrThrow
   */
  export type adressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adress
     */
    select?: adressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the adress
     */
    omit?: adressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adressInclude<ExtArgs> | null
    /**
     * Filter, which adress to fetch.
     */
    where: adressWhereUniqueInput
  }

  /**
   * adress findFirst
   */
  export type adressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adress
     */
    select?: adressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the adress
     */
    omit?: adressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adressInclude<ExtArgs> | null
    /**
     * Filter, which adress to fetch.
     */
    where?: adressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of adresses to fetch.
     */
    orderBy?: adressOrderByWithRelationInput | adressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for adresses.
     */
    cursor?: adressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` adresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of adresses.
     */
    distinct?: AdressScalarFieldEnum | AdressScalarFieldEnum[]
  }

  /**
   * adress findFirstOrThrow
   */
  export type adressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adress
     */
    select?: adressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the adress
     */
    omit?: adressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adressInclude<ExtArgs> | null
    /**
     * Filter, which adress to fetch.
     */
    where?: adressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of adresses to fetch.
     */
    orderBy?: adressOrderByWithRelationInput | adressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for adresses.
     */
    cursor?: adressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` adresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of adresses.
     */
    distinct?: AdressScalarFieldEnum | AdressScalarFieldEnum[]
  }

  /**
   * adress findMany
   */
  export type adressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adress
     */
    select?: adressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the adress
     */
    omit?: adressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adressInclude<ExtArgs> | null
    /**
     * Filter, which adresses to fetch.
     */
    where?: adressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of adresses to fetch.
     */
    orderBy?: adressOrderByWithRelationInput | adressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing adresses.
     */
    cursor?: adressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` adresses.
     */
    skip?: number
    distinct?: AdressScalarFieldEnum | AdressScalarFieldEnum[]
  }

  /**
   * adress create
   */
  export type adressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adress
     */
    select?: adressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the adress
     */
    omit?: adressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adressInclude<ExtArgs> | null
    /**
     * The data needed to create a adress.
     */
    data: XOR<adressCreateInput, adressUncheckedCreateInput>
  }

  /**
   * adress createMany
   */
  export type adressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many adresses.
     */
    data: adressCreateManyInput | adressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * adress createManyAndReturn
   */
  export type adressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adress
     */
    select?: adressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the adress
     */
    omit?: adressOmit<ExtArgs> | null
    /**
     * The data used to create many adresses.
     */
    data: adressCreateManyInput | adressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * adress update
   */
  export type adressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adress
     */
    select?: adressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the adress
     */
    omit?: adressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adressInclude<ExtArgs> | null
    /**
     * The data needed to update a adress.
     */
    data: XOR<adressUpdateInput, adressUncheckedUpdateInput>
    /**
     * Choose, which adress to update.
     */
    where: adressWhereUniqueInput
  }

  /**
   * adress updateMany
   */
  export type adressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update adresses.
     */
    data: XOR<adressUpdateManyMutationInput, adressUncheckedUpdateManyInput>
    /**
     * Filter which adresses to update
     */
    where?: adressWhereInput
    /**
     * Limit how many adresses to update.
     */
    limit?: number
  }

  /**
   * adress updateManyAndReturn
   */
  export type adressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adress
     */
    select?: adressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the adress
     */
    omit?: adressOmit<ExtArgs> | null
    /**
     * The data used to update adresses.
     */
    data: XOR<adressUpdateManyMutationInput, adressUncheckedUpdateManyInput>
    /**
     * Filter which adresses to update
     */
    where?: adressWhereInput
    /**
     * Limit how many adresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * adress upsert
   */
  export type adressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adress
     */
    select?: adressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the adress
     */
    omit?: adressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adressInclude<ExtArgs> | null
    /**
     * The filter to search for the adress to update in case it exists.
     */
    where: adressWhereUniqueInput
    /**
     * In case the adress found by the `where` argument doesn't exist, create a new adress with this data.
     */
    create: XOR<adressCreateInput, adressUncheckedCreateInput>
    /**
     * In case the adress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<adressUpdateInput, adressUncheckedUpdateInput>
  }

  /**
   * adress delete
   */
  export type adressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adress
     */
    select?: adressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the adress
     */
    omit?: adressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adressInclude<ExtArgs> | null
    /**
     * Filter which adress to delete.
     */
    where: adressWhereUniqueInput
  }

  /**
   * adress deleteMany
   */
  export type adressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which adresses to delete
     */
    where?: adressWhereInput
    /**
     * Limit how many adresses to delete.
     */
    limit?: number
  }

  /**
   * adress without action
   */
  export type adressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adress
     */
    select?: adressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the adress
     */
    omit?: adressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adressInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    readingTime: number | null
    wordCount: number | null
  }

  export type PostSumAggregateOutputType = {
    readingTime: number | null
    wordCount: number | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    subtitle: string | null
    contentText: string | null
    excerpt: string | null
    coverImageUrl: string | null
    canonicalUrl: string | null
    ogImageUrl: string | null
    status: $Enums.PostStatus | null
    visibility: $Enums.PostVisibility | null
    publishedAt: Date | null
    scheduledAt: Date | null
    readingTime: number | null
    wordCount: number | null
    language: string | null
    authorId: string | null
    parentId: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    subtitle: string | null
    contentText: string | null
    excerpt: string | null
    coverImageUrl: string | null
    canonicalUrl: string | null
    ogImageUrl: string | null
    status: $Enums.PostStatus | null
    visibility: $Enums.PostVisibility | null
    publishedAt: Date | null
    scheduledAt: Date | null
    readingTime: number | null
    wordCount: number | null
    language: string | null
    authorId: string | null
    parentId: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    subtitle: number
    content: number
    contentText: number
    excerpt: number
    coverImageUrl: number
    canonicalUrl: number
    ogImageUrl: number
    status: number
    visibility: number
    publishedAt: number
    scheduledAt: number
    readingTime: number
    wordCount: number
    language: number
    authorId: number
    parentId: number
    projectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    readingTime?: true
    wordCount?: true
  }

  export type PostSumAggregateInputType = {
    readingTime?: true
    wordCount?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    subtitle?: true
    contentText?: true
    excerpt?: true
    coverImageUrl?: true
    canonicalUrl?: true
    ogImageUrl?: true
    status?: true
    visibility?: true
    publishedAt?: true
    scheduledAt?: true
    readingTime?: true
    wordCount?: true
    language?: true
    authorId?: true
    parentId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    subtitle?: true
    contentText?: true
    excerpt?: true
    coverImageUrl?: true
    canonicalUrl?: true
    ogImageUrl?: true
    status?: true
    visibility?: true
    publishedAt?: true
    scheduledAt?: true
    readingTime?: true
    wordCount?: true
    language?: true
    authorId?: true
    parentId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    subtitle?: true
    content?: true
    contentText?: true
    excerpt?: true
    coverImageUrl?: true
    canonicalUrl?: true
    ogImageUrl?: true
    status?: true
    visibility?: true
    publishedAt?: true
    scheduledAt?: true
    readingTime?: true
    wordCount?: true
    language?: true
    authorId?: true
    parentId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    slug: string
    title: string
    subtitle: string | null
    content: JsonValue | null
    contentText: string | null
    excerpt: string | null
    coverImageUrl: string | null
    canonicalUrl: string | null
    ogImageUrl: string | null
    status: $Enums.PostStatus
    visibility: $Enums.PostVisibility
    publishedAt: Date | null
    scheduledAt: Date | null
    readingTime: number | null
    wordCount: number | null
    language: string | null
    authorId: string
    parentId: string | null
    projectId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    subtitle?: boolean
    content?: boolean
    contentText?: boolean
    excerpt?: boolean
    coverImageUrl?: boolean
    canonicalUrl?: boolean
    ogImageUrl?: boolean
    status?: boolean
    visibility?: boolean
    publishedAt?: boolean
    scheduledAt?: boolean
    readingTime?: boolean
    wordCount?: boolean
    language?: boolean
    authorId?: boolean
    parentId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Post$parentArgs<ExtArgs>
    children?: boolean | Post$childrenArgs<ExtArgs>
    attachments?: boolean | Post$attachmentsArgs<ExtArgs>
    codeSnippets?: boolean | Post$codeSnippetsArgs<ExtArgs>
    tags?: boolean | Post$tagsArgs<ExtArgs>
    categories?: boolean | Post$categoriesArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    reactions?: boolean | Post$reactionsArgs<ExtArgs>
    project?: boolean | Post$projectArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    subtitle?: boolean
    content?: boolean
    contentText?: boolean
    excerpt?: boolean
    coverImageUrl?: boolean
    canonicalUrl?: boolean
    ogImageUrl?: boolean
    status?: boolean
    visibility?: boolean
    publishedAt?: boolean
    scheduledAt?: boolean
    readingTime?: boolean
    wordCount?: boolean
    language?: boolean
    authorId?: boolean
    parentId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Post$parentArgs<ExtArgs>
    project?: boolean | Post$projectArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    subtitle?: boolean
    content?: boolean
    contentText?: boolean
    excerpt?: boolean
    coverImageUrl?: boolean
    canonicalUrl?: boolean
    ogImageUrl?: boolean
    status?: boolean
    visibility?: boolean
    publishedAt?: boolean
    scheduledAt?: boolean
    readingTime?: boolean
    wordCount?: boolean
    language?: boolean
    authorId?: boolean
    parentId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Post$parentArgs<ExtArgs>
    project?: boolean | Post$projectArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    subtitle?: boolean
    content?: boolean
    contentText?: boolean
    excerpt?: boolean
    coverImageUrl?: boolean
    canonicalUrl?: boolean
    ogImageUrl?: boolean
    status?: boolean
    visibility?: boolean
    publishedAt?: boolean
    scheduledAt?: boolean
    readingTime?: boolean
    wordCount?: boolean
    language?: boolean
    authorId?: boolean
    parentId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "title" | "subtitle" | "content" | "contentText" | "excerpt" | "coverImageUrl" | "canonicalUrl" | "ogImageUrl" | "status" | "visibility" | "publishedAt" | "scheduledAt" | "readingTime" | "wordCount" | "language" | "authorId" | "parentId" | "projectId" | "createdAt" | "updatedAt", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Post$parentArgs<ExtArgs>
    children?: boolean | Post$childrenArgs<ExtArgs>
    attachments?: boolean | Post$attachmentsArgs<ExtArgs>
    codeSnippets?: boolean | Post$codeSnippetsArgs<ExtArgs>
    tags?: boolean | Post$tagsArgs<ExtArgs>
    categories?: boolean | Post$categoriesArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    reactions?: boolean | Post$reactionsArgs<ExtArgs>
    project?: boolean | Post$projectArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Post$parentArgs<ExtArgs>
    project?: boolean | Post$projectArgs<ExtArgs>
  }
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Post$parentArgs<ExtArgs>
    project?: boolean | Post$projectArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$PostPayload<ExtArgs> | null
      children: Prisma.$PostPayload<ExtArgs>[]
      attachments: Prisma.$MediaAssetPayload<ExtArgs>[]
      codeSnippets: Prisma.$CodeSnippetPayload<ExtArgs>[]
      tags: Prisma.$PostsOnTagsPayload<ExtArgs>[]
      categories: Prisma.$PostsOnCategoriesPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      reactions: Prisma.$ReactionPayload<ExtArgs>[]
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
      subtitle: string | null
      content: Prisma.JsonValue | null
      contentText: string | null
      excerpt: string | null
      coverImageUrl: string | null
      canonicalUrl: string | null
      ogImageUrl: string | null
      status: $Enums.PostStatus
      visibility: $Enums.PostVisibility
      publishedAt: Date | null
      scheduledAt: Date | null
      readingTime: number | null
      wordCount: number | null
      language: string | null
      authorId: string
      parentId: string | null
      projectId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends Post$parentArgs<ExtArgs> = {}>(args?: Subset<T, Post$parentArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Post$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Post$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends Post$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    codeSnippets<T extends Post$codeSnippetsArgs<ExtArgs> = {}>(args?: Subset<T, Post$codeSnippetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeSnippetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Post$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Post$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsOnTagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends Post$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Post$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsOnCategoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reactions<T extends Post$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, Post$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    project<T extends Post$projectArgs<ExtArgs> = {}>(args?: Subset<T, Post$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly slug: FieldRef<"Post", 'String'>
    readonly title: FieldRef<"Post", 'String'>
    readonly subtitle: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'Json'>
    readonly contentText: FieldRef<"Post", 'String'>
    readonly excerpt: FieldRef<"Post", 'String'>
    readonly coverImageUrl: FieldRef<"Post", 'String'>
    readonly canonicalUrl: FieldRef<"Post", 'String'>
    readonly ogImageUrl: FieldRef<"Post", 'String'>
    readonly status: FieldRef<"Post", 'PostStatus'>
    readonly visibility: FieldRef<"Post", 'PostVisibility'>
    readonly publishedAt: FieldRef<"Post", 'DateTime'>
    readonly scheduledAt: FieldRef<"Post", 'DateTime'>
    readonly readingTime: FieldRef<"Post", 'Int'>
    readonly wordCount: FieldRef<"Post", 'Int'>
    readonly language: FieldRef<"Post", 'String'>
    readonly authorId: FieldRef<"Post", 'String'>
    readonly parentId: FieldRef<"Post", 'String'>
    readonly projectId: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post.parent
   */
  export type Post$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
  }

  /**
   * Post.children
   */
  export type Post$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post.attachments
   */
  export type Post$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    where?: MediaAssetWhereInput
    orderBy?: MediaAssetOrderByWithRelationInput | MediaAssetOrderByWithRelationInput[]
    cursor?: MediaAssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaAssetScalarFieldEnum | MediaAssetScalarFieldEnum[]
  }

  /**
   * Post.codeSnippets
   */
  export type Post$codeSnippetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSnippet
     */
    select?: CodeSnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSnippet
     */
    omit?: CodeSnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSnippetInclude<ExtArgs> | null
    where?: CodeSnippetWhereInput
    orderBy?: CodeSnippetOrderByWithRelationInput | CodeSnippetOrderByWithRelationInput[]
    cursor?: CodeSnippetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CodeSnippetScalarFieldEnum | CodeSnippetScalarFieldEnum[]
  }

  /**
   * Post.tags
   */
  export type Post$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnTags
     */
    select?: PostsOnTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnTags
     */
    omit?: PostsOnTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnTagsInclude<ExtArgs> | null
    where?: PostsOnTagsWhereInput
    orderBy?: PostsOnTagsOrderByWithRelationInput | PostsOnTagsOrderByWithRelationInput[]
    cursor?: PostsOnTagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostsOnTagsScalarFieldEnum | PostsOnTagsScalarFieldEnum[]
  }

  /**
   * Post.categories
   */
  export type Post$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnCategories
     */
    select?: PostsOnCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnCategories
     */
    omit?: PostsOnCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnCategoriesInclude<ExtArgs> | null
    where?: PostsOnCategoriesWhereInput
    orderBy?: PostsOnCategoriesOrderByWithRelationInput | PostsOnCategoriesOrderByWithRelationInput[]
    cursor?: PostsOnCategoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostsOnCategoriesScalarFieldEnum | PostsOnCategoriesScalarFieldEnum[]
  }

  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Post.reactions
   */
  export type Post$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    cursor?: ReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Post.project
   */
  export type Post$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model MediaAsset
   */

  export type AggregateMediaAsset = {
    _count: MediaAssetCountAggregateOutputType | null
    _avg: MediaAssetAvgAggregateOutputType | null
    _sum: MediaAssetSumAggregateOutputType | null
    _min: MediaAssetMinAggregateOutputType | null
    _max: MediaAssetMaxAggregateOutputType | null
  }

  export type MediaAssetAvgAggregateOutputType = {
    position: number | null
    sizeBytes: number | null
    width: number | null
    height: number | null
    durationMs: number | null
  }

  export type MediaAssetSumAggregateOutputType = {
    position: number | null
    sizeBytes: number | null
    width: number | null
    height: number | null
    durationMs: number | null
  }

  export type MediaAssetMinAggregateOutputType = {
    id: string | null
    postId: string | null
    type: $Enums.MediaType | null
    url: string | null
    provider: string | null
    title: string | null
    alt: string | null
    caption: string | null
    position: number | null
    mimeType: string | null
    sizeBytes: number | null
    width: number | null
    height: number | null
    durationMs: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaAssetMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    type: $Enums.MediaType | null
    url: string | null
    provider: string | null
    title: string | null
    alt: string | null
    caption: string | null
    position: number | null
    mimeType: string | null
    sizeBytes: number | null
    width: number | null
    height: number | null
    durationMs: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaAssetCountAggregateOutputType = {
    id: number
    postId: number
    type: number
    url: number
    provider: number
    title: number
    alt: number
    caption: number
    position: number
    mimeType: number
    sizeBytes: number
    width: number
    height: number
    durationMs: number
    meta: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MediaAssetAvgAggregateInputType = {
    position?: true
    sizeBytes?: true
    width?: true
    height?: true
    durationMs?: true
  }

  export type MediaAssetSumAggregateInputType = {
    position?: true
    sizeBytes?: true
    width?: true
    height?: true
    durationMs?: true
  }

  export type MediaAssetMinAggregateInputType = {
    id?: true
    postId?: true
    type?: true
    url?: true
    provider?: true
    title?: true
    alt?: true
    caption?: true
    position?: true
    mimeType?: true
    sizeBytes?: true
    width?: true
    height?: true
    durationMs?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaAssetMaxAggregateInputType = {
    id?: true
    postId?: true
    type?: true
    url?: true
    provider?: true
    title?: true
    alt?: true
    caption?: true
    position?: true
    mimeType?: true
    sizeBytes?: true
    width?: true
    height?: true
    durationMs?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaAssetCountAggregateInputType = {
    id?: true
    postId?: true
    type?: true
    url?: true
    provider?: true
    title?: true
    alt?: true
    caption?: true
    position?: true
    mimeType?: true
    sizeBytes?: true
    width?: true
    height?: true
    durationMs?: true
    meta?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MediaAssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaAsset to aggregate.
     */
    where?: MediaAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAssets to fetch.
     */
    orderBy?: MediaAssetOrderByWithRelationInput | MediaAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaAssets
    **/
    _count?: true | MediaAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaAssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaAssetMaxAggregateInputType
  }

  export type GetMediaAssetAggregateType<T extends MediaAssetAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaAsset[P]>
      : GetScalarType<T[P], AggregateMediaAsset[P]>
  }




  export type MediaAssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaAssetWhereInput
    orderBy?: MediaAssetOrderByWithAggregationInput | MediaAssetOrderByWithAggregationInput[]
    by: MediaAssetScalarFieldEnum[] | MediaAssetScalarFieldEnum
    having?: MediaAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaAssetCountAggregateInputType | true
    _avg?: MediaAssetAvgAggregateInputType
    _sum?: MediaAssetSumAggregateInputType
    _min?: MediaAssetMinAggregateInputType
    _max?: MediaAssetMaxAggregateInputType
  }

  export type MediaAssetGroupByOutputType = {
    id: string
    postId: string
    type: $Enums.MediaType
    url: string
    provider: string | null
    title: string | null
    alt: string | null
    caption: string | null
    position: number | null
    mimeType: string | null
    sizeBytes: number | null
    width: number | null
    height: number | null
    durationMs: number | null
    meta: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: MediaAssetCountAggregateOutputType | null
    _avg: MediaAssetAvgAggregateOutputType | null
    _sum: MediaAssetSumAggregateOutputType | null
    _min: MediaAssetMinAggregateOutputType | null
    _max: MediaAssetMaxAggregateOutputType | null
  }

  type GetMediaAssetGroupByPayload<T extends MediaAssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaAssetGroupByOutputType[P]>
            : GetScalarType<T[P], MediaAssetGroupByOutputType[P]>
        }
      >
    >


  export type MediaAssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    type?: boolean
    url?: boolean
    provider?: boolean
    title?: boolean
    alt?: boolean
    caption?: boolean
    position?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    width?: boolean
    height?: boolean
    durationMs?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaAsset"]>

  export type MediaAssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    type?: boolean
    url?: boolean
    provider?: boolean
    title?: boolean
    alt?: boolean
    caption?: boolean
    position?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    width?: boolean
    height?: boolean
    durationMs?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaAsset"]>

  export type MediaAssetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    type?: boolean
    url?: boolean
    provider?: boolean
    title?: boolean
    alt?: boolean
    caption?: boolean
    position?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    width?: boolean
    height?: boolean
    durationMs?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaAsset"]>

  export type MediaAssetSelectScalar = {
    id?: boolean
    postId?: boolean
    type?: boolean
    url?: boolean
    provider?: boolean
    title?: boolean
    alt?: boolean
    caption?: boolean
    position?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    width?: boolean
    height?: boolean
    durationMs?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MediaAssetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "type" | "url" | "provider" | "title" | "alt" | "caption" | "position" | "mimeType" | "sizeBytes" | "width" | "height" | "durationMs" | "meta" | "createdAt" | "updatedAt", ExtArgs["result"]["mediaAsset"]>
  export type MediaAssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type MediaAssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type MediaAssetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $MediaAssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaAsset"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      type: $Enums.MediaType
      url: string
      provider: string | null
      title: string | null
      alt: string | null
      caption: string | null
      position: number | null
      mimeType: string | null
      sizeBytes: number | null
      width: number | null
      height: number | null
      durationMs: number | null
      meta: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mediaAsset"]>
    composites: {}
  }

  type MediaAssetGetPayload<S extends boolean | null | undefined | MediaAssetDefaultArgs> = $Result.GetResult<Prisma.$MediaAssetPayload, S>

  type MediaAssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaAssetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaAssetCountAggregateInputType | true
    }

  export interface MediaAssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaAsset'], meta: { name: 'MediaAsset' } }
    /**
     * Find zero or one MediaAsset that matches the filter.
     * @param {MediaAssetFindUniqueArgs} args - Arguments to find a MediaAsset
     * @example
     * // Get one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaAssetFindUniqueArgs>(args: SelectSubset<T, MediaAssetFindUniqueArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MediaAsset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaAssetFindUniqueOrThrowArgs} args - Arguments to find a MediaAsset
     * @example
     * // Get one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaAssetFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaAssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetFindFirstArgs} args - Arguments to find a MediaAsset
     * @example
     * // Get one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaAssetFindFirstArgs>(args?: SelectSubset<T, MediaAssetFindFirstArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaAsset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetFindFirstOrThrowArgs} args - Arguments to find a MediaAsset
     * @example
     * // Get one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaAssetFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaAssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MediaAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaAssets
     * const mediaAssets = await prisma.mediaAsset.findMany()
     * 
     * // Get first 10 MediaAssets
     * const mediaAssets = await prisma.mediaAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaAssetWithIdOnly = await prisma.mediaAsset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaAssetFindManyArgs>(args?: SelectSubset<T, MediaAssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MediaAsset.
     * @param {MediaAssetCreateArgs} args - Arguments to create a MediaAsset.
     * @example
     * // Create one MediaAsset
     * const MediaAsset = await prisma.mediaAsset.create({
     *   data: {
     *     // ... data to create a MediaAsset
     *   }
     * })
     * 
     */
    create<T extends MediaAssetCreateArgs>(args: SelectSubset<T, MediaAssetCreateArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MediaAssets.
     * @param {MediaAssetCreateManyArgs} args - Arguments to create many MediaAssets.
     * @example
     * // Create many MediaAssets
     * const mediaAsset = await prisma.mediaAsset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaAssetCreateManyArgs>(args?: SelectSubset<T, MediaAssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaAssets and returns the data saved in the database.
     * @param {MediaAssetCreateManyAndReturnArgs} args - Arguments to create many MediaAssets.
     * @example
     * // Create many MediaAssets
     * const mediaAsset = await prisma.mediaAsset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaAssets and only return the `id`
     * const mediaAssetWithIdOnly = await prisma.mediaAsset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaAssetCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaAssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MediaAsset.
     * @param {MediaAssetDeleteArgs} args - Arguments to delete one MediaAsset.
     * @example
     * // Delete one MediaAsset
     * const MediaAsset = await prisma.mediaAsset.delete({
     *   where: {
     *     // ... filter to delete one MediaAsset
     *   }
     * })
     * 
     */
    delete<T extends MediaAssetDeleteArgs>(args: SelectSubset<T, MediaAssetDeleteArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MediaAsset.
     * @param {MediaAssetUpdateArgs} args - Arguments to update one MediaAsset.
     * @example
     * // Update one MediaAsset
     * const mediaAsset = await prisma.mediaAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaAssetUpdateArgs>(args: SelectSubset<T, MediaAssetUpdateArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MediaAssets.
     * @param {MediaAssetDeleteManyArgs} args - Arguments to filter MediaAssets to delete.
     * @example
     * // Delete a few MediaAssets
     * const { count } = await prisma.mediaAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaAssetDeleteManyArgs>(args?: SelectSubset<T, MediaAssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaAssets
     * const mediaAsset = await prisma.mediaAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaAssetUpdateManyArgs>(args: SelectSubset<T, MediaAssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaAssets and returns the data updated in the database.
     * @param {MediaAssetUpdateManyAndReturnArgs} args - Arguments to update many MediaAssets.
     * @example
     * // Update many MediaAssets
     * const mediaAsset = await prisma.mediaAsset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MediaAssets and only return the `id`
     * const mediaAssetWithIdOnly = await prisma.mediaAsset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaAssetUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaAssetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MediaAsset.
     * @param {MediaAssetUpsertArgs} args - Arguments to update or create a MediaAsset.
     * @example
     * // Update or create a MediaAsset
     * const mediaAsset = await prisma.mediaAsset.upsert({
     *   create: {
     *     // ... data to create a MediaAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaAsset we want to update
     *   }
     * })
     */
    upsert<T extends MediaAssetUpsertArgs>(args: SelectSubset<T, MediaAssetUpsertArgs<ExtArgs>>): Prisma__MediaAssetClient<$Result.GetResult<Prisma.$MediaAssetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MediaAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetCountArgs} args - Arguments to filter MediaAssets to count.
     * @example
     * // Count the number of MediaAssets
     * const count = await prisma.mediaAsset.count({
     *   where: {
     *     // ... the filter for the MediaAssets we want to count
     *   }
     * })
    **/
    count<T extends MediaAssetCountArgs>(
      args?: Subset<T, MediaAssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAssetAggregateArgs>(args: Subset<T, MediaAssetAggregateArgs>): Prisma.PrismaPromise<GetMediaAssetAggregateType<T>>

    /**
     * Group by MediaAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaAssetGroupByArgs['orderBy'] }
        : { orderBy?: MediaAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaAsset model
   */
  readonly fields: MediaAssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaAssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaAsset model
   */
  interface MediaAssetFieldRefs {
    readonly id: FieldRef<"MediaAsset", 'String'>
    readonly postId: FieldRef<"MediaAsset", 'String'>
    readonly type: FieldRef<"MediaAsset", 'MediaType'>
    readonly url: FieldRef<"MediaAsset", 'String'>
    readonly provider: FieldRef<"MediaAsset", 'String'>
    readonly title: FieldRef<"MediaAsset", 'String'>
    readonly alt: FieldRef<"MediaAsset", 'String'>
    readonly caption: FieldRef<"MediaAsset", 'String'>
    readonly position: FieldRef<"MediaAsset", 'Int'>
    readonly mimeType: FieldRef<"MediaAsset", 'String'>
    readonly sizeBytes: FieldRef<"MediaAsset", 'Int'>
    readonly width: FieldRef<"MediaAsset", 'Int'>
    readonly height: FieldRef<"MediaAsset", 'Int'>
    readonly durationMs: FieldRef<"MediaAsset", 'Int'>
    readonly meta: FieldRef<"MediaAsset", 'Json'>
    readonly createdAt: FieldRef<"MediaAsset", 'DateTime'>
    readonly updatedAt: FieldRef<"MediaAsset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MediaAsset findUnique
   */
  export type MediaAssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAsset to fetch.
     */
    where: MediaAssetWhereUniqueInput
  }

  /**
   * MediaAsset findUniqueOrThrow
   */
  export type MediaAssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAsset to fetch.
     */
    where: MediaAssetWhereUniqueInput
  }

  /**
   * MediaAsset findFirst
   */
  export type MediaAssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAsset to fetch.
     */
    where?: MediaAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAssets to fetch.
     */
    orderBy?: MediaAssetOrderByWithRelationInput | MediaAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaAssets.
     */
    cursor?: MediaAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaAssets.
     */
    distinct?: MediaAssetScalarFieldEnum | MediaAssetScalarFieldEnum[]
  }

  /**
   * MediaAsset findFirstOrThrow
   */
  export type MediaAssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAsset to fetch.
     */
    where?: MediaAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAssets to fetch.
     */
    orderBy?: MediaAssetOrderByWithRelationInput | MediaAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaAssets.
     */
    cursor?: MediaAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaAssets.
     */
    distinct?: MediaAssetScalarFieldEnum | MediaAssetScalarFieldEnum[]
  }

  /**
   * MediaAsset findMany
   */
  export type MediaAssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter, which MediaAssets to fetch.
     */
    where?: MediaAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaAssets to fetch.
     */
    orderBy?: MediaAssetOrderByWithRelationInput | MediaAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaAssets.
     */
    cursor?: MediaAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaAssets.
     */
    skip?: number
    distinct?: MediaAssetScalarFieldEnum | MediaAssetScalarFieldEnum[]
  }

  /**
   * MediaAsset create
   */
  export type MediaAssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaAsset.
     */
    data: XOR<MediaAssetCreateInput, MediaAssetUncheckedCreateInput>
  }

  /**
   * MediaAsset createMany
   */
  export type MediaAssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaAssets.
     */
    data: MediaAssetCreateManyInput | MediaAssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaAsset createManyAndReturn
   */
  export type MediaAssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * The data used to create many MediaAssets.
     */
    data: MediaAssetCreateManyInput | MediaAssetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaAsset update
   */
  export type MediaAssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaAsset.
     */
    data: XOR<MediaAssetUpdateInput, MediaAssetUncheckedUpdateInput>
    /**
     * Choose, which MediaAsset to update.
     */
    where: MediaAssetWhereUniqueInput
  }

  /**
   * MediaAsset updateMany
   */
  export type MediaAssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaAssets.
     */
    data: XOR<MediaAssetUpdateManyMutationInput, MediaAssetUncheckedUpdateManyInput>
    /**
     * Filter which MediaAssets to update
     */
    where?: MediaAssetWhereInput
    /**
     * Limit how many MediaAssets to update.
     */
    limit?: number
  }

  /**
   * MediaAsset updateManyAndReturn
   */
  export type MediaAssetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * The data used to update MediaAssets.
     */
    data: XOR<MediaAssetUpdateManyMutationInput, MediaAssetUncheckedUpdateManyInput>
    /**
     * Filter which MediaAssets to update
     */
    where?: MediaAssetWhereInput
    /**
     * Limit how many MediaAssets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaAsset upsert
   */
  export type MediaAssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaAsset to update in case it exists.
     */
    where: MediaAssetWhereUniqueInput
    /**
     * In case the MediaAsset found by the `where` argument doesn't exist, create a new MediaAsset with this data.
     */
    create: XOR<MediaAssetCreateInput, MediaAssetUncheckedCreateInput>
    /**
     * In case the MediaAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaAssetUpdateInput, MediaAssetUncheckedUpdateInput>
  }

  /**
   * MediaAsset delete
   */
  export type MediaAssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
    /**
     * Filter which MediaAsset to delete.
     */
    where: MediaAssetWhereUniqueInput
  }

  /**
   * MediaAsset deleteMany
   */
  export type MediaAssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaAssets to delete
     */
    where?: MediaAssetWhereInput
    /**
     * Limit how many MediaAssets to delete.
     */
    limit?: number
  }

  /**
   * MediaAsset without action
   */
  export type MediaAssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaAsset
     */
    select?: MediaAssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaAsset
     */
    omit?: MediaAssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaAssetInclude<ExtArgs> | null
  }


  /**
   * Model CodeSnippet
   */

  export type AggregateCodeSnippet = {
    _count: CodeSnippetCountAggregateOutputType | null
    _min: CodeSnippetMinAggregateOutputType | null
    _max: CodeSnippetMaxAggregateOutputType | null
  }

  export type CodeSnippetMinAggregateOutputType = {
    id: string | null
    postId: string | null
    title: string | null
    language: string | null
    filename: string | null
    code: string | null
    highlightedHtml: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CodeSnippetMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    title: string | null
    language: string | null
    filename: string | null
    code: string | null
    highlightedHtml: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CodeSnippetCountAggregateOutputType = {
    id: number
    postId: number
    title: number
    language: number
    filename: number
    code: number
    highlightedHtml: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CodeSnippetMinAggregateInputType = {
    id?: true
    postId?: true
    title?: true
    language?: true
    filename?: true
    code?: true
    highlightedHtml?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CodeSnippetMaxAggregateInputType = {
    id?: true
    postId?: true
    title?: true
    language?: true
    filename?: true
    code?: true
    highlightedHtml?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CodeSnippetCountAggregateInputType = {
    id?: true
    postId?: true
    title?: true
    language?: true
    filename?: true
    code?: true
    highlightedHtml?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CodeSnippetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CodeSnippet to aggregate.
     */
    where?: CodeSnippetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeSnippets to fetch.
     */
    orderBy?: CodeSnippetOrderByWithRelationInput | CodeSnippetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CodeSnippetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeSnippets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeSnippets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CodeSnippets
    **/
    _count?: true | CodeSnippetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodeSnippetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodeSnippetMaxAggregateInputType
  }

  export type GetCodeSnippetAggregateType<T extends CodeSnippetAggregateArgs> = {
        [P in keyof T & keyof AggregateCodeSnippet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodeSnippet[P]>
      : GetScalarType<T[P], AggregateCodeSnippet[P]>
  }




  export type CodeSnippetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CodeSnippetWhereInput
    orderBy?: CodeSnippetOrderByWithAggregationInput | CodeSnippetOrderByWithAggregationInput[]
    by: CodeSnippetScalarFieldEnum[] | CodeSnippetScalarFieldEnum
    having?: CodeSnippetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodeSnippetCountAggregateInputType | true
    _min?: CodeSnippetMinAggregateInputType
    _max?: CodeSnippetMaxAggregateInputType
  }

  export type CodeSnippetGroupByOutputType = {
    id: string
    postId: string
    title: string | null
    language: string
    filename: string | null
    code: string
    highlightedHtml: string | null
    createdAt: Date
    updatedAt: Date
    _count: CodeSnippetCountAggregateOutputType | null
    _min: CodeSnippetMinAggregateOutputType | null
    _max: CodeSnippetMaxAggregateOutputType | null
  }

  type GetCodeSnippetGroupByPayload<T extends CodeSnippetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CodeSnippetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CodeSnippetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CodeSnippetGroupByOutputType[P]>
            : GetScalarType<T[P], CodeSnippetGroupByOutputType[P]>
        }
      >
    >


  export type CodeSnippetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    title?: boolean
    language?: boolean
    filename?: boolean
    code?: boolean
    highlightedHtml?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["codeSnippet"]>

  export type CodeSnippetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    title?: boolean
    language?: boolean
    filename?: boolean
    code?: boolean
    highlightedHtml?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["codeSnippet"]>

  export type CodeSnippetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    title?: boolean
    language?: boolean
    filename?: boolean
    code?: boolean
    highlightedHtml?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["codeSnippet"]>

  export type CodeSnippetSelectScalar = {
    id?: boolean
    postId?: boolean
    title?: boolean
    language?: boolean
    filename?: boolean
    code?: boolean
    highlightedHtml?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CodeSnippetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "title" | "language" | "filename" | "code" | "highlightedHtml" | "createdAt" | "updatedAt", ExtArgs["result"]["codeSnippet"]>
  export type CodeSnippetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type CodeSnippetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type CodeSnippetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $CodeSnippetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CodeSnippet"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      title: string | null
      language: string
      filename: string | null
      code: string
      highlightedHtml: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["codeSnippet"]>
    composites: {}
  }

  type CodeSnippetGetPayload<S extends boolean | null | undefined | CodeSnippetDefaultArgs> = $Result.GetResult<Prisma.$CodeSnippetPayload, S>

  type CodeSnippetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CodeSnippetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CodeSnippetCountAggregateInputType | true
    }

  export interface CodeSnippetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CodeSnippet'], meta: { name: 'CodeSnippet' } }
    /**
     * Find zero or one CodeSnippet that matches the filter.
     * @param {CodeSnippetFindUniqueArgs} args - Arguments to find a CodeSnippet
     * @example
     * // Get one CodeSnippet
     * const codeSnippet = await prisma.codeSnippet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CodeSnippetFindUniqueArgs>(args: SelectSubset<T, CodeSnippetFindUniqueArgs<ExtArgs>>): Prisma__CodeSnippetClient<$Result.GetResult<Prisma.$CodeSnippetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CodeSnippet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CodeSnippetFindUniqueOrThrowArgs} args - Arguments to find a CodeSnippet
     * @example
     * // Get one CodeSnippet
     * const codeSnippet = await prisma.codeSnippet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CodeSnippetFindUniqueOrThrowArgs>(args: SelectSubset<T, CodeSnippetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CodeSnippetClient<$Result.GetResult<Prisma.$CodeSnippetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CodeSnippet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSnippetFindFirstArgs} args - Arguments to find a CodeSnippet
     * @example
     * // Get one CodeSnippet
     * const codeSnippet = await prisma.codeSnippet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CodeSnippetFindFirstArgs>(args?: SelectSubset<T, CodeSnippetFindFirstArgs<ExtArgs>>): Prisma__CodeSnippetClient<$Result.GetResult<Prisma.$CodeSnippetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CodeSnippet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSnippetFindFirstOrThrowArgs} args - Arguments to find a CodeSnippet
     * @example
     * // Get one CodeSnippet
     * const codeSnippet = await prisma.codeSnippet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CodeSnippetFindFirstOrThrowArgs>(args?: SelectSubset<T, CodeSnippetFindFirstOrThrowArgs<ExtArgs>>): Prisma__CodeSnippetClient<$Result.GetResult<Prisma.$CodeSnippetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CodeSnippets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSnippetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodeSnippets
     * const codeSnippets = await prisma.codeSnippet.findMany()
     * 
     * // Get first 10 CodeSnippets
     * const codeSnippets = await prisma.codeSnippet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const codeSnippetWithIdOnly = await prisma.codeSnippet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CodeSnippetFindManyArgs>(args?: SelectSubset<T, CodeSnippetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeSnippetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CodeSnippet.
     * @param {CodeSnippetCreateArgs} args - Arguments to create a CodeSnippet.
     * @example
     * // Create one CodeSnippet
     * const CodeSnippet = await prisma.codeSnippet.create({
     *   data: {
     *     // ... data to create a CodeSnippet
     *   }
     * })
     * 
     */
    create<T extends CodeSnippetCreateArgs>(args: SelectSubset<T, CodeSnippetCreateArgs<ExtArgs>>): Prisma__CodeSnippetClient<$Result.GetResult<Prisma.$CodeSnippetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CodeSnippets.
     * @param {CodeSnippetCreateManyArgs} args - Arguments to create many CodeSnippets.
     * @example
     * // Create many CodeSnippets
     * const codeSnippet = await prisma.codeSnippet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CodeSnippetCreateManyArgs>(args?: SelectSubset<T, CodeSnippetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CodeSnippets and returns the data saved in the database.
     * @param {CodeSnippetCreateManyAndReturnArgs} args - Arguments to create many CodeSnippets.
     * @example
     * // Create many CodeSnippets
     * const codeSnippet = await prisma.codeSnippet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CodeSnippets and only return the `id`
     * const codeSnippetWithIdOnly = await prisma.codeSnippet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CodeSnippetCreateManyAndReturnArgs>(args?: SelectSubset<T, CodeSnippetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeSnippetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CodeSnippet.
     * @param {CodeSnippetDeleteArgs} args - Arguments to delete one CodeSnippet.
     * @example
     * // Delete one CodeSnippet
     * const CodeSnippet = await prisma.codeSnippet.delete({
     *   where: {
     *     // ... filter to delete one CodeSnippet
     *   }
     * })
     * 
     */
    delete<T extends CodeSnippetDeleteArgs>(args: SelectSubset<T, CodeSnippetDeleteArgs<ExtArgs>>): Prisma__CodeSnippetClient<$Result.GetResult<Prisma.$CodeSnippetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CodeSnippet.
     * @param {CodeSnippetUpdateArgs} args - Arguments to update one CodeSnippet.
     * @example
     * // Update one CodeSnippet
     * const codeSnippet = await prisma.codeSnippet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CodeSnippetUpdateArgs>(args: SelectSubset<T, CodeSnippetUpdateArgs<ExtArgs>>): Prisma__CodeSnippetClient<$Result.GetResult<Prisma.$CodeSnippetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CodeSnippets.
     * @param {CodeSnippetDeleteManyArgs} args - Arguments to filter CodeSnippets to delete.
     * @example
     * // Delete a few CodeSnippets
     * const { count } = await prisma.codeSnippet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CodeSnippetDeleteManyArgs>(args?: SelectSubset<T, CodeSnippetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeSnippets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSnippetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodeSnippets
     * const codeSnippet = await prisma.codeSnippet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CodeSnippetUpdateManyArgs>(args: SelectSubset<T, CodeSnippetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeSnippets and returns the data updated in the database.
     * @param {CodeSnippetUpdateManyAndReturnArgs} args - Arguments to update many CodeSnippets.
     * @example
     * // Update many CodeSnippets
     * const codeSnippet = await prisma.codeSnippet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CodeSnippets and only return the `id`
     * const codeSnippetWithIdOnly = await prisma.codeSnippet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CodeSnippetUpdateManyAndReturnArgs>(args: SelectSubset<T, CodeSnippetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CodeSnippetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CodeSnippet.
     * @param {CodeSnippetUpsertArgs} args - Arguments to update or create a CodeSnippet.
     * @example
     * // Update or create a CodeSnippet
     * const codeSnippet = await prisma.codeSnippet.upsert({
     *   create: {
     *     // ... data to create a CodeSnippet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodeSnippet we want to update
     *   }
     * })
     */
    upsert<T extends CodeSnippetUpsertArgs>(args: SelectSubset<T, CodeSnippetUpsertArgs<ExtArgs>>): Prisma__CodeSnippetClient<$Result.GetResult<Prisma.$CodeSnippetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CodeSnippets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSnippetCountArgs} args - Arguments to filter CodeSnippets to count.
     * @example
     * // Count the number of CodeSnippets
     * const count = await prisma.codeSnippet.count({
     *   where: {
     *     // ... the filter for the CodeSnippets we want to count
     *   }
     * })
    **/
    count<T extends CodeSnippetCountArgs>(
      args?: Subset<T, CodeSnippetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodeSnippetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodeSnippet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSnippetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodeSnippetAggregateArgs>(args: Subset<T, CodeSnippetAggregateArgs>): Prisma.PrismaPromise<GetCodeSnippetAggregateType<T>>

    /**
     * Group by CodeSnippet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeSnippetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodeSnippetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodeSnippetGroupByArgs['orderBy'] }
        : { orderBy?: CodeSnippetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodeSnippetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodeSnippetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CodeSnippet model
   */
  readonly fields: CodeSnippetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CodeSnippet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CodeSnippetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CodeSnippet model
   */
  interface CodeSnippetFieldRefs {
    readonly id: FieldRef<"CodeSnippet", 'String'>
    readonly postId: FieldRef<"CodeSnippet", 'String'>
    readonly title: FieldRef<"CodeSnippet", 'String'>
    readonly language: FieldRef<"CodeSnippet", 'String'>
    readonly filename: FieldRef<"CodeSnippet", 'String'>
    readonly code: FieldRef<"CodeSnippet", 'String'>
    readonly highlightedHtml: FieldRef<"CodeSnippet", 'String'>
    readonly createdAt: FieldRef<"CodeSnippet", 'DateTime'>
    readonly updatedAt: FieldRef<"CodeSnippet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CodeSnippet findUnique
   */
  export type CodeSnippetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSnippet
     */
    select?: CodeSnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSnippet
     */
    omit?: CodeSnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSnippetInclude<ExtArgs> | null
    /**
     * Filter, which CodeSnippet to fetch.
     */
    where: CodeSnippetWhereUniqueInput
  }

  /**
   * CodeSnippet findUniqueOrThrow
   */
  export type CodeSnippetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSnippet
     */
    select?: CodeSnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSnippet
     */
    omit?: CodeSnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSnippetInclude<ExtArgs> | null
    /**
     * Filter, which CodeSnippet to fetch.
     */
    where: CodeSnippetWhereUniqueInput
  }

  /**
   * CodeSnippet findFirst
   */
  export type CodeSnippetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSnippet
     */
    select?: CodeSnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSnippet
     */
    omit?: CodeSnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSnippetInclude<ExtArgs> | null
    /**
     * Filter, which CodeSnippet to fetch.
     */
    where?: CodeSnippetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeSnippets to fetch.
     */
    orderBy?: CodeSnippetOrderByWithRelationInput | CodeSnippetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeSnippets.
     */
    cursor?: CodeSnippetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeSnippets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeSnippets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeSnippets.
     */
    distinct?: CodeSnippetScalarFieldEnum | CodeSnippetScalarFieldEnum[]
  }

  /**
   * CodeSnippet findFirstOrThrow
   */
  export type CodeSnippetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSnippet
     */
    select?: CodeSnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSnippet
     */
    omit?: CodeSnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSnippetInclude<ExtArgs> | null
    /**
     * Filter, which CodeSnippet to fetch.
     */
    where?: CodeSnippetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeSnippets to fetch.
     */
    orderBy?: CodeSnippetOrderByWithRelationInput | CodeSnippetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeSnippets.
     */
    cursor?: CodeSnippetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeSnippets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeSnippets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeSnippets.
     */
    distinct?: CodeSnippetScalarFieldEnum | CodeSnippetScalarFieldEnum[]
  }

  /**
   * CodeSnippet findMany
   */
  export type CodeSnippetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSnippet
     */
    select?: CodeSnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSnippet
     */
    omit?: CodeSnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSnippetInclude<ExtArgs> | null
    /**
     * Filter, which CodeSnippets to fetch.
     */
    where?: CodeSnippetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeSnippets to fetch.
     */
    orderBy?: CodeSnippetOrderByWithRelationInput | CodeSnippetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CodeSnippets.
     */
    cursor?: CodeSnippetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeSnippets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeSnippets.
     */
    skip?: number
    distinct?: CodeSnippetScalarFieldEnum | CodeSnippetScalarFieldEnum[]
  }

  /**
   * CodeSnippet create
   */
  export type CodeSnippetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSnippet
     */
    select?: CodeSnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSnippet
     */
    omit?: CodeSnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSnippetInclude<ExtArgs> | null
    /**
     * The data needed to create a CodeSnippet.
     */
    data: XOR<CodeSnippetCreateInput, CodeSnippetUncheckedCreateInput>
  }

  /**
   * CodeSnippet createMany
   */
  export type CodeSnippetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CodeSnippets.
     */
    data: CodeSnippetCreateManyInput | CodeSnippetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CodeSnippet createManyAndReturn
   */
  export type CodeSnippetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSnippet
     */
    select?: CodeSnippetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSnippet
     */
    omit?: CodeSnippetOmit<ExtArgs> | null
    /**
     * The data used to create many CodeSnippets.
     */
    data: CodeSnippetCreateManyInput | CodeSnippetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSnippetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CodeSnippet update
   */
  export type CodeSnippetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSnippet
     */
    select?: CodeSnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSnippet
     */
    omit?: CodeSnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSnippetInclude<ExtArgs> | null
    /**
     * The data needed to update a CodeSnippet.
     */
    data: XOR<CodeSnippetUpdateInput, CodeSnippetUncheckedUpdateInput>
    /**
     * Choose, which CodeSnippet to update.
     */
    where: CodeSnippetWhereUniqueInput
  }

  /**
   * CodeSnippet updateMany
   */
  export type CodeSnippetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CodeSnippets.
     */
    data: XOR<CodeSnippetUpdateManyMutationInput, CodeSnippetUncheckedUpdateManyInput>
    /**
     * Filter which CodeSnippets to update
     */
    where?: CodeSnippetWhereInput
    /**
     * Limit how many CodeSnippets to update.
     */
    limit?: number
  }

  /**
   * CodeSnippet updateManyAndReturn
   */
  export type CodeSnippetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSnippet
     */
    select?: CodeSnippetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSnippet
     */
    omit?: CodeSnippetOmit<ExtArgs> | null
    /**
     * The data used to update CodeSnippets.
     */
    data: XOR<CodeSnippetUpdateManyMutationInput, CodeSnippetUncheckedUpdateManyInput>
    /**
     * Filter which CodeSnippets to update
     */
    where?: CodeSnippetWhereInput
    /**
     * Limit how many CodeSnippets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSnippetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CodeSnippet upsert
   */
  export type CodeSnippetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSnippet
     */
    select?: CodeSnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSnippet
     */
    omit?: CodeSnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSnippetInclude<ExtArgs> | null
    /**
     * The filter to search for the CodeSnippet to update in case it exists.
     */
    where: CodeSnippetWhereUniqueInput
    /**
     * In case the CodeSnippet found by the `where` argument doesn't exist, create a new CodeSnippet with this data.
     */
    create: XOR<CodeSnippetCreateInput, CodeSnippetUncheckedCreateInput>
    /**
     * In case the CodeSnippet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CodeSnippetUpdateInput, CodeSnippetUncheckedUpdateInput>
  }

  /**
   * CodeSnippet delete
   */
  export type CodeSnippetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSnippet
     */
    select?: CodeSnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSnippet
     */
    omit?: CodeSnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSnippetInclude<ExtArgs> | null
    /**
     * Filter which CodeSnippet to delete.
     */
    where: CodeSnippetWhereUniqueInput
  }

  /**
   * CodeSnippet deleteMany
   */
  export type CodeSnippetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CodeSnippets to delete
     */
    where?: CodeSnippetWhereInput
    /**
     * Limit how many CodeSnippets to delete.
     */
    limit?: number
  }

  /**
   * CodeSnippet without action
   */
  export type CodeSnippetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CodeSnippet
     */
    select?: CodeSnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CodeSnippet
     */
    omit?: CodeSnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CodeSnippetInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posts?: boolean | Tag$postsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Tag$postsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      posts: Prisma.$PostsOnTagsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends Tag$postsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsOnTagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly slug: FieldRef<"Tag", 'String'>
    readonly description: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.posts
   */
  export type Tag$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnTags
     */
    select?: PostsOnTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnTags
     */
    omit?: PostsOnTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnTagsInclude<ExtArgs> | null
    where?: PostsOnTagsWhereInput
    orderBy?: PostsOnTagsOrderByWithRelationInput | PostsOnTagsOrderByWithRelationInput[]
    cursor?: PostsOnTagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostsOnTagsScalarFieldEnum | PostsOnTagsScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model PostsOnTags
   */

  export type AggregatePostsOnTags = {
    _count: PostsOnTagsCountAggregateOutputType | null
    _min: PostsOnTagsMinAggregateOutputType | null
    _max: PostsOnTagsMaxAggregateOutputType | null
  }

  export type PostsOnTagsMinAggregateOutputType = {
    postId: string | null
    tagId: string | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type PostsOnTagsMaxAggregateOutputType = {
    postId: string | null
    tagId: string | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type PostsOnTagsCountAggregateOutputType = {
    postId: number
    tagId: number
    assignedAt: number
    assignedBy: number
    _all: number
  }


  export type PostsOnTagsMinAggregateInputType = {
    postId?: true
    tagId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type PostsOnTagsMaxAggregateInputType = {
    postId?: true
    tagId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type PostsOnTagsCountAggregateInputType = {
    postId?: true
    tagId?: true
    assignedAt?: true
    assignedBy?: true
    _all?: true
  }

  export type PostsOnTagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostsOnTags to aggregate.
     */
    where?: PostsOnTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostsOnTags to fetch.
     */
    orderBy?: PostsOnTagsOrderByWithRelationInput | PostsOnTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostsOnTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostsOnTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostsOnTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostsOnTags
    **/
    _count?: true | PostsOnTagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostsOnTagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostsOnTagsMaxAggregateInputType
  }

  export type GetPostsOnTagsAggregateType<T extends PostsOnTagsAggregateArgs> = {
        [P in keyof T & keyof AggregatePostsOnTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostsOnTags[P]>
      : GetScalarType<T[P], AggregatePostsOnTags[P]>
  }




  export type PostsOnTagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostsOnTagsWhereInput
    orderBy?: PostsOnTagsOrderByWithAggregationInput | PostsOnTagsOrderByWithAggregationInput[]
    by: PostsOnTagsScalarFieldEnum[] | PostsOnTagsScalarFieldEnum
    having?: PostsOnTagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostsOnTagsCountAggregateInputType | true
    _min?: PostsOnTagsMinAggregateInputType
    _max?: PostsOnTagsMaxAggregateInputType
  }

  export type PostsOnTagsGroupByOutputType = {
    postId: string
    tagId: string
    assignedAt: Date
    assignedBy: string | null
    _count: PostsOnTagsCountAggregateOutputType | null
    _min: PostsOnTagsMinAggregateOutputType | null
    _max: PostsOnTagsMaxAggregateOutputType | null
  }

  type GetPostsOnTagsGroupByPayload<T extends PostsOnTagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostsOnTagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostsOnTagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostsOnTagsGroupByOutputType[P]>
            : GetScalarType<T[P], PostsOnTagsGroupByOutputType[P]>
        }
      >
    >


  export type PostsOnTagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    tagId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postsOnTags"]>

  export type PostsOnTagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    tagId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postsOnTags"]>

  export type PostsOnTagsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    tagId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postsOnTags"]>

  export type PostsOnTagsSelectScalar = {
    postId?: boolean
    tagId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }

  export type PostsOnTagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"postId" | "tagId" | "assignedAt" | "assignedBy", ExtArgs["result"]["postsOnTags"]>
  export type PostsOnTagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type PostsOnTagsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type PostsOnTagsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $PostsOnTagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostsOnTags"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      postId: string
      tagId: string
      assignedAt: Date
      assignedBy: string | null
    }, ExtArgs["result"]["postsOnTags"]>
    composites: {}
  }

  type PostsOnTagsGetPayload<S extends boolean | null | undefined | PostsOnTagsDefaultArgs> = $Result.GetResult<Prisma.$PostsOnTagsPayload, S>

  type PostsOnTagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostsOnTagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostsOnTagsCountAggregateInputType | true
    }

  export interface PostsOnTagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostsOnTags'], meta: { name: 'PostsOnTags' } }
    /**
     * Find zero or one PostsOnTags that matches the filter.
     * @param {PostsOnTagsFindUniqueArgs} args - Arguments to find a PostsOnTags
     * @example
     * // Get one PostsOnTags
     * const postsOnTags = await prisma.postsOnTags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostsOnTagsFindUniqueArgs>(args: SelectSubset<T, PostsOnTagsFindUniqueArgs<ExtArgs>>): Prisma__PostsOnTagsClient<$Result.GetResult<Prisma.$PostsOnTagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostsOnTags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostsOnTagsFindUniqueOrThrowArgs} args - Arguments to find a PostsOnTags
     * @example
     * // Get one PostsOnTags
     * const postsOnTags = await prisma.postsOnTags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostsOnTagsFindUniqueOrThrowArgs>(args: SelectSubset<T, PostsOnTagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostsOnTagsClient<$Result.GetResult<Prisma.$PostsOnTagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostsOnTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsOnTagsFindFirstArgs} args - Arguments to find a PostsOnTags
     * @example
     * // Get one PostsOnTags
     * const postsOnTags = await prisma.postsOnTags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostsOnTagsFindFirstArgs>(args?: SelectSubset<T, PostsOnTagsFindFirstArgs<ExtArgs>>): Prisma__PostsOnTagsClient<$Result.GetResult<Prisma.$PostsOnTagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostsOnTags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsOnTagsFindFirstOrThrowArgs} args - Arguments to find a PostsOnTags
     * @example
     * // Get one PostsOnTags
     * const postsOnTags = await prisma.postsOnTags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostsOnTagsFindFirstOrThrowArgs>(args?: SelectSubset<T, PostsOnTagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostsOnTagsClient<$Result.GetResult<Prisma.$PostsOnTagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostsOnTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsOnTagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostsOnTags
     * const postsOnTags = await prisma.postsOnTags.findMany()
     * 
     * // Get first 10 PostsOnTags
     * const postsOnTags = await prisma.postsOnTags.findMany({ take: 10 })
     * 
     * // Only select the `postId`
     * const postsOnTagsWithPostIdOnly = await prisma.postsOnTags.findMany({ select: { postId: true } })
     * 
     */
    findMany<T extends PostsOnTagsFindManyArgs>(args?: SelectSubset<T, PostsOnTagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsOnTagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostsOnTags.
     * @param {PostsOnTagsCreateArgs} args - Arguments to create a PostsOnTags.
     * @example
     * // Create one PostsOnTags
     * const PostsOnTags = await prisma.postsOnTags.create({
     *   data: {
     *     // ... data to create a PostsOnTags
     *   }
     * })
     * 
     */
    create<T extends PostsOnTagsCreateArgs>(args: SelectSubset<T, PostsOnTagsCreateArgs<ExtArgs>>): Prisma__PostsOnTagsClient<$Result.GetResult<Prisma.$PostsOnTagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostsOnTags.
     * @param {PostsOnTagsCreateManyArgs} args - Arguments to create many PostsOnTags.
     * @example
     * // Create many PostsOnTags
     * const postsOnTags = await prisma.postsOnTags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostsOnTagsCreateManyArgs>(args?: SelectSubset<T, PostsOnTagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostsOnTags and returns the data saved in the database.
     * @param {PostsOnTagsCreateManyAndReturnArgs} args - Arguments to create many PostsOnTags.
     * @example
     * // Create many PostsOnTags
     * const postsOnTags = await prisma.postsOnTags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostsOnTags and only return the `postId`
     * const postsOnTagsWithPostIdOnly = await prisma.postsOnTags.createManyAndReturn({
     *   select: { postId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostsOnTagsCreateManyAndReturnArgs>(args?: SelectSubset<T, PostsOnTagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsOnTagsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostsOnTags.
     * @param {PostsOnTagsDeleteArgs} args - Arguments to delete one PostsOnTags.
     * @example
     * // Delete one PostsOnTags
     * const PostsOnTags = await prisma.postsOnTags.delete({
     *   where: {
     *     // ... filter to delete one PostsOnTags
     *   }
     * })
     * 
     */
    delete<T extends PostsOnTagsDeleteArgs>(args: SelectSubset<T, PostsOnTagsDeleteArgs<ExtArgs>>): Prisma__PostsOnTagsClient<$Result.GetResult<Prisma.$PostsOnTagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostsOnTags.
     * @param {PostsOnTagsUpdateArgs} args - Arguments to update one PostsOnTags.
     * @example
     * // Update one PostsOnTags
     * const postsOnTags = await prisma.postsOnTags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostsOnTagsUpdateArgs>(args: SelectSubset<T, PostsOnTagsUpdateArgs<ExtArgs>>): Prisma__PostsOnTagsClient<$Result.GetResult<Prisma.$PostsOnTagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostsOnTags.
     * @param {PostsOnTagsDeleteManyArgs} args - Arguments to filter PostsOnTags to delete.
     * @example
     * // Delete a few PostsOnTags
     * const { count } = await prisma.postsOnTags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostsOnTagsDeleteManyArgs>(args?: SelectSubset<T, PostsOnTagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostsOnTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsOnTagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostsOnTags
     * const postsOnTags = await prisma.postsOnTags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostsOnTagsUpdateManyArgs>(args: SelectSubset<T, PostsOnTagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostsOnTags and returns the data updated in the database.
     * @param {PostsOnTagsUpdateManyAndReturnArgs} args - Arguments to update many PostsOnTags.
     * @example
     * // Update many PostsOnTags
     * const postsOnTags = await prisma.postsOnTags.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostsOnTags and only return the `postId`
     * const postsOnTagsWithPostIdOnly = await prisma.postsOnTags.updateManyAndReturn({
     *   select: { postId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostsOnTagsUpdateManyAndReturnArgs>(args: SelectSubset<T, PostsOnTagsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsOnTagsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostsOnTags.
     * @param {PostsOnTagsUpsertArgs} args - Arguments to update or create a PostsOnTags.
     * @example
     * // Update or create a PostsOnTags
     * const postsOnTags = await prisma.postsOnTags.upsert({
     *   create: {
     *     // ... data to create a PostsOnTags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostsOnTags we want to update
     *   }
     * })
     */
    upsert<T extends PostsOnTagsUpsertArgs>(args: SelectSubset<T, PostsOnTagsUpsertArgs<ExtArgs>>): Prisma__PostsOnTagsClient<$Result.GetResult<Prisma.$PostsOnTagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostsOnTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsOnTagsCountArgs} args - Arguments to filter PostsOnTags to count.
     * @example
     * // Count the number of PostsOnTags
     * const count = await prisma.postsOnTags.count({
     *   where: {
     *     // ... the filter for the PostsOnTags we want to count
     *   }
     * })
    **/
    count<T extends PostsOnTagsCountArgs>(
      args?: Subset<T, PostsOnTagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostsOnTagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostsOnTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsOnTagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostsOnTagsAggregateArgs>(args: Subset<T, PostsOnTagsAggregateArgs>): Prisma.PrismaPromise<GetPostsOnTagsAggregateType<T>>

    /**
     * Group by PostsOnTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsOnTagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostsOnTagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostsOnTagsGroupByArgs['orderBy'] }
        : { orderBy?: PostsOnTagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostsOnTagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostsOnTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostsOnTags model
   */
  readonly fields: PostsOnTagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostsOnTags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostsOnTagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostsOnTags model
   */
  interface PostsOnTagsFieldRefs {
    readonly postId: FieldRef<"PostsOnTags", 'String'>
    readonly tagId: FieldRef<"PostsOnTags", 'String'>
    readonly assignedAt: FieldRef<"PostsOnTags", 'DateTime'>
    readonly assignedBy: FieldRef<"PostsOnTags", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PostsOnTags findUnique
   */
  export type PostsOnTagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnTags
     */
    select?: PostsOnTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnTags
     */
    omit?: PostsOnTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnTagsInclude<ExtArgs> | null
    /**
     * Filter, which PostsOnTags to fetch.
     */
    where: PostsOnTagsWhereUniqueInput
  }

  /**
   * PostsOnTags findUniqueOrThrow
   */
  export type PostsOnTagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnTags
     */
    select?: PostsOnTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnTags
     */
    omit?: PostsOnTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnTagsInclude<ExtArgs> | null
    /**
     * Filter, which PostsOnTags to fetch.
     */
    where: PostsOnTagsWhereUniqueInput
  }

  /**
   * PostsOnTags findFirst
   */
  export type PostsOnTagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnTags
     */
    select?: PostsOnTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnTags
     */
    omit?: PostsOnTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnTagsInclude<ExtArgs> | null
    /**
     * Filter, which PostsOnTags to fetch.
     */
    where?: PostsOnTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostsOnTags to fetch.
     */
    orderBy?: PostsOnTagsOrderByWithRelationInput | PostsOnTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostsOnTags.
     */
    cursor?: PostsOnTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostsOnTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostsOnTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostsOnTags.
     */
    distinct?: PostsOnTagsScalarFieldEnum | PostsOnTagsScalarFieldEnum[]
  }

  /**
   * PostsOnTags findFirstOrThrow
   */
  export type PostsOnTagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnTags
     */
    select?: PostsOnTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnTags
     */
    omit?: PostsOnTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnTagsInclude<ExtArgs> | null
    /**
     * Filter, which PostsOnTags to fetch.
     */
    where?: PostsOnTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostsOnTags to fetch.
     */
    orderBy?: PostsOnTagsOrderByWithRelationInput | PostsOnTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostsOnTags.
     */
    cursor?: PostsOnTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostsOnTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostsOnTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostsOnTags.
     */
    distinct?: PostsOnTagsScalarFieldEnum | PostsOnTagsScalarFieldEnum[]
  }

  /**
   * PostsOnTags findMany
   */
  export type PostsOnTagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnTags
     */
    select?: PostsOnTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnTags
     */
    omit?: PostsOnTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnTagsInclude<ExtArgs> | null
    /**
     * Filter, which PostsOnTags to fetch.
     */
    where?: PostsOnTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostsOnTags to fetch.
     */
    orderBy?: PostsOnTagsOrderByWithRelationInput | PostsOnTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostsOnTags.
     */
    cursor?: PostsOnTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostsOnTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostsOnTags.
     */
    skip?: number
    distinct?: PostsOnTagsScalarFieldEnum | PostsOnTagsScalarFieldEnum[]
  }

  /**
   * PostsOnTags create
   */
  export type PostsOnTagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnTags
     */
    select?: PostsOnTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnTags
     */
    omit?: PostsOnTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnTagsInclude<ExtArgs> | null
    /**
     * The data needed to create a PostsOnTags.
     */
    data: XOR<PostsOnTagsCreateInput, PostsOnTagsUncheckedCreateInput>
  }

  /**
   * PostsOnTags createMany
   */
  export type PostsOnTagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostsOnTags.
     */
    data: PostsOnTagsCreateManyInput | PostsOnTagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostsOnTags createManyAndReturn
   */
  export type PostsOnTagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnTags
     */
    select?: PostsOnTagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnTags
     */
    omit?: PostsOnTagsOmit<ExtArgs> | null
    /**
     * The data used to create many PostsOnTags.
     */
    data: PostsOnTagsCreateManyInput | PostsOnTagsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnTagsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostsOnTags update
   */
  export type PostsOnTagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnTags
     */
    select?: PostsOnTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnTags
     */
    omit?: PostsOnTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnTagsInclude<ExtArgs> | null
    /**
     * The data needed to update a PostsOnTags.
     */
    data: XOR<PostsOnTagsUpdateInput, PostsOnTagsUncheckedUpdateInput>
    /**
     * Choose, which PostsOnTags to update.
     */
    where: PostsOnTagsWhereUniqueInput
  }

  /**
   * PostsOnTags updateMany
   */
  export type PostsOnTagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostsOnTags.
     */
    data: XOR<PostsOnTagsUpdateManyMutationInput, PostsOnTagsUncheckedUpdateManyInput>
    /**
     * Filter which PostsOnTags to update
     */
    where?: PostsOnTagsWhereInput
    /**
     * Limit how many PostsOnTags to update.
     */
    limit?: number
  }

  /**
   * PostsOnTags updateManyAndReturn
   */
  export type PostsOnTagsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnTags
     */
    select?: PostsOnTagsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnTags
     */
    omit?: PostsOnTagsOmit<ExtArgs> | null
    /**
     * The data used to update PostsOnTags.
     */
    data: XOR<PostsOnTagsUpdateManyMutationInput, PostsOnTagsUncheckedUpdateManyInput>
    /**
     * Filter which PostsOnTags to update
     */
    where?: PostsOnTagsWhereInput
    /**
     * Limit how many PostsOnTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnTagsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostsOnTags upsert
   */
  export type PostsOnTagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnTags
     */
    select?: PostsOnTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnTags
     */
    omit?: PostsOnTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnTagsInclude<ExtArgs> | null
    /**
     * The filter to search for the PostsOnTags to update in case it exists.
     */
    where: PostsOnTagsWhereUniqueInput
    /**
     * In case the PostsOnTags found by the `where` argument doesn't exist, create a new PostsOnTags with this data.
     */
    create: XOR<PostsOnTagsCreateInput, PostsOnTagsUncheckedCreateInput>
    /**
     * In case the PostsOnTags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostsOnTagsUpdateInput, PostsOnTagsUncheckedUpdateInput>
  }

  /**
   * PostsOnTags delete
   */
  export type PostsOnTagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnTags
     */
    select?: PostsOnTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnTags
     */
    omit?: PostsOnTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnTagsInclude<ExtArgs> | null
    /**
     * Filter which PostsOnTags to delete.
     */
    where: PostsOnTagsWhereUniqueInput
  }

  /**
   * PostsOnTags deleteMany
   */
  export type PostsOnTagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostsOnTags to delete
     */
    where?: PostsOnTagsWhereInput
    /**
     * Limit how many PostsOnTags to delete.
     */
    limit?: number
  }

  /**
   * PostsOnTags without action
   */
  export type PostsOnTagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnTags
     */
    select?: PostsOnTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnTags
     */
    omit?: PostsOnTagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnTagsInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    posts?: boolean | Category$postsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    posts?: boolean | Category$postsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      parent: Prisma.$CategoryPayload<ExtArgs> | null
      children: Prisma.$CategoryPayload<ExtArgs>[]
      posts: Prisma.$PostsOnCategoriesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Category$parentArgs<ExtArgs> = {}>(args?: Subset<T, Category$parentArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Category$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Category$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends Category$postsArgs<ExtArgs> = {}>(args?: Subset<T, Category$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsOnCategoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly parentId: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.parent
   */
  export type Category$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.children
   */
  export type Category$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category.posts
   */
  export type Category$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnCategories
     */
    select?: PostsOnCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnCategories
     */
    omit?: PostsOnCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnCategoriesInclude<ExtArgs> | null
    where?: PostsOnCategoriesWhereInput
    orderBy?: PostsOnCategoriesOrderByWithRelationInput | PostsOnCategoriesOrderByWithRelationInput[]
    cursor?: PostsOnCategoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostsOnCategoriesScalarFieldEnum | PostsOnCategoriesScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model PostsOnCategories
   */

  export type AggregatePostsOnCategories = {
    _count: PostsOnCategoriesCountAggregateOutputType | null
    _avg: PostsOnCategoriesAvgAggregateOutputType | null
    _sum: PostsOnCategoriesSumAggregateOutputType | null
    _min: PostsOnCategoriesMinAggregateOutputType | null
    _max: PostsOnCategoriesMaxAggregateOutputType | null
  }

  export type PostsOnCategoriesAvgAggregateOutputType = {
    position: number | null
  }

  export type PostsOnCategoriesSumAggregateOutputType = {
    position: number | null
  }

  export type PostsOnCategoriesMinAggregateOutputType = {
    postId: string | null
    categoryId: string | null
    position: number | null
    assignedAt: Date | null
  }

  export type PostsOnCategoriesMaxAggregateOutputType = {
    postId: string | null
    categoryId: string | null
    position: number | null
    assignedAt: Date | null
  }

  export type PostsOnCategoriesCountAggregateOutputType = {
    postId: number
    categoryId: number
    position: number
    assignedAt: number
    _all: number
  }


  export type PostsOnCategoriesAvgAggregateInputType = {
    position?: true
  }

  export type PostsOnCategoriesSumAggregateInputType = {
    position?: true
  }

  export type PostsOnCategoriesMinAggregateInputType = {
    postId?: true
    categoryId?: true
    position?: true
    assignedAt?: true
  }

  export type PostsOnCategoriesMaxAggregateInputType = {
    postId?: true
    categoryId?: true
    position?: true
    assignedAt?: true
  }

  export type PostsOnCategoriesCountAggregateInputType = {
    postId?: true
    categoryId?: true
    position?: true
    assignedAt?: true
    _all?: true
  }

  export type PostsOnCategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostsOnCategories to aggregate.
     */
    where?: PostsOnCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostsOnCategories to fetch.
     */
    orderBy?: PostsOnCategoriesOrderByWithRelationInput | PostsOnCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostsOnCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostsOnCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostsOnCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostsOnCategories
    **/
    _count?: true | PostsOnCategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostsOnCategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostsOnCategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostsOnCategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostsOnCategoriesMaxAggregateInputType
  }

  export type GetPostsOnCategoriesAggregateType<T extends PostsOnCategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregatePostsOnCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostsOnCategories[P]>
      : GetScalarType<T[P], AggregatePostsOnCategories[P]>
  }




  export type PostsOnCategoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostsOnCategoriesWhereInput
    orderBy?: PostsOnCategoriesOrderByWithAggregationInput | PostsOnCategoriesOrderByWithAggregationInput[]
    by: PostsOnCategoriesScalarFieldEnum[] | PostsOnCategoriesScalarFieldEnum
    having?: PostsOnCategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostsOnCategoriesCountAggregateInputType | true
    _avg?: PostsOnCategoriesAvgAggregateInputType
    _sum?: PostsOnCategoriesSumAggregateInputType
    _min?: PostsOnCategoriesMinAggregateInputType
    _max?: PostsOnCategoriesMaxAggregateInputType
  }

  export type PostsOnCategoriesGroupByOutputType = {
    postId: string
    categoryId: string
    position: number | null
    assignedAt: Date
    _count: PostsOnCategoriesCountAggregateOutputType | null
    _avg: PostsOnCategoriesAvgAggregateOutputType | null
    _sum: PostsOnCategoriesSumAggregateOutputType | null
    _min: PostsOnCategoriesMinAggregateOutputType | null
    _max: PostsOnCategoriesMaxAggregateOutputType | null
  }

  type GetPostsOnCategoriesGroupByPayload<T extends PostsOnCategoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostsOnCategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostsOnCategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostsOnCategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], PostsOnCategoriesGroupByOutputType[P]>
        }
      >
    >


  export type PostsOnCategoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    categoryId?: boolean
    position?: boolean
    assignedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postsOnCategories"]>

  export type PostsOnCategoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    categoryId?: boolean
    position?: boolean
    assignedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postsOnCategories"]>

  export type PostsOnCategoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    categoryId?: boolean
    position?: boolean
    assignedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postsOnCategories"]>

  export type PostsOnCategoriesSelectScalar = {
    postId?: boolean
    categoryId?: boolean
    position?: boolean
    assignedAt?: boolean
  }

  export type PostsOnCategoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"postId" | "categoryId" | "position" | "assignedAt", ExtArgs["result"]["postsOnCategories"]>
  export type PostsOnCategoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type PostsOnCategoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type PostsOnCategoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $PostsOnCategoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostsOnCategories"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      postId: string
      categoryId: string
      position: number | null
      assignedAt: Date
    }, ExtArgs["result"]["postsOnCategories"]>
    composites: {}
  }

  type PostsOnCategoriesGetPayload<S extends boolean | null | undefined | PostsOnCategoriesDefaultArgs> = $Result.GetResult<Prisma.$PostsOnCategoriesPayload, S>

  type PostsOnCategoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostsOnCategoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostsOnCategoriesCountAggregateInputType | true
    }

  export interface PostsOnCategoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostsOnCategories'], meta: { name: 'PostsOnCategories' } }
    /**
     * Find zero or one PostsOnCategories that matches the filter.
     * @param {PostsOnCategoriesFindUniqueArgs} args - Arguments to find a PostsOnCategories
     * @example
     * // Get one PostsOnCategories
     * const postsOnCategories = await prisma.postsOnCategories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostsOnCategoriesFindUniqueArgs>(args: SelectSubset<T, PostsOnCategoriesFindUniqueArgs<ExtArgs>>): Prisma__PostsOnCategoriesClient<$Result.GetResult<Prisma.$PostsOnCategoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostsOnCategories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostsOnCategoriesFindUniqueOrThrowArgs} args - Arguments to find a PostsOnCategories
     * @example
     * // Get one PostsOnCategories
     * const postsOnCategories = await prisma.postsOnCategories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostsOnCategoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, PostsOnCategoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostsOnCategoriesClient<$Result.GetResult<Prisma.$PostsOnCategoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostsOnCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsOnCategoriesFindFirstArgs} args - Arguments to find a PostsOnCategories
     * @example
     * // Get one PostsOnCategories
     * const postsOnCategories = await prisma.postsOnCategories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostsOnCategoriesFindFirstArgs>(args?: SelectSubset<T, PostsOnCategoriesFindFirstArgs<ExtArgs>>): Prisma__PostsOnCategoriesClient<$Result.GetResult<Prisma.$PostsOnCategoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostsOnCategories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsOnCategoriesFindFirstOrThrowArgs} args - Arguments to find a PostsOnCategories
     * @example
     * // Get one PostsOnCategories
     * const postsOnCategories = await prisma.postsOnCategories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostsOnCategoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, PostsOnCategoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostsOnCategoriesClient<$Result.GetResult<Prisma.$PostsOnCategoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostsOnCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsOnCategoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostsOnCategories
     * const postsOnCategories = await prisma.postsOnCategories.findMany()
     * 
     * // Get first 10 PostsOnCategories
     * const postsOnCategories = await prisma.postsOnCategories.findMany({ take: 10 })
     * 
     * // Only select the `postId`
     * const postsOnCategoriesWithPostIdOnly = await prisma.postsOnCategories.findMany({ select: { postId: true } })
     * 
     */
    findMany<T extends PostsOnCategoriesFindManyArgs>(args?: SelectSubset<T, PostsOnCategoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsOnCategoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostsOnCategories.
     * @param {PostsOnCategoriesCreateArgs} args - Arguments to create a PostsOnCategories.
     * @example
     * // Create one PostsOnCategories
     * const PostsOnCategories = await prisma.postsOnCategories.create({
     *   data: {
     *     // ... data to create a PostsOnCategories
     *   }
     * })
     * 
     */
    create<T extends PostsOnCategoriesCreateArgs>(args: SelectSubset<T, PostsOnCategoriesCreateArgs<ExtArgs>>): Prisma__PostsOnCategoriesClient<$Result.GetResult<Prisma.$PostsOnCategoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostsOnCategories.
     * @param {PostsOnCategoriesCreateManyArgs} args - Arguments to create many PostsOnCategories.
     * @example
     * // Create many PostsOnCategories
     * const postsOnCategories = await prisma.postsOnCategories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostsOnCategoriesCreateManyArgs>(args?: SelectSubset<T, PostsOnCategoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostsOnCategories and returns the data saved in the database.
     * @param {PostsOnCategoriesCreateManyAndReturnArgs} args - Arguments to create many PostsOnCategories.
     * @example
     * // Create many PostsOnCategories
     * const postsOnCategories = await prisma.postsOnCategories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostsOnCategories and only return the `postId`
     * const postsOnCategoriesWithPostIdOnly = await prisma.postsOnCategories.createManyAndReturn({
     *   select: { postId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostsOnCategoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, PostsOnCategoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsOnCategoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostsOnCategories.
     * @param {PostsOnCategoriesDeleteArgs} args - Arguments to delete one PostsOnCategories.
     * @example
     * // Delete one PostsOnCategories
     * const PostsOnCategories = await prisma.postsOnCategories.delete({
     *   where: {
     *     // ... filter to delete one PostsOnCategories
     *   }
     * })
     * 
     */
    delete<T extends PostsOnCategoriesDeleteArgs>(args: SelectSubset<T, PostsOnCategoriesDeleteArgs<ExtArgs>>): Prisma__PostsOnCategoriesClient<$Result.GetResult<Prisma.$PostsOnCategoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostsOnCategories.
     * @param {PostsOnCategoriesUpdateArgs} args - Arguments to update one PostsOnCategories.
     * @example
     * // Update one PostsOnCategories
     * const postsOnCategories = await prisma.postsOnCategories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostsOnCategoriesUpdateArgs>(args: SelectSubset<T, PostsOnCategoriesUpdateArgs<ExtArgs>>): Prisma__PostsOnCategoriesClient<$Result.GetResult<Prisma.$PostsOnCategoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostsOnCategories.
     * @param {PostsOnCategoriesDeleteManyArgs} args - Arguments to filter PostsOnCategories to delete.
     * @example
     * // Delete a few PostsOnCategories
     * const { count } = await prisma.postsOnCategories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostsOnCategoriesDeleteManyArgs>(args?: SelectSubset<T, PostsOnCategoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostsOnCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsOnCategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostsOnCategories
     * const postsOnCategories = await prisma.postsOnCategories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostsOnCategoriesUpdateManyArgs>(args: SelectSubset<T, PostsOnCategoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostsOnCategories and returns the data updated in the database.
     * @param {PostsOnCategoriesUpdateManyAndReturnArgs} args - Arguments to update many PostsOnCategories.
     * @example
     * // Update many PostsOnCategories
     * const postsOnCategories = await prisma.postsOnCategories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostsOnCategories and only return the `postId`
     * const postsOnCategoriesWithPostIdOnly = await prisma.postsOnCategories.updateManyAndReturn({
     *   select: { postId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostsOnCategoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, PostsOnCategoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsOnCategoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostsOnCategories.
     * @param {PostsOnCategoriesUpsertArgs} args - Arguments to update or create a PostsOnCategories.
     * @example
     * // Update or create a PostsOnCategories
     * const postsOnCategories = await prisma.postsOnCategories.upsert({
     *   create: {
     *     // ... data to create a PostsOnCategories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostsOnCategories we want to update
     *   }
     * })
     */
    upsert<T extends PostsOnCategoriesUpsertArgs>(args: SelectSubset<T, PostsOnCategoriesUpsertArgs<ExtArgs>>): Prisma__PostsOnCategoriesClient<$Result.GetResult<Prisma.$PostsOnCategoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostsOnCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsOnCategoriesCountArgs} args - Arguments to filter PostsOnCategories to count.
     * @example
     * // Count the number of PostsOnCategories
     * const count = await prisma.postsOnCategories.count({
     *   where: {
     *     // ... the filter for the PostsOnCategories we want to count
     *   }
     * })
    **/
    count<T extends PostsOnCategoriesCountArgs>(
      args?: Subset<T, PostsOnCategoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostsOnCategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostsOnCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsOnCategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostsOnCategoriesAggregateArgs>(args: Subset<T, PostsOnCategoriesAggregateArgs>): Prisma.PrismaPromise<GetPostsOnCategoriesAggregateType<T>>

    /**
     * Group by PostsOnCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsOnCategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostsOnCategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostsOnCategoriesGroupByArgs['orderBy'] }
        : { orderBy?: PostsOnCategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostsOnCategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostsOnCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostsOnCategories model
   */
  readonly fields: PostsOnCategoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostsOnCategories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostsOnCategoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostsOnCategories model
   */
  interface PostsOnCategoriesFieldRefs {
    readonly postId: FieldRef<"PostsOnCategories", 'String'>
    readonly categoryId: FieldRef<"PostsOnCategories", 'String'>
    readonly position: FieldRef<"PostsOnCategories", 'Int'>
    readonly assignedAt: FieldRef<"PostsOnCategories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostsOnCategories findUnique
   */
  export type PostsOnCategoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnCategories
     */
    select?: PostsOnCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnCategories
     */
    omit?: PostsOnCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which PostsOnCategories to fetch.
     */
    where: PostsOnCategoriesWhereUniqueInput
  }

  /**
   * PostsOnCategories findUniqueOrThrow
   */
  export type PostsOnCategoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnCategories
     */
    select?: PostsOnCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnCategories
     */
    omit?: PostsOnCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which PostsOnCategories to fetch.
     */
    where: PostsOnCategoriesWhereUniqueInput
  }

  /**
   * PostsOnCategories findFirst
   */
  export type PostsOnCategoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnCategories
     */
    select?: PostsOnCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnCategories
     */
    omit?: PostsOnCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which PostsOnCategories to fetch.
     */
    where?: PostsOnCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostsOnCategories to fetch.
     */
    orderBy?: PostsOnCategoriesOrderByWithRelationInput | PostsOnCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostsOnCategories.
     */
    cursor?: PostsOnCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostsOnCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostsOnCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostsOnCategories.
     */
    distinct?: PostsOnCategoriesScalarFieldEnum | PostsOnCategoriesScalarFieldEnum[]
  }

  /**
   * PostsOnCategories findFirstOrThrow
   */
  export type PostsOnCategoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnCategories
     */
    select?: PostsOnCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnCategories
     */
    omit?: PostsOnCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which PostsOnCategories to fetch.
     */
    where?: PostsOnCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostsOnCategories to fetch.
     */
    orderBy?: PostsOnCategoriesOrderByWithRelationInput | PostsOnCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostsOnCategories.
     */
    cursor?: PostsOnCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostsOnCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostsOnCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostsOnCategories.
     */
    distinct?: PostsOnCategoriesScalarFieldEnum | PostsOnCategoriesScalarFieldEnum[]
  }

  /**
   * PostsOnCategories findMany
   */
  export type PostsOnCategoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnCategories
     */
    select?: PostsOnCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnCategories
     */
    omit?: PostsOnCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which PostsOnCategories to fetch.
     */
    where?: PostsOnCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostsOnCategories to fetch.
     */
    orderBy?: PostsOnCategoriesOrderByWithRelationInput | PostsOnCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostsOnCategories.
     */
    cursor?: PostsOnCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostsOnCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostsOnCategories.
     */
    skip?: number
    distinct?: PostsOnCategoriesScalarFieldEnum | PostsOnCategoriesScalarFieldEnum[]
  }

  /**
   * PostsOnCategories create
   */
  export type PostsOnCategoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnCategories
     */
    select?: PostsOnCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnCategories
     */
    omit?: PostsOnCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnCategoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a PostsOnCategories.
     */
    data: XOR<PostsOnCategoriesCreateInput, PostsOnCategoriesUncheckedCreateInput>
  }

  /**
   * PostsOnCategories createMany
   */
  export type PostsOnCategoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostsOnCategories.
     */
    data: PostsOnCategoriesCreateManyInput | PostsOnCategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostsOnCategories createManyAndReturn
   */
  export type PostsOnCategoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnCategories
     */
    select?: PostsOnCategoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnCategories
     */
    omit?: PostsOnCategoriesOmit<ExtArgs> | null
    /**
     * The data used to create many PostsOnCategories.
     */
    data: PostsOnCategoriesCreateManyInput | PostsOnCategoriesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnCategoriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostsOnCategories update
   */
  export type PostsOnCategoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnCategories
     */
    select?: PostsOnCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnCategories
     */
    omit?: PostsOnCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnCategoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a PostsOnCategories.
     */
    data: XOR<PostsOnCategoriesUpdateInput, PostsOnCategoriesUncheckedUpdateInput>
    /**
     * Choose, which PostsOnCategories to update.
     */
    where: PostsOnCategoriesWhereUniqueInput
  }

  /**
   * PostsOnCategories updateMany
   */
  export type PostsOnCategoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostsOnCategories.
     */
    data: XOR<PostsOnCategoriesUpdateManyMutationInput, PostsOnCategoriesUncheckedUpdateManyInput>
    /**
     * Filter which PostsOnCategories to update
     */
    where?: PostsOnCategoriesWhereInput
    /**
     * Limit how many PostsOnCategories to update.
     */
    limit?: number
  }

  /**
   * PostsOnCategories updateManyAndReturn
   */
  export type PostsOnCategoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnCategories
     */
    select?: PostsOnCategoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnCategories
     */
    omit?: PostsOnCategoriesOmit<ExtArgs> | null
    /**
     * The data used to update PostsOnCategories.
     */
    data: XOR<PostsOnCategoriesUpdateManyMutationInput, PostsOnCategoriesUncheckedUpdateManyInput>
    /**
     * Filter which PostsOnCategories to update
     */
    where?: PostsOnCategoriesWhereInput
    /**
     * Limit how many PostsOnCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnCategoriesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostsOnCategories upsert
   */
  export type PostsOnCategoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnCategories
     */
    select?: PostsOnCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnCategories
     */
    omit?: PostsOnCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnCategoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the PostsOnCategories to update in case it exists.
     */
    where: PostsOnCategoriesWhereUniqueInput
    /**
     * In case the PostsOnCategories found by the `where` argument doesn't exist, create a new PostsOnCategories with this data.
     */
    create: XOR<PostsOnCategoriesCreateInput, PostsOnCategoriesUncheckedCreateInput>
    /**
     * In case the PostsOnCategories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostsOnCategoriesUpdateInput, PostsOnCategoriesUncheckedUpdateInput>
  }

  /**
   * PostsOnCategories delete
   */
  export type PostsOnCategoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnCategories
     */
    select?: PostsOnCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnCategories
     */
    omit?: PostsOnCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnCategoriesInclude<ExtArgs> | null
    /**
     * Filter which PostsOnCategories to delete.
     */
    where: PostsOnCategoriesWhereUniqueInput
  }

  /**
   * PostsOnCategories deleteMany
   */
  export type PostsOnCategoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostsOnCategories to delete
     */
    where?: PostsOnCategoriesWhereInput
    /**
     * Limit how many PostsOnCategories to delete.
     */
    limit?: number
  }

  /**
   * PostsOnCategories without action
   */
  export type PostsOnCategoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsOnCategories
     */
    select?: PostsOnCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsOnCategories
     */
    omit?: PostsOnCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsOnCategoriesInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    postId: string | null
    authorId: string | null
    contentText: string | null
    status: $Enums.CommentStatus | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    authorId: string | null
    contentText: string | null
    status: $Enums.CommentStatus | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    postId: number
    authorId: number
    content: number
    contentText: number
    status: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    contentText?: true
    status?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    contentText?: true
    status?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    content?: true
    contentText?: true
    status?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    postId: string
    authorId: string
    content: JsonValue | null
    contentText: string | null
    status: $Enums.CommentStatus
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    authorId?: boolean
    content?: boolean
    contentText?: boolean
    status?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    children?: boolean | Comment$childrenArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    authorId?: boolean
    content?: boolean
    contentText?: boolean
    status?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    authorId?: boolean
    content?: boolean
    contentText?: boolean
    status?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    postId?: boolean
    authorId?: boolean
    content?: boolean
    contentText?: boolean
    status?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "authorId" | "content" | "contentText" | "status" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    children?: boolean | Comment$childrenArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$CommentPayload<ExtArgs> | null
      children: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      authorId: string
      content: Prisma.JsonValue | null
      contentText: string | null
      status: $Enums.CommentStatus
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends Comment$parentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Comment$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Comment$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly postId: FieldRef<"Comment", 'String'>
    readonly authorId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'Json'>
    readonly contentText: FieldRef<"Comment", 'String'>
    readonly status: FieldRef<"Comment", 'CommentStatus'>
    readonly parentId: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.parent
   */
  export type Comment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.children
   */
  export type Comment$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Reaction
   */

  export type AggregateReaction = {
    _count: ReactionCountAggregateOutputType | null
    _min: ReactionMinAggregateOutputType | null
    _max: ReactionMaxAggregateOutputType | null
  }

  export type ReactionMinAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    type: $Enums.ReactionType | null
    createdAt: Date | null
  }

  export type ReactionMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    type: $Enums.ReactionType | null
    createdAt: Date | null
  }

  export type ReactionCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    type: number
    createdAt: number
    _all: number
  }


  export type ReactionMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    type?: true
    createdAt?: true
  }

  export type ReactionMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    type?: true
    createdAt?: true
  }

  export type ReactionCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type ReactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reaction to aggregate.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reactions
    **/
    _count?: true | ReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReactionMaxAggregateInputType
  }

  export type GetReactionAggregateType<T extends ReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReaction[P]>
      : GetScalarType<T[P], AggregateReaction[P]>
  }




  export type ReactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithAggregationInput | ReactionOrderByWithAggregationInput[]
    by: ReactionScalarFieldEnum[] | ReactionScalarFieldEnum
    having?: ReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReactionCountAggregateInputType | true
    _min?: ReactionMinAggregateInputType
    _max?: ReactionMaxAggregateInputType
  }

  export type ReactionGroupByOutputType = {
    id: string
    postId: string
    userId: string
    type: $Enums.ReactionType
    createdAt: Date
    _count: ReactionCountAggregateOutputType | null
    _min: ReactionMinAggregateOutputType | null
    _max: ReactionMaxAggregateOutputType | null
  }

  type GetReactionGroupByPayload<T extends ReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReactionGroupByOutputType[P]>
            : GetScalarType<T[P], ReactionGroupByOutputType[P]>
        }
      >
    >


  export type ReactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reaction"]>

  export type ReactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reaction"]>

  export type ReactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reaction"]>

  export type ReactionSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type ReactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "userId" | "type" | "createdAt", ExtArgs["result"]["reaction"]>
  export type ReactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reaction"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      userId: string
      type: $Enums.ReactionType
      createdAt: Date
    }, ExtArgs["result"]["reaction"]>
    composites: {}
  }

  type ReactionGetPayload<S extends boolean | null | undefined | ReactionDefaultArgs> = $Result.GetResult<Prisma.$ReactionPayload, S>

  type ReactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReactionCountAggregateInputType | true
    }

  export interface ReactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reaction'], meta: { name: 'Reaction' } }
    /**
     * Find zero or one Reaction that matches the filter.
     * @param {ReactionFindUniqueArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReactionFindUniqueArgs>(args: SelectSubset<T, ReactionFindUniqueArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReactionFindUniqueOrThrowArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReactionFindUniqueOrThrowArgs>(args: SelectSubset<T, ReactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindFirstArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReactionFindFirstArgs>(args?: SelectSubset<T, ReactionFindFirstArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindFirstOrThrowArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReactionFindFirstOrThrowArgs>(args?: SelectSubset<T, ReactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reactions
     * const reactions = await prisma.reaction.findMany()
     * 
     * // Get first 10 Reactions
     * const reactions = await prisma.reaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reactionWithIdOnly = await prisma.reaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReactionFindManyArgs>(args?: SelectSubset<T, ReactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reaction.
     * @param {ReactionCreateArgs} args - Arguments to create a Reaction.
     * @example
     * // Create one Reaction
     * const Reaction = await prisma.reaction.create({
     *   data: {
     *     // ... data to create a Reaction
     *   }
     * })
     * 
     */
    create<T extends ReactionCreateArgs>(args: SelectSubset<T, ReactionCreateArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reactions.
     * @param {ReactionCreateManyArgs} args - Arguments to create many Reactions.
     * @example
     * // Create many Reactions
     * const reaction = await prisma.reaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReactionCreateManyArgs>(args?: SelectSubset<T, ReactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reactions and returns the data saved in the database.
     * @param {ReactionCreateManyAndReturnArgs} args - Arguments to create many Reactions.
     * @example
     * // Create many Reactions
     * const reaction = await prisma.reaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reactions and only return the `id`
     * const reactionWithIdOnly = await prisma.reaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReactionCreateManyAndReturnArgs>(args?: SelectSubset<T, ReactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reaction.
     * @param {ReactionDeleteArgs} args - Arguments to delete one Reaction.
     * @example
     * // Delete one Reaction
     * const Reaction = await prisma.reaction.delete({
     *   where: {
     *     // ... filter to delete one Reaction
     *   }
     * })
     * 
     */
    delete<T extends ReactionDeleteArgs>(args: SelectSubset<T, ReactionDeleteArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reaction.
     * @param {ReactionUpdateArgs} args - Arguments to update one Reaction.
     * @example
     * // Update one Reaction
     * const reaction = await prisma.reaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReactionUpdateArgs>(args: SelectSubset<T, ReactionUpdateArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reactions.
     * @param {ReactionDeleteManyArgs} args - Arguments to filter Reactions to delete.
     * @example
     * // Delete a few Reactions
     * const { count } = await prisma.reaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReactionDeleteManyArgs>(args?: SelectSubset<T, ReactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reactions
     * const reaction = await prisma.reaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReactionUpdateManyArgs>(args: SelectSubset<T, ReactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reactions and returns the data updated in the database.
     * @param {ReactionUpdateManyAndReturnArgs} args - Arguments to update many Reactions.
     * @example
     * // Update many Reactions
     * const reaction = await prisma.reaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reactions and only return the `id`
     * const reactionWithIdOnly = await prisma.reaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReactionUpdateManyAndReturnArgs>(args: SelectSubset<T, ReactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reaction.
     * @param {ReactionUpsertArgs} args - Arguments to update or create a Reaction.
     * @example
     * // Update or create a Reaction
     * const reaction = await prisma.reaction.upsert({
     *   create: {
     *     // ... data to create a Reaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reaction we want to update
     *   }
     * })
     */
    upsert<T extends ReactionUpsertArgs>(args: SelectSubset<T, ReactionUpsertArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionCountArgs} args - Arguments to filter Reactions to count.
     * @example
     * // Count the number of Reactions
     * const count = await prisma.reaction.count({
     *   where: {
     *     // ... the filter for the Reactions we want to count
     *   }
     * })
    **/
    count<T extends ReactionCountArgs>(
      args?: Subset<T, ReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReactionAggregateArgs>(args: Subset<T, ReactionAggregateArgs>): Prisma.PrismaPromise<GetReactionAggregateType<T>>

    /**
     * Group by Reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReactionGroupByArgs['orderBy'] }
        : { orderBy?: ReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reaction model
   */
  readonly fields: ReactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reaction model
   */
  interface ReactionFieldRefs {
    readonly id: FieldRef<"Reaction", 'String'>
    readonly postId: FieldRef<"Reaction", 'String'>
    readonly userId: FieldRef<"Reaction", 'String'>
    readonly type: FieldRef<"Reaction", 'ReactionType'>
    readonly createdAt: FieldRef<"Reaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reaction findUnique
   */
  export type ReactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction findUniqueOrThrow
   */
  export type ReactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction findFirst
   */
  export type ReactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reactions.
     */
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction findFirstOrThrow
   */
  export type ReactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reactions.
     */
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction findMany
   */
  export type ReactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reactions to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction create
   */
  export type ReactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Reaction.
     */
    data: XOR<ReactionCreateInput, ReactionUncheckedCreateInput>
  }

  /**
   * Reaction createMany
   */
  export type ReactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reactions.
     */
    data: ReactionCreateManyInput | ReactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reaction createManyAndReturn
   */
  export type ReactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * The data used to create many Reactions.
     */
    data: ReactionCreateManyInput | ReactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reaction update
   */
  export type ReactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Reaction.
     */
    data: XOR<ReactionUpdateInput, ReactionUncheckedUpdateInput>
    /**
     * Choose, which Reaction to update.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction updateMany
   */
  export type ReactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reactions.
     */
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyInput>
    /**
     * Filter which Reactions to update
     */
    where?: ReactionWhereInput
    /**
     * Limit how many Reactions to update.
     */
    limit?: number
  }

  /**
   * Reaction updateManyAndReturn
   */
  export type ReactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * The data used to update Reactions.
     */
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyInput>
    /**
     * Filter which Reactions to update
     */
    where?: ReactionWhereInput
    /**
     * Limit how many Reactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reaction upsert
   */
  export type ReactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Reaction to update in case it exists.
     */
    where: ReactionWhereUniqueInput
    /**
     * In case the Reaction found by the `where` argument doesn't exist, create a new Reaction with this data.
     */
    create: XOR<ReactionCreateInput, ReactionUncheckedCreateInput>
    /**
     * In case the Reaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReactionUpdateInput, ReactionUncheckedUpdateInput>
  }

  /**
   * Reaction delete
   */
  export type ReactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter which Reaction to delete.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction deleteMany
   */
  export type ReactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reactions to delete
     */
    where?: ReactionWhereInput
    /**
     * Limit how many Reactions to delete.
     */
    limit?: number
  }

  /**
   * Reaction without action
   */
  export type ReactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reaction
     */
    omit?: ReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    fundingGoal: number | null
    amountRaised: number | null
    duration: number | null
    sdgAlignment: number | null
    valuation: number | null
    minInvestment: number | null
    capitalPercentage: number | null
    expectedInvestors: number | null
    interestRate: number | null
    loanDuration: number | null
    minLoanAmount: number | null
  }

  export type ProjectSumAggregateOutputType = {
    fundingGoal: number | null
    amountRaised: number | null
    duration: number | null
    sdgAlignment: number[]
    valuation: number | null
    minInvestment: number | null
    capitalPercentage: number | null
    expectedInvestors: number | null
    interestRate: number | null
    loanDuration: number | null
    minLoanAmount: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    shortDescription: string | null
    type: $Enums.ProjectType | null
    status: $Enums.ProjectStatus | null
    category: $Enums.ProjectCategory | null
    location: string | null
    fundingGoal: number | null
    amountRaised: number | null
    currency: string | null
    startDate: Date | null
    endDate: Date | null
    duration: number | null
    ownerId: string | null
    organization: string | null
    legalStatus: string | null
    website: string | null
    contactEmail: string | null
    contactPhone: string | null
    impactDescription: string | null
    visibility: $Enums.PostVisibility | null
    allowComments: boolean | null
    enableImpactSprint: boolean | null
    valuation: number | null
    minInvestment: number | null
    capitalPercentage: number | null
    expectedInvestors: number | null
    taxAdvantages: string | null
    interestRate: number | null
    loanDuration: number | null
    repaymentFrequency: string | null
    minLoanAmount: number | null
    guarantees: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    shortDescription: string | null
    type: $Enums.ProjectType | null
    status: $Enums.ProjectStatus | null
    category: $Enums.ProjectCategory | null
    location: string | null
    fundingGoal: number | null
    amountRaised: number | null
    currency: string | null
    startDate: Date | null
    endDate: Date | null
    duration: number | null
    ownerId: string | null
    organization: string | null
    legalStatus: string | null
    website: string | null
    contactEmail: string | null
    contactPhone: string | null
    impactDescription: string | null
    visibility: $Enums.PostVisibility | null
    allowComments: boolean | null
    enableImpactSprint: boolean | null
    valuation: number | null
    minInvestment: number | null
    capitalPercentage: number | null
    expectedInvestors: number | null
    taxAdvantages: string | null
    interestRate: number | null
    loanDuration: number | null
    repaymentFrequency: string | null
    minLoanAmount: number | null
    guarantees: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    shortDescription: number
    type: number
    status: number
    category: number
    location: number
    fundingGoal: number
    amountRaised: number
    currency: number
    startDate: number
    endDate: number
    duration: number
    ownerId: number
    organization: number
    legalStatus: number
    website: number
    socialMedia: number
    contactEmail: number
    contactPhone: number
    impactTypes: number
    impactDescription: number
    impactIndicators: number
    sdgAlignment: number
    images: number
    videos: number
    documents: number
    visibility: number
    allowComments: number
    enableImpactSprint: number
    valuation: number
    minInvestment: number
    capitalPercentage: number
    expectedInvestors: number
    taxAdvantages: number
    interestRate: number
    loanDuration: number
    repaymentFrequency: number
    minLoanAmount: number
    guarantees: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    fundingGoal?: true
    amountRaised?: true
    duration?: true
    sdgAlignment?: true
    valuation?: true
    minInvestment?: true
    capitalPercentage?: true
    expectedInvestors?: true
    interestRate?: true
    loanDuration?: true
    minLoanAmount?: true
  }

  export type ProjectSumAggregateInputType = {
    fundingGoal?: true
    amountRaised?: true
    duration?: true
    sdgAlignment?: true
    valuation?: true
    minInvestment?: true
    capitalPercentage?: true
    expectedInvestors?: true
    interestRate?: true
    loanDuration?: true
    minLoanAmount?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    shortDescription?: true
    type?: true
    status?: true
    category?: true
    location?: true
    fundingGoal?: true
    amountRaised?: true
    currency?: true
    startDate?: true
    endDate?: true
    duration?: true
    ownerId?: true
    organization?: true
    legalStatus?: true
    website?: true
    contactEmail?: true
    contactPhone?: true
    impactDescription?: true
    visibility?: true
    allowComments?: true
    enableImpactSprint?: true
    valuation?: true
    minInvestment?: true
    capitalPercentage?: true
    expectedInvestors?: true
    taxAdvantages?: true
    interestRate?: true
    loanDuration?: true
    repaymentFrequency?: true
    minLoanAmount?: true
    guarantees?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    shortDescription?: true
    type?: true
    status?: true
    category?: true
    location?: true
    fundingGoal?: true
    amountRaised?: true
    currency?: true
    startDate?: true
    endDate?: true
    duration?: true
    ownerId?: true
    organization?: true
    legalStatus?: true
    website?: true
    contactEmail?: true
    contactPhone?: true
    impactDescription?: true
    visibility?: true
    allowComments?: true
    enableImpactSprint?: true
    valuation?: true
    minInvestment?: true
    capitalPercentage?: true
    expectedInvestors?: true
    taxAdvantages?: true
    interestRate?: true
    loanDuration?: true
    repaymentFrequency?: true
    minLoanAmount?: true
    guarantees?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    shortDescription?: true
    type?: true
    status?: true
    category?: true
    location?: true
    fundingGoal?: true
    amountRaised?: true
    currency?: true
    startDate?: true
    endDate?: true
    duration?: true
    ownerId?: true
    organization?: true
    legalStatus?: true
    website?: true
    socialMedia?: true
    contactEmail?: true
    contactPhone?: true
    impactTypes?: true
    impactDescription?: true
    impactIndicators?: true
    sdgAlignment?: true
    images?: true
    videos?: true
    documents?: true
    visibility?: true
    allowComments?: true
    enableImpactSprint?: true
    valuation?: true
    minInvestment?: true
    capitalPercentage?: true
    expectedInvestors?: true
    taxAdvantages?: true
    interestRate?: true
    loanDuration?: true
    repaymentFrequency?: true
    minLoanAmount?: true
    guarantees?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    shortDescription: string | null
    type: $Enums.ProjectType
    status: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location: string | null
    fundingGoal: number
    amountRaised: number
    currency: string
    startDate: Date | null
    endDate: Date | null
    duration: number | null
    ownerId: string
    organization: string | null
    legalStatus: string | null
    website: string | null
    socialMedia: JsonValue | null
    contactEmail: string | null
    contactPhone: string | null
    impactTypes: $Enums.ProjectImpactType[]
    impactDescription: string | null
    impactIndicators: string[]
    sdgAlignment: number[]
    images: string[]
    videos: string[]
    documents: string[]
    visibility: $Enums.PostVisibility
    allowComments: boolean
    enableImpactSprint: boolean
    valuation: number | null
    minInvestment: number | null
    capitalPercentage: number | null
    expectedInvestors: number | null
    taxAdvantages: string | null
    interestRate: number | null
    loanDuration: number | null
    repaymentFrequency: string | null
    minLoanAmount: number | null
    guarantees: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    shortDescription?: boolean
    type?: boolean
    status?: boolean
    category?: boolean
    location?: boolean
    fundingGoal?: boolean
    amountRaised?: boolean
    currency?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    ownerId?: boolean
    organization?: boolean
    legalStatus?: boolean
    website?: boolean
    socialMedia?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    impactTypes?: boolean
    impactDescription?: boolean
    impactIndicators?: boolean
    sdgAlignment?: boolean
    images?: boolean
    videos?: boolean
    documents?: boolean
    visibility?: boolean
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: boolean
    minInvestment?: boolean
    capitalPercentage?: boolean
    expectedInvestors?: boolean
    taxAdvantages?: boolean
    interestRate?: boolean
    loanDuration?: boolean
    repaymentFrequency?: boolean
    minLoanAmount?: boolean
    guarantees?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    posts?: boolean | Project$postsArgs<ExtArgs>
    updates?: boolean | Project$updatesArgs<ExtArgs>
    rewards?: boolean | Project$rewardsArgs<ExtArgs>
    donations?: boolean | Project$donationsArgs<ExtArgs>
    investments?: boolean | Project$investmentsArgs<ExtArgs>
    loans?: boolean | Project$loansArgs<ExtArgs>
    Transaction?: boolean | Project$TransactionArgs<ExtArgs>
    CircleProject?: boolean | Project$CircleProjectArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    shortDescription?: boolean
    type?: boolean
    status?: boolean
    category?: boolean
    location?: boolean
    fundingGoal?: boolean
    amountRaised?: boolean
    currency?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    ownerId?: boolean
    organization?: boolean
    legalStatus?: boolean
    website?: boolean
    socialMedia?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    impactTypes?: boolean
    impactDescription?: boolean
    impactIndicators?: boolean
    sdgAlignment?: boolean
    images?: boolean
    videos?: boolean
    documents?: boolean
    visibility?: boolean
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: boolean
    minInvestment?: boolean
    capitalPercentage?: boolean
    expectedInvestors?: boolean
    taxAdvantages?: boolean
    interestRate?: boolean
    loanDuration?: boolean
    repaymentFrequency?: boolean
    minLoanAmount?: boolean
    guarantees?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    shortDescription?: boolean
    type?: boolean
    status?: boolean
    category?: boolean
    location?: boolean
    fundingGoal?: boolean
    amountRaised?: boolean
    currency?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    ownerId?: boolean
    organization?: boolean
    legalStatus?: boolean
    website?: boolean
    socialMedia?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    impactTypes?: boolean
    impactDescription?: boolean
    impactIndicators?: boolean
    sdgAlignment?: boolean
    images?: boolean
    videos?: boolean
    documents?: boolean
    visibility?: boolean
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: boolean
    minInvestment?: boolean
    capitalPercentage?: boolean
    expectedInvestors?: boolean
    taxAdvantages?: boolean
    interestRate?: boolean
    loanDuration?: boolean
    repaymentFrequency?: boolean
    minLoanAmount?: boolean
    guarantees?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    shortDescription?: boolean
    type?: boolean
    status?: boolean
    category?: boolean
    location?: boolean
    fundingGoal?: boolean
    amountRaised?: boolean
    currency?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    ownerId?: boolean
    organization?: boolean
    legalStatus?: boolean
    website?: boolean
    socialMedia?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    impactTypes?: boolean
    impactDescription?: boolean
    impactIndicators?: boolean
    sdgAlignment?: boolean
    images?: boolean
    videos?: boolean
    documents?: boolean
    visibility?: boolean
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: boolean
    minInvestment?: boolean
    capitalPercentage?: boolean
    expectedInvestors?: boolean
    taxAdvantages?: boolean
    interestRate?: boolean
    loanDuration?: boolean
    repaymentFrequency?: boolean
    minLoanAmount?: boolean
    guarantees?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "shortDescription" | "type" | "status" | "category" | "location" | "fundingGoal" | "amountRaised" | "currency" | "startDate" | "endDate" | "duration" | "ownerId" | "organization" | "legalStatus" | "website" | "socialMedia" | "contactEmail" | "contactPhone" | "impactTypes" | "impactDescription" | "impactIndicators" | "sdgAlignment" | "images" | "videos" | "documents" | "visibility" | "allowComments" | "enableImpactSprint" | "valuation" | "minInvestment" | "capitalPercentage" | "expectedInvestors" | "taxAdvantages" | "interestRate" | "loanDuration" | "repaymentFrequency" | "minLoanAmount" | "guarantees" | "createdAt" | "updatedAt", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    posts?: boolean | Project$postsArgs<ExtArgs>
    updates?: boolean | Project$updatesArgs<ExtArgs>
    rewards?: boolean | Project$rewardsArgs<ExtArgs>
    donations?: boolean | Project$donationsArgs<ExtArgs>
    investments?: boolean | Project$investmentsArgs<ExtArgs>
    loans?: boolean | Project$loansArgs<ExtArgs>
    Transaction?: boolean | Project$TransactionArgs<ExtArgs>
    CircleProject?: boolean | Project$CircleProjectArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$ProjectMemberPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      updates: Prisma.$ProjectUpdatePayload<ExtArgs>[]
      rewards: Prisma.$ProjectRewardPayload<ExtArgs>[]
      donations: Prisma.$ProjectDonationPayload<ExtArgs>[]
      investments: Prisma.$ProjectInvestmentPayload<ExtArgs>[]
      loans: Prisma.$ProjectLoanPayload<ExtArgs>[]
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
      CircleProject: Prisma.$CircleProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      shortDescription: string | null
      type: $Enums.ProjectType
      status: $Enums.ProjectStatus
      category: $Enums.ProjectCategory
      location: string | null
      fundingGoal: number
      amountRaised: number
      currency: string
      startDate: Date | null
      endDate: Date | null
      duration: number | null
      ownerId: string
      organization: string | null
      legalStatus: string | null
      website: string | null
      socialMedia: Prisma.JsonValue | null
      contactEmail: string | null
      contactPhone: string | null
      impactTypes: $Enums.ProjectImpactType[]
      impactDescription: string | null
      impactIndicators: string[]
      sdgAlignment: number[]
      images: string[]
      videos: string[]
      documents: string[]
      visibility: $Enums.PostVisibility
      allowComments: boolean
      enableImpactSprint: boolean
      valuation: number | null
      minInvestment: number | null
      capitalPercentage: number | null
      expectedInvestors: number | null
      taxAdvantages: string | null
      interestRate: number | null
      loanDuration: number | null
      repaymentFrequency: string | null
      minLoanAmount: number | null
      guarantees: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Project$membersArgs<ExtArgs> = {}>(args?: Subset<T, Project$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends Project$postsArgs<ExtArgs> = {}>(args?: Subset<T, Project$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updates<T extends Project$updatesArgs<ExtArgs> = {}>(args?: Subset<T, Project$updatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rewards<T extends Project$rewardsArgs<ExtArgs> = {}>(args?: Subset<T, Project$rewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    donations<T extends Project$donationsArgs<ExtArgs> = {}>(args?: Subset<T, Project$donationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDonationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    investments<T extends Project$investmentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$investmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectInvestmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    loans<T extends Project$loansArgs<ExtArgs> = {}>(args?: Subset<T, Project$loansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectLoanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transaction<T extends Project$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, Project$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CircleProject<T extends Project$CircleProjectArgs<ExtArgs> = {}>(args?: Subset<T, Project$CircleProjectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CircleProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly slug: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly shortDescription: FieldRef<"Project", 'String'>
    readonly type: FieldRef<"Project", 'ProjectType'>
    readonly status: FieldRef<"Project", 'ProjectStatus'>
    readonly category: FieldRef<"Project", 'ProjectCategory'>
    readonly location: FieldRef<"Project", 'String'>
    readonly fundingGoal: FieldRef<"Project", 'Float'>
    readonly amountRaised: FieldRef<"Project", 'Float'>
    readonly currency: FieldRef<"Project", 'String'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly duration: FieldRef<"Project", 'Int'>
    readonly ownerId: FieldRef<"Project", 'String'>
    readonly organization: FieldRef<"Project", 'String'>
    readonly legalStatus: FieldRef<"Project", 'String'>
    readonly website: FieldRef<"Project", 'String'>
    readonly socialMedia: FieldRef<"Project", 'Json'>
    readonly contactEmail: FieldRef<"Project", 'String'>
    readonly contactPhone: FieldRef<"Project", 'String'>
    readonly impactTypes: FieldRef<"Project", 'ProjectImpactType[]'>
    readonly impactDescription: FieldRef<"Project", 'String'>
    readonly impactIndicators: FieldRef<"Project", 'String[]'>
    readonly sdgAlignment: FieldRef<"Project", 'Int[]'>
    readonly images: FieldRef<"Project", 'String[]'>
    readonly videos: FieldRef<"Project", 'String[]'>
    readonly documents: FieldRef<"Project", 'String[]'>
    readonly visibility: FieldRef<"Project", 'PostVisibility'>
    readonly allowComments: FieldRef<"Project", 'Boolean'>
    readonly enableImpactSprint: FieldRef<"Project", 'Boolean'>
    readonly valuation: FieldRef<"Project", 'Float'>
    readonly minInvestment: FieldRef<"Project", 'Float'>
    readonly capitalPercentage: FieldRef<"Project", 'Float'>
    readonly expectedInvestors: FieldRef<"Project", 'Int'>
    readonly taxAdvantages: FieldRef<"Project", 'String'>
    readonly interestRate: FieldRef<"Project", 'Float'>
    readonly loanDuration: FieldRef<"Project", 'Int'>
    readonly repaymentFrequency: FieldRef<"Project", 'String'>
    readonly minLoanAmount: FieldRef<"Project", 'Float'>
    readonly guarantees: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.members
   */
  export type Project$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * Project.posts
   */
  export type Project$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Project.updates
   */
  export type Project$updatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    where?: ProjectUpdateWhereInput
    orderBy?: ProjectUpdateOrderByWithRelationInput | ProjectUpdateOrderByWithRelationInput[]
    cursor?: ProjectUpdateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectUpdateScalarFieldEnum | ProjectUpdateScalarFieldEnum[]
  }

  /**
   * Project.rewards
   */
  export type Project$rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectReward
     */
    select?: ProjectRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectReward
     */
    omit?: ProjectRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRewardInclude<ExtArgs> | null
    where?: ProjectRewardWhereInput
    orderBy?: ProjectRewardOrderByWithRelationInput | ProjectRewardOrderByWithRelationInput[]
    cursor?: ProjectRewardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectRewardScalarFieldEnum | ProjectRewardScalarFieldEnum[]
  }

  /**
   * Project.donations
   */
  export type Project$donationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDonation
     */
    select?: ProjectDonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDonation
     */
    omit?: ProjectDonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDonationInclude<ExtArgs> | null
    where?: ProjectDonationWhereInput
    orderBy?: ProjectDonationOrderByWithRelationInput | ProjectDonationOrderByWithRelationInput[]
    cursor?: ProjectDonationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectDonationScalarFieldEnum | ProjectDonationScalarFieldEnum[]
  }

  /**
   * Project.investments
   */
  export type Project$investmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvestment
     */
    select?: ProjectInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvestment
     */
    omit?: ProjectInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvestmentInclude<ExtArgs> | null
    where?: ProjectInvestmentWhereInput
    orderBy?: ProjectInvestmentOrderByWithRelationInput | ProjectInvestmentOrderByWithRelationInput[]
    cursor?: ProjectInvestmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectInvestmentScalarFieldEnum | ProjectInvestmentScalarFieldEnum[]
  }

  /**
   * Project.loans
   */
  export type Project$loansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLoan
     */
    select?: ProjectLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLoan
     */
    omit?: ProjectLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLoanInclude<ExtArgs> | null
    where?: ProjectLoanWhereInput
    orderBy?: ProjectLoanOrderByWithRelationInput | ProjectLoanOrderByWithRelationInput[]
    cursor?: ProjectLoanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectLoanScalarFieldEnum | ProjectLoanScalarFieldEnum[]
  }

  /**
   * Project.Transaction
   */
  export type Project$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Project.CircleProject
   */
  export type Project$CircleProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleProject
     */
    select?: CircleProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleProject
     */
    omit?: CircleProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleProjectInclude<ExtArgs> | null
    where?: CircleProjectWhereInput
    orderBy?: CircleProjectOrderByWithRelationInput | CircleProjectOrderByWithRelationInput[]
    cursor?: CircleProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CircleProjectScalarFieldEnum | CircleProjectScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectMember
   */

  export type AggregateProjectMember = {
    _count: ProjectMemberCountAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  export type ProjectMemberMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type ProjectMemberMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type ProjectMemberCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type ProjectMemberMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type ProjectMemberMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type ProjectMemberCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type ProjectMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMember to aggregate.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectMembers
    **/
    _count?: true | ProjectMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type GetProjectMemberAggregateType<T extends ProjectMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMember[P]>
      : GetScalarType<T[P], AggregateProjectMember[P]>
  }




  export type ProjectMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithAggregationInput | ProjectMemberOrderByWithAggregationInput[]
    by: ProjectMemberScalarFieldEnum[] | ProjectMemberScalarFieldEnum
    having?: ProjectMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMemberCountAggregateInputType | true
    _min?: ProjectMemberMinAggregateInputType
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type ProjectMemberGroupByOutputType = {
    id: string
    projectId: string
    userId: string
    role: string
    joinedAt: Date
    _count: ProjectMemberCountAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  type GetProjectMemberGroupByPayload<T extends ProjectMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
        }
      >
    >


  export type ProjectMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type ProjectMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "userId" | "role" | "joinedAt", ExtArgs["result"]["projectMember"]>
  export type ProjectMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectMember"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      userId: string
      role: string
      joinedAt: Date
    }, ExtArgs["result"]["projectMember"]>
    composites: {}
  }

  type ProjectMemberGetPayload<S extends boolean | null | undefined | ProjectMemberDefaultArgs> = $Result.GetResult<Prisma.$ProjectMemberPayload, S>

  type ProjectMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectMemberCountAggregateInputType | true
    }

  export interface ProjectMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectMember'], meta: { name: 'ProjectMember' } }
    /**
     * Find zero or one ProjectMember that matches the filter.
     * @param {ProjectMemberFindUniqueArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectMemberFindUniqueArgs>(args: SelectSubset<T, ProjectMemberFindUniqueArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectMemberFindUniqueOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectMemberFindFirstArgs>(args?: SelectSubset<T, ProjectMemberFindFirstArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany()
     * 
     * // Get first 10 ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectMemberFindManyArgs>(args?: SelectSubset<T, ProjectMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectMember.
     * @param {ProjectMemberCreateArgs} args - Arguments to create a ProjectMember.
     * @example
     * // Create one ProjectMember
     * const ProjectMember = await prisma.projectMember.create({
     *   data: {
     *     // ... data to create a ProjectMember
     *   }
     * })
     * 
     */
    create<T extends ProjectMemberCreateArgs>(args: SelectSubset<T, ProjectMemberCreateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectMembers.
     * @param {ProjectMemberCreateManyArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectMemberCreateManyArgs>(args?: SelectSubset<T, ProjectMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectMembers and returns the data saved in the database.
     * @param {ProjectMemberCreateManyAndReturnArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectMember.
     * @param {ProjectMemberDeleteArgs} args - Arguments to delete one ProjectMember.
     * @example
     * // Delete one ProjectMember
     * const ProjectMember = await prisma.projectMember.delete({
     *   where: {
     *     // ... filter to delete one ProjectMember
     *   }
     * })
     * 
     */
    delete<T extends ProjectMemberDeleteArgs>(args: SelectSubset<T, ProjectMemberDeleteArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectMember.
     * @param {ProjectMemberUpdateArgs} args - Arguments to update one ProjectMember.
     * @example
     * // Update one ProjectMember
     * const projectMember = await prisma.projectMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectMemberUpdateArgs>(args: SelectSubset<T, ProjectMemberUpdateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectMembers.
     * @param {ProjectMemberDeleteManyArgs} args - Arguments to filter ProjectMembers to delete.
     * @example
     * // Delete a few ProjectMembers
     * const { count } = await prisma.projectMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectMemberDeleteManyArgs>(args?: SelectSubset<T, ProjectMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectMemberUpdateManyArgs>(args: SelectSubset<T, ProjectMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers and returns the data updated in the database.
     * @param {ProjectMemberUpdateManyAndReturnArgs} args - Arguments to update many ProjectMembers.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectMember.
     * @param {ProjectMemberUpsertArgs} args - Arguments to update or create a ProjectMember.
     * @example
     * // Update or create a ProjectMember
     * const projectMember = await prisma.projectMember.upsert({
     *   create: {
     *     // ... data to create a ProjectMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMember we want to update
     *   }
     * })
     */
    upsert<T extends ProjectMemberUpsertArgs>(args: SelectSubset<T, ProjectMemberUpsertArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberCountArgs} args - Arguments to filter ProjectMembers to count.
     * @example
     * // Count the number of ProjectMembers
     * const count = await prisma.projectMember.count({
     *   where: {
     *     // ... the filter for the ProjectMembers we want to count
     *   }
     * })
    **/
    count<T extends ProjectMemberCountArgs>(
      args?: Subset<T, ProjectMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMemberAggregateArgs>(args: Subset<T, ProjectMemberAggregateArgs>): Prisma.PrismaPromise<GetProjectMemberAggregateType<T>>

    /**
     * Group by ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectMemberGroupByArgs['orderBy'] }
        : { orderBy?: ProjectMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectMember model
   */
  readonly fields: ProjectMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectMember model
   */
  interface ProjectMemberFieldRefs {
    readonly id: FieldRef<"ProjectMember", 'String'>
    readonly projectId: FieldRef<"ProjectMember", 'String'>
    readonly userId: FieldRef<"ProjectMember", 'String'>
    readonly role: FieldRef<"ProjectMember", 'String'>
    readonly joinedAt: FieldRef<"ProjectMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectMember findUnique
   */
  export type ProjectMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findUniqueOrThrow
   */
  export type ProjectMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findFirst
   */
  export type ProjectMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findFirstOrThrow
   */
  export type ProjectMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findMany
   */
  export type ProjectMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMembers to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember create
   */
  export type ProjectMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectMember.
     */
    data: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
  }

  /**
   * ProjectMember createMany
   */
  export type ProjectMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectMember createManyAndReturn
   */
  export type ProjectMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember update
   */
  export type ProjectMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectMember.
     */
    data: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
    /**
     * Choose, which ProjectMember to update.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember updateMany
   */
  export type ProjectMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to update.
     */
    limit?: number
  }

  /**
   * ProjectMember updateManyAndReturn
   */
  export type ProjectMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember upsert
   */
  export type ProjectMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectMember to update in case it exists.
     */
    where: ProjectMemberWhereUniqueInput
    /**
     * In case the ProjectMember found by the `where` argument doesn't exist, create a new ProjectMember with this data.
     */
    create: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
    /**
     * In case the ProjectMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
  }

  /**
   * ProjectMember delete
   */
  export type ProjectMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter which ProjectMember to delete.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember deleteMany
   */
  export type ProjectMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMembers to delete
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to delete.
     */
    limit?: number
  }

  /**
   * ProjectMember without action
   */
  export type ProjectMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
  }


  /**
   * Model ProjectUpdate
   */

  export type AggregateProjectUpdate = {
    _count: ProjectUpdateCountAggregateOutputType | null
    _min: ProjectUpdateMinAggregateOutputType | null
    _max: ProjectUpdateMaxAggregateOutputType | null
  }

  export type ProjectUpdateMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectUpdateMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectUpdateCountAggregateOutputType = {
    id: number
    projectId: number
    title: number
    content: number
    images: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectUpdateMinAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectUpdateMaxAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectUpdateCountAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    content?: true
    images?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectUpdateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectUpdate to aggregate.
     */
    where?: ProjectUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUpdates to fetch.
     */
    orderBy?: ProjectUpdateOrderByWithRelationInput | ProjectUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectUpdates
    **/
    _count?: true | ProjectUpdateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectUpdateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectUpdateMaxAggregateInputType
  }

  export type GetProjectUpdateAggregateType<T extends ProjectUpdateAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectUpdate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectUpdate[P]>
      : GetScalarType<T[P], AggregateProjectUpdate[P]>
  }




  export type ProjectUpdateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectUpdateWhereInput
    orderBy?: ProjectUpdateOrderByWithAggregationInput | ProjectUpdateOrderByWithAggregationInput[]
    by: ProjectUpdateScalarFieldEnum[] | ProjectUpdateScalarFieldEnum
    having?: ProjectUpdateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectUpdateCountAggregateInputType | true
    _min?: ProjectUpdateMinAggregateInputType
    _max?: ProjectUpdateMaxAggregateInputType
  }

  export type ProjectUpdateGroupByOutputType = {
    id: string
    projectId: string
    title: string
    content: string
    images: string[]
    createdAt: Date
    updatedAt: Date
    _count: ProjectUpdateCountAggregateOutputType | null
    _min: ProjectUpdateMinAggregateOutputType | null
    _max: ProjectUpdateMaxAggregateOutputType | null
  }

  type GetProjectUpdateGroupByPayload<T extends ProjectUpdateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectUpdateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectUpdateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectUpdateGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectUpdateGroupByOutputType[P]>
        }
      >
    >


  export type ProjectUpdateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    content?: boolean
    images?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | ProjectUpdate$UserArgs<ExtArgs>
    _count?: boolean | ProjectUpdateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectUpdate"]>

  export type ProjectUpdateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    content?: boolean
    images?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectUpdate"]>

  export type ProjectUpdateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    content?: boolean
    images?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectUpdate"]>

  export type ProjectUpdateSelectScalar = {
    id?: boolean
    projectId?: boolean
    title?: boolean
    content?: boolean
    images?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectUpdateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "title" | "content" | "images" | "createdAt" | "updatedAt", ExtArgs["result"]["projectUpdate"]>
  export type ProjectUpdateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | ProjectUpdate$UserArgs<ExtArgs>
    _count?: boolean | ProjectUpdateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectUpdateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectUpdateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectUpdatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectUpdate"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      title: string
      content: string
      images: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectUpdate"]>
    composites: {}
  }

  type ProjectUpdateGetPayload<S extends boolean | null | undefined | ProjectUpdateDefaultArgs> = $Result.GetResult<Prisma.$ProjectUpdatePayload, S>

  type ProjectUpdateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectUpdateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectUpdateCountAggregateInputType | true
    }

  export interface ProjectUpdateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectUpdate'], meta: { name: 'ProjectUpdate' } }
    /**
     * Find zero or one ProjectUpdate that matches the filter.
     * @param {ProjectUpdateFindUniqueArgs} args - Arguments to find a ProjectUpdate
     * @example
     * // Get one ProjectUpdate
     * const projectUpdate = await prisma.projectUpdate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectUpdateFindUniqueArgs>(args: SelectSubset<T, ProjectUpdateFindUniqueArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectUpdate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectUpdateFindUniqueOrThrowArgs} args - Arguments to find a ProjectUpdate
     * @example
     * // Get one ProjectUpdate
     * const projectUpdate = await prisma.projectUpdate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectUpdateFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectUpdateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectUpdate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateFindFirstArgs} args - Arguments to find a ProjectUpdate
     * @example
     * // Get one ProjectUpdate
     * const projectUpdate = await prisma.projectUpdate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectUpdateFindFirstArgs>(args?: SelectSubset<T, ProjectUpdateFindFirstArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectUpdate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateFindFirstOrThrowArgs} args - Arguments to find a ProjectUpdate
     * @example
     * // Get one ProjectUpdate
     * const projectUpdate = await prisma.projectUpdate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectUpdateFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectUpdateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectUpdates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectUpdates
     * const projectUpdates = await prisma.projectUpdate.findMany()
     * 
     * // Get first 10 ProjectUpdates
     * const projectUpdates = await prisma.projectUpdate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectUpdateWithIdOnly = await prisma.projectUpdate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectUpdateFindManyArgs>(args?: SelectSubset<T, ProjectUpdateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectUpdate.
     * @param {ProjectUpdateCreateArgs} args - Arguments to create a ProjectUpdate.
     * @example
     * // Create one ProjectUpdate
     * const ProjectUpdate = await prisma.projectUpdate.create({
     *   data: {
     *     // ... data to create a ProjectUpdate
     *   }
     * })
     * 
     */
    create<T extends ProjectUpdateCreateArgs>(args: SelectSubset<T, ProjectUpdateCreateArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectUpdates.
     * @param {ProjectUpdateCreateManyArgs} args - Arguments to create many ProjectUpdates.
     * @example
     * // Create many ProjectUpdates
     * const projectUpdate = await prisma.projectUpdate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectUpdateCreateManyArgs>(args?: SelectSubset<T, ProjectUpdateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectUpdates and returns the data saved in the database.
     * @param {ProjectUpdateCreateManyAndReturnArgs} args - Arguments to create many ProjectUpdates.
     * @example
     * // Create many ProjectUpdates
     * const projectUpdate = await prisma.projectUpdate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectUpdates and only return the `id`
     * const projectUpdateWithIdOnly = await prisma.projectUpdate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectUpdateCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectUpdateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectUpdate.
     * @param {ProjectUpdateDeleteArgs} args - Arguments to delete one ProjectUpdate.
     * @example
     * // Delete one ProjectUpdate
     * const ProjectUpdate = await prisma.projectUpdate.delete({
     *   where: {
     *     // ... filter to delete one ProjectUpdate
     *   }
     * })
     * 
     */
    delete<T extends ProjectUpdateDeleteArgs>(args: SelectSubset<T, ProjectUpdateDeleteArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectUpdate.
     * @param {ProjectUpdateUpdateArgs} args - Arguments to update one ProjectUpdate.
     * @example
     * // Update one ProjectUpdate
     * const projectUpdate = await prisma.projectUpdate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateUpdateArgs>(args: SelectSubset<T, ProjectUpdateUpdateArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectUpdates.
     * @param {ProjectUpdateDeleteManyArgs} args - Arguments to filter ProjectUpdates to delete.
     * @example
     * // Delete a few ProjectUpdates
     * const { count } = await prisma.projectUpdate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectUpdateDeleteManyArgs>(args?: SelectSubset<T, ProjectUpdateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectUpdates
     * const projectUpdate = await prisma.projectUpdate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectUpdates and returns the data updated in the database.
     * @param {ProjectUpdateUpdateManyAndReturnArgs} args - Arguments to update many ProjectUpdates.
     * @example
     * // Update many ProjectUpdates
     * const projectUpdate = await prisma.projectUpdate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectUpdates and only return the `id`
     * const projectUpdateWithIdOnly = await prisma.projectUpdate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectUpdate.
     * @param {ProjectUpdateUpsertArgs} args - Arguments to update or create a ProjectUpdate.
     * @example
     * // Update or create a ProjectUpdate
     * const projectUpdate = await prisma.projectUpdate.upsert({
     *   create: {
     *     // ... data to create a ProjectUpdate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectUpdate we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpdateUpsertArgs>(args: SelectSubset<T, ProjectUpdateUpsertArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateCountArgs} args - Arguments to filter ProjectUpdates to count.
     * @example
     * // Count the number of ProjectUpdates
     * const count = await prisma.projectUpdate.count({
     *   where: {
     *     // ... the filter for the ProjectUpdates we want to count
     *   }
     * })
    **/
    count<T extends ProjectUpdateCountArgs>(
      args?: Subset<T, ProjectUpdateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectUpdateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectUpdateAggregateArgs>(args: Subset<T, ProjectUpdateAggregateArgs>): Prisma.PrismaPromise<GetProjectUpdateAggregateType<T>>

    /**
     * Group by ProjectUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectUpdateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectUpdateGroupByArgs['orderBy'] }
        : { orderBy?: ProjectUpdateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectUpdateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectUpdateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectUpdate model
   */
  readonly fields: ProjectUpdateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectUpdate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectUpdateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends ProjectUpdate$UserArgs<ExtArgs> = {}>(args?: Subset<T, ProjectUpdate$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectUpdate model
   */
  interface ProjectUpdateFieldRefs {
    readonly id: FieldRef<"ProjectUpdate", 'String'>
    readonly projectId: FieldRef<"ProjectUpdate", 'String'>
    readonly title: FieldRef<"ProjectUpdate", 'String'>
    readonly content: FieldRef<"ProjectUpdate", 'String'>
    readonly images: FieldRef<"ProjectUpdate", 'String[]'>
    readonly createdAt: FieldRef<"ProjectUpdate", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectUpdate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectUpdate findUnique
   */
  export type ProjectUpdateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUpdate to fetch.
     */
    where: ProjectUpdateWhereUniqueInput
  }

  /**
   * ProjectUpdate findUniqueOrThrow
   */
  export type ProjectUpdateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUpdate to fetch.
     */
    where: ProjectUpdateWhereUniqueInput
  }

  /**
   * ProjectUpdate findFirst
   */
  export type ProjectUpdateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUpdate to fetch.
     */
    where?: ProjectUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUpdates to fetch.
     */
    orderBy?: ProjectUpdateOrderByWithRelationInput | ProjectUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectUpdates.
     */
    cursor?: ProjectUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectUpdates.
     */
    distinct?: ProjectUpdateScalarFieldEnum | ProjectUpdateScalarFieldEnum[]
  }

  /**
   * ProjectUpdate findFirstOrThrow
   */
  export type ProjectUpdateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUpdate to fetch.
     */
    where?: ProjectUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUpdates to fetch.
     */
    orderBy?: ProjectUpdateOrderByWithRelationInput | ProjectUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectUpdates.
     */
    cursor?: ProjectUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectUpdates.
     */
    distinct?: ProjectUpdateScalarFieldEnum | ProjectUpdateScalarFieldEnum[]
  }

  /**
   * ProjectUpdate findMany
   */
  export type ProjectUpdateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUpdates to fetch.
     */
    where?: ProjectUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUpdates to fetch.
     */
    orderBy?: ProjectUpdateOrderByWithRelationInput | ProjectUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectUpdates.
     */
    cursor?: ProjectUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUpdates.
     */
    skip?: number
    distinct?: ProjectUpdateScalarFieldEnum | ProjectUpdateScalarFieldEnum[]
  }

  /**
   * ProjectUpdate create
   */
  export type ProjectUpdateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectUpdate.
     */
    data: XOR<ProjectUpdateCreateInput, ProjectUpdateUncheckedCreateInput>
  }

  /**
   * ProjectUpdate createMany
   */
  export type ProjectUpdateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectUpdates.
     */
    data: ProjectUpdateCreateManyInput | ProjectUpdateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectUpdate createManyAndReturn
   */
  export type ProjectUpdateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectUpdates.
     */
    data: ProjectUpdateCreateManyInput | ProjectUpdateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectUpdate update
   */
  export type ProjectUpdateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectUpdate.
     */
    data: XOR<ProjectUpdateUpdateInput, ProjectUpdateUncheckedUpdateInput>
    /**
     * Choose, which ProjectUpdate to update.
     */
    where: ProjectUpdateWhereUniqueInput
  }

  /**
   * ProjectUpdate updateMany
   */
  export type ProjectUpdateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectUpdates.
     */
    data: XOR<ProjectUpdateUpdateManyMutationInput, ProjectUpdateUncheckedUpdateManyInput>
    /**
     * Filter which ProjectUpdates to update
     */
    where?: ProjectUpdateWhereInput
    /**
     * Limit how many ProjectUpdates to update.
     */
    limit?: number
  }

  /**
   * ProjectUpdate updateManyAndReturn
   */
  export type ProjectUpdateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * The data used to update ProjectUpdates.
     */
    data: XOR<ProjectUpdateUpdateManyMutationInput, ProjectUpdateUncheckedUpdateManyInput>
    /**
     * Filter which ProjectUpdates to update
     */
    where?: ProjectUpdateWhereInput
    /**
     * Limit how many ProjectUpdates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectUpdate upsert
   */
  export type ProjectUpdateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectUpdate to update in case it exists.
     */
    where: ProjectUpdateWhereUniqueInput
    /**
     * In case the ProjectUpdate found by the `where` argument doesn't exist, create a new ProjectUpdate with this data.
     */
    create: XOR<ProjectUpdateCreateInput, ProjectUpdateUncheckedCreateInput>
    /**
     * In case the ProjectUpdate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateUpdateInput, ProjectUpdateUncheckedUpdateInput>
  }

  /**
   * ProjectUpdate delete
   */
  export type ProjectUpdateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * Filter which ProjectUpdate to delete.
     */
    where: ProjectUpdateWhereUniqueInput
  }

  /**
   * ProjectUpdate deleteMany
   */
  export type ProjectUpdateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectUpdates to delete
     */
    where?: ProjectUpdateWhereInput
    /**
     * Limit how many ProjectUpdates to delete.
     */
    limit?: number
  }

  /**
   * ProjectUpdate.User
   */
  export type ProjectUpdate$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * ProjectUpdate without action
   */
  export type ProjectUpdateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
  }


  /**
   * Model ProjectReward
   */

  export type AggregateProjectReward = {
    _count: ProjectRewardCountAggregateOutputType | null
    _avg: ProjectRewardAvgAggregateOutputType | null
    _sum: ProjectRewardSumAggregateOutputType | null
    _min: ProjectRewardMinAggregateOutputType | null
    _max: ProjectRewardMaxAggregateOutputType | null
  }

  export type ProjectRewardAvgAggregateOutputType = {
    amount: number | null
    quantity: number | null
    claimed: number | null
  }

  export type ProjectRewardSumAggregateOutputType = {
    amount: number | null
    quantity: number | null
    claimed: number | null
  }

  export type ProjectRewardMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    amount: number | null
    title: string | null
    description: string | null
    image: string | null
    deliveryDate: Date | null
    quantity: number | null
    claimed: number | null
  }

  export type ProjectRewardMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    amount: number | null
    title: string | null
    description: string | null
    image: string | null
    deliveryDate: Date | null
    quantity: number | null
    claimed: number | null
  }

  export type ProjectRewardCountAggregateOutputType = {
    id: number
    projectId: number
    amount: number
    title: number
    description: number
    image: number
    deliveryDate: number
    quantity: number
    claimed: number
    _all: number
  }


  export type ProjectRewardAvgAggregateInputType = {
    amount?: true
    quantity?: true
    claimed?: true
  }

  export type ProjectRewardSumAggregateInputType = {
    amount?: true
    quantity?: true
    claimed?: true
  }

  export type ProjectRewardMinAggregateInputType = {
    id?: true
    projectId?: true
    amount?: true
    title?: true
    description?: true
    image?: true
    deliveryDate?: true
    quantity?: true
    claimed?: true
  }

  export type ProjectRewardMaxAggregateInputType = {
    id?: true
    projectId?: true
    amount?: true
    title?: true
    description?: true
    image?: true
    deliveryDate?: true
    quantity?: true
    claimed?: true
  }

  export type ProjectRewardCountAggregateInputType = {
    id?: true
    projectId?: true
    amount?: true
    title?: true
    description?: true
    image?: true
    deliveryDate?: true
    quantity?: true
    claimed?: true
    _all?: true
  }

  export type ProjectRewardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectReward to aggregate.
     */
    where?: ProjectRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectRewards to fetch.
     */
    orderBy?: ProjectRewardOrderByWithRelationInput | ProjectRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectRewards
    **/
    _count?: true | ProjectRewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectRewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectRewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectRewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectRewardMaxAggregateInputType
  }

  export type GetProjectRewardAggregateType<T extends ProjectRewardAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectReward[P]>
      : GetScalarType<T[P], AggregateProjectReward[P]>
  }




  export type ProjectRewardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectRewardWhereInput
    orderBy?: ProjectRewardOrderByWithAggregationInput | ProjectRewardOrderByWithAggregationInput[]
    by: ProjectRewardScalarFieldEnum[] | ProjectRewardScalarFieldEnum
    having?: ProjectRewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectRewardCountAggregateInputType | true
    _avg?: ProjectRewardAvgAggregateInputType
    _sum?: ProjectRewardSumAggregateInputType
    _min?: ProjectRewardMinAggregateInputType
    _max?: ProjectRewardMaxAggregateInputType
  }

  export type ProjectRewardGroupByOutputType = {
    id: string
    projectId: string
    amount: number
    title: string
    description: string
    image: string | null
    deliveryDate: Date | null
    quantity: number | null
    claimed: number
    _count: ProjectRewardCountAggregateOutputType | null
    _avg: ProjectRewardAvgAggregateOutputType | null
    _sum: ProjectRewardSumAggregateOutputType | null
    _min: ProjectRewardMinAggregateOutputType | null
    _max: ProjectRewardMaxAggregateOutputType | null
  }

  type GetProjectRewardGroupByPayload<T extends ProjectRewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectRewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectRewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectRewardGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectRewardGroupByOutputType[P]>
        }
      >
    >


  export type ProjectRewardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    amount?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    deliveryDate?: boolean
    quantity?: boolean
    claimed?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    ProjectDonation?: boolean | ProjectReward$ProjectDonationArgs<ExtArgs>
    User?: boolean | ProjectReward$UserArgs<ExtArgs>
    _count?: boolean | ProjectRewardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectReward"]>

  export type ProjectRewardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    amount?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    deliveryDate?: boolean
    quantity?: boolean
    claimed?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectReward"]>

  export type ProjectRewardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    amount?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    deliveryDate?: boolean
    quantity?: boolean
    claimed?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectReward"]>

  export type ProjectRewardSelectScalar = {
    id?: boolean
    projectId?: boolean
    amount?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    deliveryDate?: boolean
    quantity?: boolean
    claimed?: boolean
  }

  export type ProjectRewardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "amount" | "title" | "description" | "image" | "deliveryDate" | "quantity" | "claimed", ExtArgs["result"]["projectReward"]>
  export type ProjectRewardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    ProjectDonation?: boolean | ProjectReward$ProjectDonationArgs<ExtArgs>
    User?: boolean | ProjectReward$UserArgs<ExtArgs>
    _count?: boolean | ProjectRewardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectRewardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectRewardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectRewardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectReward"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      ProjectDonation: Prisma.$ProjectDonationPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      amount: number
      title: string
      description: string
      image: string | null
      deliveryDate: Date | null
      quantity: number | null
      claimed: number
    }, ExtArgs["result"]["projectReward"]>
    composites: {}
  }

  type ProjectRewardGetPayload<S extends boolean | null | undefined | ProjectRewardDefaultArgs> = $Result.GetResult<Prisma.$ProjectRewardPayload, S>

  type ProjectRewardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectRewardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectRewardCountAggregateInputType | true
    }

  export interface ProjectRewardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectReward'], meta: { name: 'ProjectReward' } }
    /**
     * Find zero or one ProjectReward that matches the filter.
     * @param {ProjectRewardFindUniqueArgs} args - Arguments to find a ProjectReward
     * @example
     * // Get one ProjectReward
     * const projectReward = await prisma.projectReward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectRewardFindUniqueArgs>(args: SelectSubset<T, ProjectRewardFindUniqueArgs<ExtArgs>>): Prisma__ProjectRewardClient<$Result.GetResult<Prisma.$ProjectRewardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectReward that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectRewardFindUniqueOrThrowArgs} args - Arguments to find a ProjectReward
     * @example
     * // Get one ProjectReward
     * const projectReward = await prisma.projectReward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectRewardFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectRewardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectRewardClient<$Result.GetResult<Prisma.$ProjectRewardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectReward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRewardFindFirstArgs} args - Arguments to find a ProjectReward
     * @example
     * // Get one ProjectReward
     * const projectReward = await prisma.projectReward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectRewardFindFirstArgs>(args?: SelectSubset<T, ProjectRewardFindFirstArgs<ExtArgs>>): Prisma__ProjectRewardClient<$Result.GetResult<Prisma.$ProjectRewardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectReward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRewardFindFirstOrThrowArgs} args - Arguments to find a ProjectReward
     * @example
     * // Get one ProjectReward
     * const projectReward = await prisma.projectReward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectRewardFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectRewardFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectRewardClient<$Result.GetResult<Prisma.$ProjectRewardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectRewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRewardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectRewards
     * const projectRewards = await prisma.projectReward.findMany()
     * 
     * // Get first 10 ProjectRewards
     * const projectRewards = await prisma.projectReward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectRewardWithIdOnly = await prisma.projectReward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectRewardFindManyArgs>(args?: SelectSubset<T, ProjectRewardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectReward.
     * @param {ProjectRewardCreateArgs} args - Arguments to create a ProjectReward.
     * @example
     * // Create one ProjectReward
     * const ProjectReward = await prisma.projectReward.create({
     *   data: {
     *     // ... data to create a ProjectReward
     *   }
     * })
     * 
     */
    create<T extends ProjectRewardCreateArgs>(args: SelectSubset<T, ProjectRewardCreateArgs<ExtArgs>>): Prisma__ProjectRewardClient<$Result.GetResult<Prisma.$ProjectRewardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectRewards.
     * @param {ProjectRewardCreateManyArgs} args - Arguments to create many ProjectRewards.
     * @example
     * // Create many ProjectRewards
     * const projectReward = await prisma.projectReward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectRewardCreateManyArgs>(args?: SelectSubset<T, ProjectRewardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectRewards and returns the data saved in the database.
     * @param {ProjectRewardCreateManyAndReturnArgs} args - Arguments to create many ProjectRewards.
     * @example
     * // Create many ProjectRewards
     * const projectReward = await prisma.projectReward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectRewards and only return the `id`
     * const projectRewardWithIdOnly = await prisma.projectReward.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectRewardCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectRewardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRewardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectReward.
     * @param {ProjectRewardDeleteArgs} args - Arguments to delete one ProjectReward.
     * @example
     * // Delete one ProjectReward
     * const ProjectReward = await prisma.projectReward.delete({
     *   where: {
     *     // ... filter to delete one ProjectReward
     *   }
     * })
     * 
     */
    delete<T extends ProjectRewardDeleteArgs>(args: SelectSubset<T, ProjectRewardDeleteArgs<ExtArgs>>): Prisma__ProjectRewardClient<$Result.GetResult<Prisma.$ProjectRewardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectReward.
     * @param {ProjectRewardUpdateArgs} args - Arguments to update one ProjectReward.
     * @example
     * // Update one ProjectReward
     * const projectReward = await prisma.projectReward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectRewardUpdateArgs>(args: SelectSubset<T, ProjectRewardUpdateArgs<ExtArgs>>): Prisma__ProjectRewardClient<$Result.GetResult<Prisma.$ProjectRewardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectRewards.
     * @param {ProjectRewardDeleteManyArgs} args - Arguments to filter ProjectRewards to delete.
     * @example
     * // Delete a few ProjectRewards
     * const { count } = await prisma.projectReward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectRewardDeleteManyArgs>(args?: SelectSubset<T, ProjectRewardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectRewards
     * const projectReward = await prisma.projectReward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectRewardUpdateManyArgs>(args: SelectSubset<T, ProjectRewardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectRewards and returns the data updated in the database.
     * @param {ProjectRewardUpdateManyAndReturnArgs} args - Arguments to update many ProjectRewards.
     * @example
     * // Update many ProjectRewards
     * const projectReward = await prisma.projectReward.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectRewards and only return the `id`
     * const projectRewardWithIdOnly = await prisma.projectReward.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectRewardUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectRewardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRewardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectReward.
     * @param {ProjectRewardUpsertArgs} args - Arguments to update or create a ProjectReward.
     * @example
     * // Update or create a ProjectReward
     * const projectReward = await prisma.projectReward.upsert({
     *   create: {
     *     // ... data to create a ProjectReward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectReward we want to update
     *   }
     * })
     */
    upsert<T extends ProjectRewardUpsertArgs>(args: SelectSubset<T, ProjectRewardUpsertArgs<ExtArgs>>): Prisma__ProjectRewardClient<$Result.GetResult<Prisma.$ProjectRewardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRewardCountArgs} args - Arguments to filter ProjectRewards to count.
     * @example
     * // Count the number of ProjectRewards
     * const count = await prisma.projectReward.count({
     *   where: {
     *     // ... the filter for the ProjectRewards we want to count
     *   }
     * })
    **/
    count<T extends ProjectRewardCountArgs>(
      args?: Subset<T, ProjectRewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectRewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectRewardAggregateArgs>(args: Subset<T, ProjectRewardAggregateArgs>): Prisma.PrismaPromise<GetProjectRewardAggregateType<T>>

    /**
     * Group by ProjectReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectRewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectRewardGroupByArgs['orderBy'] }
        : { orderBy?: ProjectRewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectRewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectReward model
   */
  readonly fields: ProjectRewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectReward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectRewardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ProjectDonation<T extends ProjectReward$ProjectDonationArgs<ExtArgs> = {}>(args?: Subset<T, ProjectReward$ProjectDonationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDonationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends ProjectReward$UserArgs<ExtArgs> = {}>(args?: Subset<T, ProjectReward$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectReward model
   */
  interface ProjectRewardFieldRefs {
    readonly id: FieldRef<"ProjectReward", 'String'>
    readonly projectId: FieldRef<"ProjectReward", 'String'>
    readonly amount: FieldRef<"ProjectReward", 'Float'>
    readonly title: FieldRef<"ProjectReward", 'String'>
    readonly description: FieldRef<"ProjectReward", 'String'>
    readonly image: FieldRef<"ProjectReward", 'String'>
    readonly deliveryDate: FieldRef<"ProjectReward", 'DateTime'>
    readonly quantity: FieldRef<"ProjectReward", 'Int'>
    readonly claimed: FieldRef<"ProjectReward", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProjectReward findUnique
   */
  export type ProjectRewardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectReward
     */
    select?: ProjectRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectReward
     */
    omit?: ProjectRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRewardInclude<ExtArgs> | null
    /**
     * Filter, which ProjectReward to fetch.
     */
    where: ProjectRewardWhereUniqueInput
  }

  /**
   * ProjectReward findUniqueOrThrow
   */
  export type ProjectRewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectReward
     */
    select?: ProjectRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectReward
     */
    omit?: ProjectRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRewardInclude<ExtArgs> | null
    /**
     * Filter, which ProjectReward to fetch.
     */
    where: ProjectRewardWhereUniqueInput
  }

  /**
   * ProjectReward findFirst
   */
  export type ProjectRewardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectReward
     */
    select?: ProjectRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectReward
     */
    omit?: ProjectRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRewardInclude<ExtArgs> | null
    /**
     * Filter, which ProjectReward to fetch.
     */
    where?: ProjectRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectRewards to fetch.
     */
    orderBy?: ProjectRewardOrderByWithRelationInput | ProjectRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectRewards.
     */
    cursor?: ProjectRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectRewards.
     */
    distinct?: ProjectRewardScalarFieldEnum | ProjectRewardScalarFieldEnum[]
  }

  /**
   * ProjectReward findFirstOrThrow
   */
  export type ProjectRewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectReward
     */
    select?: ProjectRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectReward
     */
    omit?: ProjectRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRewardInclude<ExtArgs> | null
    /**
     * Filter, which ProjectReward to fetch.
     */
    where?: ProjectRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectRewards to fetch.
     */
    orderBy?: ProjectRewardOrderByWithRelationInput | ProjectRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectRewards.
     */
    cursor?: ProjectRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectRewards.
     */
    distinct?: ProjectRewardScalarFieldEnum | ProjectRewardScalarFieldEnum[]
  }

  /**
   * ProjectReward findMany
   */
  export type ProjectRewardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectReward
     */
    select?: ProjectRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectReward
     */
    omit?: ProjectRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRewardInclude<ExtArgs> | null
    /**
     * Filter, which ProjectRewards to fetch.
     */
    where?: ProjectRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectRewards to fetch.
     */
    orderBy?: ProjectRewardOrderByWithRelationInput | ProjectRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectRewards.
     */
    cursor?: ProjectRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectRewards.
     */
    skip?: number
    distinct?: ProjectRewardScalarFieldEnum | ProjectRewardScalarFieldEnum[]
  }

  /**
   * ProjectReward create
   */
  export type ProjectRewardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectReward
     */
    select?: ProjectRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectReward
     */
    omit?: ProjectRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRewardInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectReward.
     */
    data: XOR<ProjectRewardCreateInput, ProjectRewardUncheckedCreateInput>
  }

  /**
   * ProjectReward createMany
   */
  export type ProjectRewardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectRewards.
     */
    data: ProjectRewardCreateManyInput | ProjectRewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectReward createManyAndReturn
   */
  export type ProjectRewardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectReward
     */
    select?: ProjectRewardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectReward
     */
    omit?: ProjectRewardOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectRewards.
     */
    data: ProjectRewardCreateManyInput | ProjectRewardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRewardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectReward update
   */
  export type ProjectRewardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectReward
     */
    select?: ProjectRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectReward
     */
    omit?: ProjectRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRewardInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectReward.
     */
    data: XOR<ProjectRewardUpdateInput, ProjectRewardUncheckedUpdateInput>
    /**
     * Choose, which ProjectReward to update.
     */
    where: ProjectRewardWhereUniqueInput
  }

  /**
   * ProjectReward updateMany
   */
  export type ProjectRewardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectRewards.
     */
    data: XOR<ProjectRewardUpdateManyMutationInput, ProjectRewardUncheckedUpdateManyInput>
    /**
     * Filter which ProjectRewards to update
     */
    where?: ProjectRewardWhereInput
    /**
     * Limit how many ProjectRewards to update.
     */
    limit?: number
  }

  /**
   * ProjectReward updateManyAndReturn
   */
  export type ProjectRewardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectReward
     */
    select?: ProjectRewardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectReward
     */
    omit?: ProjectRewardOmit<ExtArgs> | null
    /**
     * The data used to update ProjectRewards.
     */
    data: XOR<ProjectRewardUpdateManyMutationInput, ProjectRewardUncheckedUpdateManyInput>
    /**
     * Filter which ProjectRewards to update
     */
    where?: ProjectRewardWhereInput
    /**
     * Limit how many ProjectRewards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRewardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectReward upsert
   */
  export type ProjectRewardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectReward
     */
    select?: ProjectRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectReward
     */
    omit?: ProjectRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRewardInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectReward to update in case it exists.
     */
    where: ProjectRewardWhereUniqueInput
    /**
     * In case the ProjectReward found by the `where` argument doesn't exist, create a new ProjectReward with this data.
     */
    create: XOR<ProjectRewardCreateInput, ProjectRewardUncheckedCreateInput>
    /**
     * In case the ProjectReward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectRewardUpdateInput, ProjectRewardUncheckedUpdateInput>
  }

  /**
   * ProjectReward delete
   */
  export type ProjectRewardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectReward
     */
    select?: ProjectRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectReward
     */
    omit?: ProjectRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRewardInclude<ExtArgs> | null
    /**
     * Filter which ProjectReward to delete.
     */
    where: ProjectRewardWhereUniqueInput
  }

  /**
   * ProjectReward deleteMany
   */
  export type ProjectRewardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectRewards to delete
     */
    where?: ProjectRewardWhereInput
    /**
     * Limit how many ProjectRewards to delete.
     */
    limit?: number
  }

  /**
   * ProjectReward.ProjectDonation
   */
  export type ProjectReward$ProjectDonationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDonation
     */
    select?: ProjectDonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDonation
     */
    omit?: ProjectDonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDonationInclude<ExtArgs> | null
    where?: ProjectDonationWhereInput
    orderBy?: ProjectDonationOrderByWithRelationInput | ProjectDonationOrderByWithRelationInput[]
    cursor?: ProjectDonationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectDonationScalarFieldEnum | ProjectDonationScalarFieldEnum[]
  }

  /**
   * ProjectReward.User
   */
  export type ProjectReward$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * ProjectReward without action
   */
  export type ProjectRewardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectReward
     */
    select?: ProjectRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectReward
     */
    omit?: ProjectRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRewardInclude<ExtArgs> | null
  }


  /**
   * Model ProjectDonation
   */

  export type AggregateProjectDonation = {
    _count: ProjectDonationCountAggregateOutputType | null
    _avg: ProjectDonationAvgAggregateOutputType | null
    _sum: ProjectDonationSumAggregateOutputType | null
    _min: ProjectDonationMinAggregateOutputType | null
    _max: ProjectDonationMaxAggregateOutputType | null
  }

  export type ProjectDonationAvgAggregateOutputType = {
    amount: number | null
  }

  export type ProjectDonationSumAggregateOutputType = {
    amount: number | null
  }

  export type ProjectDonationMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    amount: number | null
    isAnonymous: boolean | null
    message: string | null
    rewardId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type ProjectDonationMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    amount: number | null
    isAnonymous: boolean | null
    message: string | null
    rewardId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type ProjectDonationCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    amount: number
    isAnonymous: number
    message: number
    rewardId: number
    status: number
    createdAt: number
    _all: number
  }


  export type ProjectDonationAvgAggregateInputType = {
    amount?: true
  }

  export type ProjectDonationSumAggregateInputType = {
    amount?: true
  }

  export type ProjectDonationMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    amount?: true
    isAnonymous?: true
    message?: true
    rewardId?: true
    status?: true
    createdAt?: true
  }

  export type ProjectDonationMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    amount?: true
    isAnonymous?: true
    message?: true
    rewardId?: true
    status?: true
    createdAt?: true
  }

  export type ProjectDonationCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    amount?: true
    isAnonymous?: true
    message?: true
    rewardId?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ProjectDonationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectDonation to aggregate.
     */
    where?: ProjectDonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDonations to fetch.
     */
    orderBy?: ProjectDonationOrderByWithRelationInput | ProjectDonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectDonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDonations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDonations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectDonations
    **/
    _count?: true | ProjectDonationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectDonationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectDonationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectDonationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectDonationMaxAggregateInputType
  }

  export type GetProjectDonationAggregateType<T extends ProjectDonationAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectDonation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectDonation[P]>
      : GetScalarType<T[P], AggregateProjectDonation[P]>
  }




  export type ProjectDonationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectDonationWhereInput
    orderBy?: ProjectDonationOrderByWithAggregationInput | ProjectDonationOrderByWithAggregationInput[]
    by: ProjectDonationScalarFieldEnum[] | ProjectDonationScalarFieldEnum
    having?: ProjectDonationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectDonationCountAggregateInputType | true
    _avg?: ProjectDonationAvgAggregateInputType
    _sum?: ProjectDonationSumAggregateInputType
    _min?: ProjectDonationMinAggregateInputType
    _max?: ProjectDonationMaxAggregateInputType
  }

  export type ProjectDonationGroupByOutputType = {
    id: string
    projectId: string
    userId: string
    amount: number
    isAnonymous: boolean
    message: string | null
    rewardId: string | null
    status: string
    createdAt: Date
    _count: ProjectDonationCountAggregateOutputType | null
    _avg: ProjectDonationAvgAggregateOutputType | null
    _sum: ProjectDonationSumAggregateOutputType | null
    _min: ProjectDonationMinAggregateOutputType | null
    _max: ProjectDonationMaxAggregateOutputType | null
  }

  type GetProjectDonationGroupByPayload<T extends ProjectDonationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectDonationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectDonationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectDonationGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectDonationGroupByOutputType[P]>
        }
      >
    >


  export type ProjectDonationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    amount?: boolean
    isAnonymous?: boolean
    message?: boolean
    rewardId?: boolean
    status?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    reward?: boolean | ProjectDonation$rewardArgs<ExtArgs>
  }, ExtArgs["result"]["projectDonation"]>

  export type ProjectDonationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    amount?: boolean
    isAnonymous?: boolean
    message?: boolean
    rewardId?: boolean
    status?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    reward?: boolean | ProjectDonation$rewardArgs<ExtArgs>
  }, ExtArgs["result"]["projectDonation"]>

  export type ProjectDonationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    amount?: boolean
    isAnonymous?: boolean
    message?: boolean
    rewardId?: boolean
    status?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    reward?: boolean | ProjectDonation$rewardArgs<ExtArgs>
  }, ExtArgs["result"]["projectDonation"]>

  export type ProjectDonationSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    amount?: boolean
    isAnonymous?: boolean
    message?: boolean
    rewardId?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type ProjectDonationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "userId" | "amount" | "isAnonymous" | "message" | "rewardId" | "status" | "createdAt", ExtArgs["result"]["projectDonation"]>
  export type ProjectDonationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    reward?: boolean | ProjectDonation$rewardArgs<ExtArgs>
  }
  export type ProjectDonationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    reward?: boolean | ProjectDonation$rewardArgs<ExtArgs>
  }
  export type ProjectDonationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    reward?: boolean | ProjectDonation$rewardArgs<ExtArgs>
  }

  export type $ProjectDonationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectDonation"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      reward: Prisma.$ProjectRewardPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      userId: string
      amount: number
      isAnonymous: boolean
      message: string | null
      rewardId: string | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["projectDonation"]>
    composites: {}
  }

  type ProjectDonationGetPayload<S extends boolean | null | undefined | ProjectDonationDefaultArgs> = $Result.GetResult<Prisma.$ProjectDonationPayload, S>

  type ProjectDonationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectDonationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectDonationCountAggregateInputType | true
    }

  export interface ProjectDonationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectDonation'], meta: { name: 'ProjectDonation' } }
    /**
     * Find zero or one ProjectDonation that matches the filter.
     * @param {ProjectDonationFindUniqueArgs} args - Arguments to find a ProjectDonation
     * @example
     * // Get one ProjectDonation
     * const projectDonation = await prisma.projectDonation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectDonationFindUniqueArgs>(args: SelectSubset<T, ProjectDonationFindUniqueArgs<ExtArgs>>): Prisma__ProjectDonationClient<$Result.GetResult<Prisma.$ProjectDonationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectDonation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectDonationFindUniqueOrThrowArgs} args - Arguments to find a ProjectDonation
     * @example
     * // Get one ProjectDonation
     * const projectDonation = await prisma.projectDonation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectDonationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectDonationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectDonationClient<$Result.GetResult<Prisma.$ProjectDonationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectDonation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDonationFindFirstArgs} args - Arguments to find a ProjectDonation
     * @example
     * // Get one ProjectDonation
     * const projectDonation = await prisma.projectDonation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectDonationFindFirstArgs>(args?: SelectSubset<T, ProjectDonationFindFirstArgs<ExtArgs>>): Prisma__ProjectDonationClient<$Result.GetResult<Prisma.$ProjectDonationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectDonation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDonationFindFirstOrThrowArgs} args - Arguments to find a ProjectDonation
     * @example
     * // Get one ProjectDonation
     * const projectDonation = await prisma.projectDonation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectDonationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectDonationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectDonationClient<$Result.GetResult<Prisma.$ProjectDonationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectDonations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDonationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectDonations
     * const projectDonations = await prisma.projectDonation.findMany()
     * 
     * // Get first 10 ProjectDonations
     * const projectDonations = await prisma.projectDonation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectDonationWithIdOnly = await prisma.projectDonation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectDonationFindManyArgs>(args?: SelectSubset<T, ProjectDonationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDonationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectDonation.
     * @param {ProjectDonationCreateArgs} args - Arguments to create a ProjectDonation.
     * @example
     * // Create one ProjectDonation
     * const ProjectDonation = await prisma.projectDonation.create({
     *   data: {
     *     // ... data to create a ProjectDonation
     *   }
     * })
     * 
     */
    create<T extends ProjectDonationCreateArgs>(args: SelectSubset<T, ProjectDonationCreateArgs<ExtArgs>>): Prisma__ProjectDonationClient<$Result.GetResult<Prisma.$ProjectDonationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectDonations.
     * @param {ProjectDonationCreateManyArgs} args - Arguments to create many ProjectDonations.
     * @example
     * // Create many ProjectDonations
     * const projectDonation = await prisma.projectDonation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectDonationCreateManyArgs>(args?: SelectSubset<T, ProjectDonationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectDonations and returns the data saved in the database.
     * @param {ProjectDonationCreateManyAndReturnArgs} args - Arguments to create many ProjectDonations.
     * @example
     * // Create many ProjectDonations
     * const projectDonation = await prisma.projectDonation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectDonations and only return the `id`
     * const projectDonationWithIdOnly = await prisma.projectDonation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectDonationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectDonationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDonationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectDonation.
     * @param {ProjectDonationDeleteArgs} args - Arguments to delete one ProjectDonation.
     * @example
     * // Delete one ProjectDonation
     * const ProjectDonation = await prisma.projectDonation.delete({
     *   where: {
     *     // ... filter to delete one ProjectDonation
     *   }
     * })
     * 
     */
    delete<T extends ProjectDonationDeleteArgs>(args: SelectSubset<T, ProjectDonationDeleteArgs<ExtArgs>>): Prisma__ProjectDonationClient<$Result.GetResult<Prisma.$ProjectDonationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectDonation.
     * @param {ProjectDonationUpdateArgs} args - Arguments to update one ProjectDonation.
     * @example
     * // Update one ProjectDonation
     * const projectDonation = await prisma.projectDonation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectDonationUpdateArgs>(args: SelectSubset<T, ProjectDonationUpdateArgs<ExtArgs>>): Prisma__ProjectDonationClient<$Result.GetResult<Prisma.$ProjectDonationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectDonations.
     * @param {ProjectDonationDeleteManyArgs} args - Arguments to filter ProjectDonations to delete.
     * @example
     * // Delete a few ProjectDonations
     * const { count } = await prisma.projectDonation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDonationDeleteManyArgs>(args?: SelectSubset<T, ProjectDonationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectDonations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDonationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectDonations
     * const projectDonation = await prisma.projectDonation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectDonationUpdateManyArgs>(args: SelectSubset<T, ProjectDonationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectDonations and returns the data updated in the database.
     * @param {ProjectDonationUpdateManyAndReturnArgs} args - Arguments to update many ProjectDonations.
     * @example
     * // Update many ProjectDonations
     * const projectDonation = await prisma.projectDonation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectDonations and only return the `id`
     * const projectDonationWithIdOnly = await prisma.projectDonation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectDonationUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectDonationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDonationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectDonation.
     * @param {ProjectDonationUpsertArgs} args - Arguments to update or create a ProjectDonation.
     * @example
     * // Update or create a ProjectDonation
     * const projectDonation = await prisma.projectDonation.upsert({
     *   create: {
     *     // ... data to create a ProjectDonation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectDonation we want to update
     *   }
     * })
     */
    upsert<T extends ProjectDonationUpsertArgs>(args: SelectSubset<T, ProjectDonationUpsertArgs<ExtArgs>>): Prisma__ProjectDonationClient<$Result.GetResult<Prisma.$ProjectDonationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectDonations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDonationCountArgs} args - Arguments to filter ProjectDonations to count.
     * @example
     * // Count the number of ProjectDonations
     * const count = await prisma.projectDonation.count({
     *   where: {
     *     // ... the filter for the ProjectDonations we want to count
     *   }
     * })
    **/
    count<T extends ProjectDonationCountArgs>(
      args?: Subset<T, ProjectDonationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectDonationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectDonation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDonationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectDonationAggregateArgs>(args: Subset<T, ProjectDonationAggregateArgs>): Prisma.PrismaPromise<GetProjectDonationAggregateType<T>>

    /**
     * Group by ProjectDonation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDonationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectDonationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectDonationGroupByArgs['orderBy'] }
        : { orderBy?: ProjectDonationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectDonationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectDonationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectDonation model
   */
  readonly fields: ProjectDonationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectDonation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectDonationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reward<T extends ProjectDonation$rewardArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDonation$rewardArgs<ExtArgs>>): Prisma__ProjectRewardClient<$Result.GetResult<Prisma.$ProjectRewardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectDonation model
   */
  interface ProjectDonationFieldRefs {
    readonly id: FieldRef<"ProjectDonation", 'String'>
    readonly projectId: FieldRef<"ProjectDonation", 'String'>
    readonly userId: FieldRef<"ProjectDonation", 'String'>
    readonly amount: FieldRef<"ProjectDonation", 'Float'>
    readonly isAnonymous: FieldRef<"ProjectDonation", 'Boolean'>
    readonly message: FieldRef<"ProjectDonation", 'String'>
    readonly rewardId: FieldRef<"ProjectDonation", 'String'>
    readonly status: FieldRef<"ProjectDonation", 'String'>
    readonly createdAt: FieldRef<"ProjectDonation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectDonation findUnique
   */
  export type ProjectDonationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDonation
     */
    select?: ProjectDonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDonation
     */
    omit?: ProjectDonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDonationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDonation to fetch.
     */
    where: ProjectDonationWhereUniqueInput
  }

  /**
   * ProjectDonation findUniqueOrThrow
   */
  export type ProjectDonationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDonation
     */
    select?: ProjectDonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDonation
     */
    omit?: ProjectDonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDonationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDonation to fetch.
     */
    where: ProjectDonationWhereUniqueInput
  }

  /**
   * ProjectDonation findFirst
   */
  export type ProjectDonationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDonation
     */
    select?: ProjectDonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDonation
     */
    omit?: ProjectDonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDonationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDonation to fetch.
     */
    where?: ProjectDonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDonations to fetch.
     */
    orderBy?: ProjectDonationOrderByWithRelationInput | ProjectDonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectDonations.
     */
    cursor?: ProjectDonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDonations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDonations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectDonations.
     */
    distinct?: ProjectDonationScalarFieldEnum | ProjectDonationScalarFieldEnum[]
  }

  /**
   * ProjectDonation findFirstOrThrow
   */
  export type ProjectDonationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDonation
     */
    select?: ProjectDonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDonation
     */
    omit?: ProjectDonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDonationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDonation to fetch.
     */
    where?: ProjectDonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDonations to fetch.
     */
    orderBy?: ProjectDonationOrderByWithRelationInput | ProjectDonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectDonations.
     */
    cursor?: ProjectDonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDonations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDonations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectDonations.
     */
    distinct?: ProjectDonationScalarFieldEnum | ProjectDonationScalarFieldEnum[]
  }

  /**
   * ProjectDonation findMany
   */
  export type ProjectDonationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDonation
     */
    select?: ProjectDonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDonation
     */
    omit?: ProjectDonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDonationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDonations to fetch.
     */
    where?: ProjectDonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDonations to fetch.
     */
    orderBy?: ProjectDonationOrderByWithRelationInput | ProjectDonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectDonations.
     */
    cursor?: ProjectDonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDonations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDonations.
     */
    skip?: number
    distinct?: ProjectDonationScalarFieldEnum | ProjectDonationScalarFieldEnum[]
  }

  /**
   * ProjectDonation create
   */
  export type ProjectDonationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDonation
     */
    select?: ProjectDonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDonation
     */
    omit?: ProjectDonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDonationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectDonation.
     */
    data: XOR<ProjectDonationCreateInput, ProjectDonationUncheckedCreateInput>
  }

  /**
   * ProjectDonation createMany
   */
  export type ProjectDonationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectDonations.
     */
    data: ProjectDonationCreateManyInput | ProjectDonationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectDonation createManyAndReturn
   */
  export type ProjectDonationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDonation
     */
    select?: ProjectDonationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDonation
     */
    omit?: ProjectDonationOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectDonations.
     */
    data: ProjectDonationCreateManyInput | ProjectDonationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDonationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectDonation update
   */
  export type ProjectDonationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDonation
     */
    select?: ProjectDonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDonation
     */
    omit?: ProjectDonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDonationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectDonation.
     */
    data: XOR<ProjectDonationUpdateInput, ProjectDonationUncheckedUpdateInput>
    /**
     * Choose, which ProjectDonation to update.
     */
    where: ProjectDonationWhereUniqueInput
  }

  /**
   * ProjectDonation updateMany
   */
  export type ProjectDonationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectDonations.
     */
    data: XOR<ProjectDonationUpdateManyMutationInput, ProjectDonationUncheckedUpdateManyInput>
    /**
     * Filter which ProjectDonations to update
     */
    where?: ProjectDonationWhereInput
    /**
     * Limit how many ProjectDonations to update.
     */
    limit?: number
  }

  /**
   * ProjectDonation updateManyAndReturn
   */
  export type ProjectDonationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDonation
     */
    select?: ProjectDonationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDonation
     */
    omit?: ProjectDonationOmit<ExtArgs> | null
    /**
     * The data used to update ProjectDonations.
     */
    data: XOR<ProjectDonationUpdateManyMutationInput, ProjectDonationUncheckedUpdateManyInput>
    /**
     * Filter which ProjectDonations to update
     */
    where?: ProjectDonationWhereInput
    /**
     * Limit how many ProjectDonations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDonationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectDonation upsert
   */
  export type ProjectDonationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDonation
     */
    select?: ProjectDonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDonation
     */
    omit?: ProjectDonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDonationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectDonation to update in case it exists.
     */
    where: ProjectDonationWhereUniqueInput
    /**
     * In case the ProjectDonation found by the `where` argument doesn't exist, create a new ProjectDonation with this data.
     */
    create: XOR<ProjectDonationCreateInput, ProjectDonationUncheckedCreateInput>
    /**
     * In case the ProjectDonation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectDonationUpdateInput, ProjectDonationUncheckedUpdateInput>
  }

  /**
   * ProjectDonation delete
   */
  export type ProjectDonationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDonation
     */
    select?: ProjectDonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDonation
     */
    omit?: ProjectDonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDonationInclude<ExtArgs> | null
    /**
     * Filter which ProjectDonation to delete.
     */
    where: ProjectDonationWhereUniqueInput
  }

  /**
   * ProjectDonation deleteMany
   */
  export type ProjectDonationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectDonations to delete
     */
    where?: ProjectDonationWhereInput
    /**
     * Limit how many ProjectDonations to delete.
     */
    limit?: number
  }

  /**
   * ProjectDonation.reward
   */
  export type ProjectDonation$rewardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectReward
     */
    select?: ProjectRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectReward
     */
    omit?: ProjectRewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRewardInclude<ExtArgs> | null
    where?: ProjectRewardWhereInput
  }

  /**
   * ProjectDonation without action
   */
  export type ProjectDonationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDonation
     */
    select?: ProjectDonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDonation
     */
    omit?: ProjectDonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDonationInclude<ExtArgs> | null
  }


  /**
   * Model ProjectInvestment
   */

  export type AggregateProjectInvestment = {
    _count: ProjectInvestmentCountAggregateOutputType | null
    _avg: ProjectInvestmentAvgAggregateOutputType | null
    _sum: ProjectInvestmentSumAggregateOutputType | null
    _min: ProjectInvestmentMinAggregateOutputType | null
    _max: ProjectInvestmentMaxAggregateOutputType | null
  }

  export type ProjectInvestmentAvgAggregateOutputType = {
    amount: number | null
    shares: number | null
  }

  export type ProjectInvestmentSumAggregateOutputType = {
    amount: number | null
    shares: number | null
  }

  export type ProjectInvestmentMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    amount: number | null
    shares: number | null
    status: string | null
    createdAt: Date | null
  }

  export type ProjectInvestmentMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    amount: number | null
    shares: number | null
    status: string | null
    createdAt: Date | null
  }

  export type ProjectInvestmentCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    amount: number
    shares: number
    status: number
    createdAt: number
    _all: number
  }


  export type ProjectInvestmentAvgAggregateInputType = {
    amount?: true
    shares?: true
  }

  export type ProjectInvestmentSumAggregateInputType = {
    amount?: true
    shares?: true
  }

  export type ProjectInvestmentMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    amount?: true
    shares?: true
    status?: true
    createdAt?: true
  }

  export type ProjectInvestmentMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    amount?: true
    shares?: true
    status?: true
    createdAt?: true
  }

  export type ProjectInvestmentCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    amount?: true
    shares?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ProjectInvestmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectInvestment to aggregate.
     */
    where?: ProjectInvestmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectInvestments to fetch.
     */
    orderBy?: ProjectInvestmentOrderByWithRelationInput | ProjectInvestmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectInvestmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectInvestments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectInvestments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectInvestments
    **/
    _count?: true | ProjectInvestmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectInvestmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectInvestmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectInvestmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectInvestmentMaxAggregateInputType
  }

  export type GetProjectInvestmentAggregateType<T extends ProjectInvestmentAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectInvestment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectInvestment[P]>
      : GetScalarType<T[P], AggregateProjectInvestment[P]>
  }




  export type ProjectInvestmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectInvestmentWhereInput
    orderBy?: ProjectInvestmentOrderByWithAggregationInput | ProjectInvestmentOrderByWithAggregationInput[]
    by: ProjectInvestmentScalarFieldEnum[] | ProjectInvestmentScalarFieldEnum
    having?: ProjectInvestmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectInvestmentCountAggregateInputType | true
    _avg?: ProjectInvestmentAvgAggregateInputType
    _sum?: ProjectInvestmentSumAggregateInputType
    _min?: ProjectInvestmentMinAggregateInputType
    _max?: ProjectInvestmentMaxAggregateInputType
  }

  export type ProjectInvestmentGroupByOutputType = {
    id: string
    projectId: string
    userId: string
    amount: number
    shares: number | null
    status: string
    createdAt: Date
    _count: ProjectInvestmentCountAggregateOutputType | null
    _avg: ProjectInvestmentAvgAggregateOutputType | null
    _sum: ProjectInvestmentSumAggregateOutputType | null
    _min: ProjectInvestmentMinAggregateOutputType | null
    _max: ProjectInvestmentMaxAggregateOutputType | null
  }

  type GetProjectInvestmentGroupByPayload<T extends ProjectInvestmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectInvestmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectInvestmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectInvestmentGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectInvestmentGroupByOutputType[P]>
        }
      >
    >


  export type ProjectInvestmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    amount?: boolean
    shares?: boolean
    status?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectInvestment"]>

  export type ProjectInvestmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    amount?: boolean
    shares?: boolean
    status?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectInvestment"]>

  export type ProjectInvestmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    amount?: boolean
    shares?: boolean
    status?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectInvestment"]>

  export type ProjectInvestmentSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    amount?: boolean
    shares?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type ProjectInvestmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "userId" | "amount" | "shares" | "status" | "createdAt", ExtArgs["result"]["projectInvestment"]>
  export type ProjectInvestmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectInvestmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectInvestmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectInvestmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectInvestment"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      userId: string
      amount: number
      shares: number | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["projectInvestment"]>
    composites: {}
  }

  type ProjectInvestmentGetPayload<S extends boolean | null | undefined | ProjectInvestmentDefaultArgs> = $Result.GetResult<Prisma.$ProjectInvestmentPayload, S>

  type ProjectInvestmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectInvestmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectInvestmentCountAggregateInputType | true
    }

  export interface ProjectInvestmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectInvestment'], meta: { name: 'ProjectInvestment' } }
    /**
     * Find zero or one ProjectInvestment that matches the filter.
     * @param {ProjectInvestmentFindUniqueArgs} args - Arguments to find a ProjectInvestment
     * @example
     * // Get one ProjectInvestment
     * const projectInvestment = await prisma.projectInvestment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectInvestmentFindUniqueArgs>(args: SelectSubset<T, ProjectInvestmentFindUniqueArgs<ExtArgs>>): Prisma__ProjectInvestmentClient<$Result.GetResult<Prisma.$ProjectInvestmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectInvestment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectInvestmentFindUniqueOrThrowArgs} args - Arguments to find a ProjectInvestment
     * @example
     * // Get one ProjectInvestment
     * const projectInvestment = await prisma.projectInvestment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectInvestmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectInvestmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectInvestmentClient<$Result.GetResult<Prisma.$ProjectInvestmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectInvestment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInvestmentFindFirstArgs} args - Arguments to find a ProjectInvestment
     * @example
     * // Get one ProjectInvestment
     * const projectInvestment = await prisma.projectInvestment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectInvestmentFindFirstArgs>(args?: SelectSubset<T, ProjectInvestmentFindFirstArgs<ExtArgs>>): Prisma__ProjectInvestmentClient<$Result.GetResult<Prisma.$ProjectInvestmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectInvestment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInvestmentFindFirstOrThrowArgs} args - Arguments to find a ProjectInvestment
     * @example
     * // Get one ProjectInvestment
     * const projectInvestment = await prisma.projectInvestment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectInvestmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectInvestmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectInvestmentClient<$Result.GetResult<Prisma.$ProjectInvestmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectInvestments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInvestmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectInvestments
     * const projectInvestments = await prisma.projectInvestment.findMany()
     * 
     * // Get first 10 ProjectInvestments
     * const projectInvestments = await prisma.projectInvestment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectInvestmentWithIdOnly = await prisma.projectInvestment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectInvestmentFindManyArgs>(args?: SelectSubset<T, ProjectInvestmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectInvestmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectInvestment.
     * @param {ProjectInvestmentCreateArgs} args - Arguments to create a ProjectInvestment.
     * @example
     * // Create one ProjectInvestment
     * const ProjectInvestment = await prisma.projectInvestment.create({
     *   data: {
     *     // ... data to create a ProjectInvestment
     *   }
     * })
     * 
     */
    create<T extends ProjectInvestmentCreateArgs>(args: SelectSubset<T, ProjectInvestmentCreateArgs<ExtArgs>>): Prisma__ProjectInvestmentClient<$Result.GetResult<Prisma.$ProjectInvestmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectInvestments.
     * @param {ProjectInvestmentCreateManyArgs} args - Arguments to create many ProjectInvestments.
     * @example
     * // Create many ProjectInvestments
     * const projectInvestment = await prisma.projectInvestment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectInvestmentCreateManyArgs>(args?: SelectSubset<T, ProjectInvestmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectInvestments and returns the data saved in the database.
     * @param {ProjectInvestmentCreateManyAndReturnArgs} args - Arguments to create many ProjectInvestments.
     * @example
     * // Create many ProjectInvestments
     * const projectInvestment = await prisma.projectInvestment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectInvestments and only return the `id`
     * const projectInvestmentWithIdOnly = await prisma.projectInvestment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectInvestmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectInvestmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectInvestmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectInvestment.
     * @param {ProjectInvestmentDeleteArgs} args - Arguments to delete one ProjectInvestment.
     * @example
     * // Delete one ProjectInvestment
     * const ProjectInvestment = await prisma.projectInvestment.delete({
     *   where: {
     *     // ... filter to delete one ProjectInvestment
     *   }
     * })
     * 
     */
    delete<T extends ProjectInvestmentDeleteArgs>(args: SelectSubset<T, ProjectInvestmentDeleteArgs<ExtArgs>>): Prisma__ProjectInvestmentClient<$Result.GetResult<Prisma.$ProjectInvestmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectInvestment.
     * @param {ProjectInvestmentUpdateArgs} args - Arguments to update one ProjectInvestment.
     * @example
     * // Update one ProjectInvestment
     * const projectInvestment = await prisma.projectInvestment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectInvestmentUpdateArgs>(args: SelectSubset<T, ProjectInvestmentUpdateArgs<ExtArgs>>): Prisma__ProjectInvestmentClient<$Result.GetResult<Prisma.$ProjectInvestmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectInvestments.
     * @param {ProjectInvestmentDeleteManyArgs} args - Arguments to filter ProjectInvestments to delete.
     * @example
     * // Delete a few ProjectInvestments
     * const { count } = await prisma.projectInvestment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectInvestmentDeleteManyArgs>(args?: SelectSubset<T, ProjectInvestmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectInvestments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInvestmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectInvestments
     * const projectInvestment = await prisma.projectInvestment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectInvestmentUpdateManyArgs>(args: SelectSubset<T, ProjectInvestmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectInvestments and returns the data updated in the database.
     * @param {ProjectInvestmentUpdateManyAndReturnArgs} args - Arguments to update many ProjectInvestments.
     * @example
     * // Update many ProjectInvestments
     * const projectInvestment = await prisma.projectInvestment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectInvestments and only return the `id`
     * const projectInvestmentWithIdOnly = await prisma.projectInvestment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectInvestmentUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectInvestmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectInvestmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectInvestment.
     * @param {ProjectInvestmentUpsertArgs} args - Arguments to update or create a ProjectInvestment.
     * @example
     * // Update or create a ProjectInvestment
     * const projectInvestment = await prisma.projectInvestment.upsert({
     *   create: {
     *     // ... data to create a ProjectInvestment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectInvestment we want to update
     *   }
     * })
     */
    upsert<T extends ProjectInvestmentUpsertArgs>(args: SelectSubset<T, ProjectInvestmentUpsertArgs<ExtArgs>>): Prisma__ProjectInvestmentClient<$Result.GetResult<Prisma.$ProjectInvestmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectInvestments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInvestmentCountArgs} args - Arguments to filter ProjectInvestments to count.
     * @example
     * // Count the number of ProjectInvestments
     * const count = await prisma.projectInvestment.count({
     *   where: {
     *     // ... the filter for the ProjectInvestments we want to count
     *   }
     * })
    **/
    count<T extends ProjectInvestmentCountArgs>(
      args?: Subset<T, ProjectInvestmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectInvestmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectInvestment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInvestmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectInvestmentAggregateArgs>(args: Subset<T, ProjectInvestmentAggregateArgs>): Prisma.PrismaPromise<GetProjectInvestmentAggregateType<T>>

    /**
     * Group by ProjectInvestment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectInvestmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectInvestmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectInvestmentGroupByArgs['orderBy'] }
        : { orderBy?: ProjectInvestmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectInvestmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectInvestmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectInvestment model
   */
  readonly fields: ProjectInvestmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectInvestment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectInvestmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectInvestment model
   */
  interface ProjectInvestmentFieldRefs {
    readonly id: FieldRef<"ProjectInvestment", 'String'>
    readonly projectId: FieldRef<"ProjectInvestment", 'String'>
    readonly userId: FieldRef<"ProjectInvestment", 'String'>
    readonly amount: FieldRef<"ProjectInvestment", 'Float'>
    readonly shares: FieldRef<"ProjectInvestment", 'Float'>
    readonly status: FieldRef<"ProjectInvestment", 'String'>
    readonly createdAt: FieldRef<"ProjectInvestment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectInvestment findUnique
   */
  export type ProjectInvestmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvestment
     */
    select?: ProjectInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvestment
     */
    omit?: ProjectInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvestmentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectInvestment to fetch.
     */
    where: ProjectInvestmentWhereUniqueInput
  }

  /**
   * ProjectInvestment findUniqueOrThrow
   */
  export type ProjectInvestmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvestment
     */
    select?: ProjectInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvestment
     */
    omit?: ProjectInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvestmentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectInvestment to fetch.
     */
    where: ProjectInvestmentWhereUniqueInput
  }

  /**
   * ProjectInvestment findFirst
   */
  export type ProjectInvestmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvestment
     */
    select?: ProjectInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvestment
     */
    omit?: ProjectInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvestmentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectInvestment to fetch.
     */
    where?: ProjectInvestmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectInvestments to fetch.
     */
    orderBy?: ProjectInvestmentOrderByWithRelationInput | ProjectInvestmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectInvestments.
     */
    cursor?: ProjectInvestmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectInvestments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectInvestments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectInvestments.
     */
    distinct?: ProjectInvestmentScalarFieldEnum | ProjectInvestmentScalarFieldEnum[]
  }

  /**
   * ProjectInvestment findFirstOrThrow
   */
  export type ProjectInvestmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvestment
     */
    select?: ProjectInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvestment
     */
    omit?: ProjectInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvestmentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectInvestment to fetch.
     */
    where?: ProjectInvestmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectInvestments to fetch.
     */
    orderBy?: ProjectInvestmentOrderByWithRelationInput | ProjectInvestmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectInvestments.
     */
    cursor?: ProjectInvestmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectInvestments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectInvestments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectInvestments.
     */
    distinct?: ProjectInvestmentScalarFieldEnum | ProjectInvestmentScalarFieldEnum[]
  }

  /**
   * ProjectInvestment findMany
   */
  export type ProjectInvestmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvestment
     */
    select?: ProjectInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvestment
     */
    omit?: ProjectInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvestmentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectInvestments to fetch.
     */
    where?: ProjectInvestmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectInvestments to fetch.
     */
    orderBy?: ProjectInvestmentOrderByWithRelationInput | ProjectInvestmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectInvestments.
     */
    cursor?: ProjectInvestmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectInvestments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectInvestments.
     */
    skip?: number
    distinct?: ProjectInvestmentScalarFieldEnum | ProjectInvestmentScalarFieldEnum[]
  }

  /**
   * ProjectInvestment create
   */
  export type ProjectInvestmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvestment
     */
    select?: ProjectInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvestment
     */
    omit?: ProjectInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvestmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectInvestment.
     */
    data: XOR<ProjectInvestmentCreateInput, ProjectInvestmentUncheckedCreateInput>
  }

  /**
   * ProjectInvestment createMany
   */
  export type ProjectInvestmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectInvestments.
     */
    data: ProjectInvestmentCreateManyInput | ProjectInvestmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectInvestment createManyAndReturn
   */
  export type ProjectInvestmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvestment
     */
    select?: ProjectInvestmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvestment
     */
    omit?: ProjectInvestmentOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectInvestments.
     */
    data: ProjectInvestmentCreateManyInput | ProjectInvestmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvestmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectInvestment update
   */
  export type ProjectInvestmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvestment
     */
    select?: ProjectInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvestment
     */
    omit?: ProjectInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvestmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectInvestment.
     */
    data: XOR<ProjectInvestmentUpdateInput, ProjectInvestmentUncheckedUpdateInput>
    /**
     * Choose, which ProjectInvestment to update.
     */
    where: ProjectInvestmentWhereUniqueInput
  }

  /**
   * ProjectInvestment updateMany
   */
  export type ProjectInvestmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectInvestments.
     */
    data: XOR<ProjectInvestmentUpdateManyMutationInput, ProjectInvestmentUncheckedUpdateManyInput>
    /**
     * Filter which ProjectInvestments to update
     */
    where?: ProjectInvestmentWhereInput
    /**
     * Limit how many ProjectInvestments to update.
     */
    limit?: number
  }

  /**
   * ProjectInvestment updateManyAndReturn
   */
  export type ProjectInvestmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvestment
     */
    select?: ProjectInvestmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvestment
     */
    omit?: ProjectInvestmentOmit<ExtArgs> | null
    /**
     * The data used to update ProjectInvestments.
     */
    data: XOR<ProjectInvestmentUpdateManyMutationInput, ProjectInvestmentUncheckedUpdateManyInput>
    /**
     * Filter which ProjectInvestments to update
     */
    where?: ProjectInvestmentWhereInput
    /**
     * Limit how many ProjectInvestments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvestmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectInvestment upsert
   */
  export type ProjectInvestmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvestment
     */
    select?: ProjectInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvestment
     */
    omit?: ProjectInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvestmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectInvestment to update in case it exists.
     */
    where: ProjectInvestmentWhereUniqueInput
    /**
     * In case the ProjectInvestment found by the `where` argument doesn't exist, create a new ProjectInvestment with this data.
     */
    create: XOR<ProjectInvestmentCreateInput, ProjectInvestmentUncheckedCreateInput>
    /**
     * In case the ProjectInvestment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectInvestmentUpdateInput, ProjectInvestmentUncheckedUpdateInput>
  }

  /**
   * ProjectInvestment delete
   */
  export type ProjectInvestmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvestment
     */
    select?: ProjectInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvestment
     */
    omit?: ProjectInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvestmentInclude<ExtArgs> | null
    /**
     * Filter which ProjectInvestment to delete.
     */
    where: ProjectInvestmentWhereUniqueInput
  }

  /**
   * ProjectInvestment deleteMany
   */
  export type ProjectInvestmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectInvestments to delete
     */
    where?: ProjectInvestmentWhereInput
    /**
     * Limit how many ProjectInvestments to delete.
     */
    limit?: number
  }

  /**
   * ProjectInvestment without action
   */
  export type ProjectInvestmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectInvestment
     */
    select?: ProjectInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectInvestment
     */
    omit?: ProjectInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInvestmentInclude<ExtArgs> | null
  }


  /**
   * Model ProjectLoan
   */

  export type AggregateProjectLoan = {
    _count: ProjectLoanCountAggregateOutputType | null
    _avg: ProjectLoanAvgAggregateOutputType | null
    _sum: ProjectLoanSumAggregateOutputType | null
    _min: ProjectLoanMinAggregateOutputType | null
    _max: ProjectLoanMaxAggregateOutputType | null
  }

  export type ProjectLoanAvgAggregateOutputType = {
    amount: number | null
  }

  export type ProjectLoanSumAggregateOutputType = {
    amount: number | null
  }

  export type ProjectLoanMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    amount: number | null
    status: string | null
    createdAt: Date | null
  }

  export type ProjectLoanMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    amount: number | null
    status: string | null
    createdAt: Date | null
  }

  export type ProjectLoanCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    amount: number
    status: number
    createdAt: number
    _all: number
  }


  export type ProjectLoanAvgAggregateInputType = {
    amount?: true
  }

  export type ProjectLoanSumAggregateInputType = {
    amount?: true
  }

  export type ProjectLoanMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    amount?: true
    status?: true
    createdAt?: true
  }

  export type ProjectLoanMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    amount?: true
    status?: true
    createdAt?: true
  }

  export type ProjectLoanCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    amount?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ProjectLoanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectLoan to aggregate.
     */
    where?: ProjectLoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectLoans to fetch.
     */
    orderBy?: ProjectLoanOrderByWithRelationInput | ProjectLoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectLoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectLoans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectLoans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectLoans
    **/
    _count?: true | ProjectLoanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectLoanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectLoanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectLoanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectLoanMaxAggregateInputType
  }

  export type GetProjectLoanAggregateType<T extends ProjectLoanAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectLoan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectLoan[P]>
      : GetScalarType<T[P], AggregateProjectLoan[P]>
  }




  export type ProjectLoanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectLoanWhereInput
    orderBy?: ProjectLoanOrderByWithAggregationInput | ProjectLoanOrderByWithAggregationInput[]
    by: ProjectLoanScalarFieldEnum[] | ProjectLoanScalarFieldEnum
    having?: ProjectLoanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectLoanCountAggregateInputType | true
    _avg?: ProjectLoanAvgAggregateInputType
    _sum?: ProjectLoanSumAggregateInputType
    _min?: ProjectLoanMinAggregateInputType
    _max?: ProjectLoanMaxAggregateInputType
  }

  export type ProjectLoanGroupByOutputType = {
    id: string
    projectId: string
    userId: string
    amount: number
    status: string
    createdAt: Date
    _count: ProjectLoanCountAggregateOutputType | null
    _avg: ProjectLoanAvgAggregateOutputType | null
    _sum: ProjectLoanSumAggregateOutputType | null
    _min: ProjectLoanMinAggregateOutputType | null
    _max: ProjectLoanMaxAggregateOutputType | null
  }

  type GetProjectLoanGroupByPayload<T extends ProjectLoanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectLoanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectLoanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectLoanGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectLoanGroupByOutputType[P]>
        }
      >
    >


  export type ProjectLoanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectLoan"]>

  export type ProjectLoanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectLoan"]>

  export type ProjectLoanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectLoan"]>

  export type ProjectLoanSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type ProjectLoanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "userId" | "amount" | "status" | "createdAt", ExtArgs["result"]["projectLoan"]>
  export type ProjectLoanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectLoanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectLoanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectLoanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectLoan"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      userId: string
      amount: number
      status: string
      createdAt: Date
    }, ExtArgs["result"]["projectLoan"]>
    composites: {}
  }

  type ProjectLoanGetPayload<S extends boolean | null | undefined | ProjectLoanDefaultArgs> = $Result.GetResult<Prisma.$ProjectLoanPayload, S>

  type ProjectLoanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectLoanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectLoanCountAggregateInputType | true
    }

  export interface ProjectLoanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectLoan'], meta: { name: 'ProjectLoan' } }
    /**
     * Find zero or one ProjectLoan that matches the filter.
     * @param {ProjectLoanFindUniqueArgs} args - Arguments to find a ProjectLoan
     * @example
     * // Get one ProjectLoan
     * const projectLoan = await prisma.projectLoan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectLoanFindUniqueArgs>(args: SelectSubset<T, ProjectLoanFindUniqueArgs<ExtArgs>>): Prisma__ProjectLoanClient<$Result.GetResult<Prisma.$ProjectLoanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectLoan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectLoanFindUniqueOrThrowArgs} args - Arguments to find a ProjectLoan
     * @example
     * // Get one ProjectLoan
     * const projectLoan = await prisma.projectLoan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectLoanFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectLoanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectLoanClient<$Result.GetResult<Prisma.$ProjectLoanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectLoan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectLoanFindFirstArgs} args - Arguments to find a ProjectLoan
     * @example
     * // Get one ProjectLoan
     * const projectLoan = await prisma.projectLoan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectLoanFindFirstArgs>(args?: SelectSubset<T, ProjectLoanFindFirstArgs<ExtArgs>>): Prisma__ProjectLoanClient<$Result.GetResult<Prisma.$ProjectLoanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectLoan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectLoanFindFirstOrThrowArgs} args - Arguments to find a ProjectLoan
     * @example
     * // Get one ProjectLoan
     * const projectLoan = await prisma.projectLoan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectLoanFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectLoanFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectLoanClient<$Result.GetResult<Prisma.$ProjectLoanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectLoans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectLoanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectLoans
     * const projectLoans = await prisma.projectLoan.findMany()
     * 
     * // Get first 10 ProjectLoans
     * const projectLoans = await prisma.projectLoan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectLoanWithIdOnly = await prisma.projectLoan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectLoanFindManyArgs>(args?: SelectSubset<T, ProjectLoanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectLoanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectLoan.
     * @param {ProjectLoanCreateArgs} args - Arguments to create a ProjectLoan.
     * @example
     * // Create one ProjectLoan
     * const ProjectLoan = await prisma.projectLoan.create({
     *   data: {
     *     // ... data to create a ProjectLoan
     *   }
     * })
     * 
     */
    create<T extends ProjectLoanCreateArgs>(args: SelectSubset<T, ProjectLoanCreateArgs<ExtArgs>>): Prisma__ProjectLoanClient<$Result.GetResult<Prisma.$ProjectLoanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectLoans.
     * @param {ProjectLoanCreateManyArgs} args - Arguments to create many ProjectLoans.
     * @example
     * // Create many ProjectLoans
     * const projectLoan = await prisma.projectLoan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectLoanCreateManyArgs>(args?: SelectSubset<T, ProjectLoanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectLoans and returns the data saved in the database.
     * @param {ProjectLoanCreateManyAndReturnArgs} args - Arguments to create many ProjectLoans.
     * @example
     * // Create many ProjectLoans
     * const projectLoan = await prisma.projectLoan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectLoans and only return the `id`
     * const projectLoanWithIdOnly = await prisma.projectLoan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectLoanCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectLoanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectLoanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectLoan.
     * @param {ProjectLoanDeleteArgs} args - Arguments to delete one ProjectLoan.
     * @example
     * // Delete one ProjectLoan
     * const ProjectLoan = await prisma.projectLoan.delete({
     *   where: {
     *     // ... filter to delete one ProjectLoan
     *   }
     * })
     * 
     */
    delete<T extends ProjectLoanDeleteArgs>(args: SelectSubset<T, ProjectLoanDeleteArgs<ExtArgs>>): Prisma__ProjectLoanClient<$Result.GetResult<Prisma.$ProjectLoanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectLoan.
     * @param {ProjectLoanUpdateArgs} args - Arguments to update one ProjectLoan.
     * @example
     * // Update one ProjectLoan
     * const projectLoan = await prisma.projectLoan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectLoanUpdateArgs>(args: SelectSubset<T, ProjectLoanUpdateArgs<ExtArgs>>): Prisma__ProjectLoanClient<$Result.GetResult<Prisma.$ProjectLoanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectLoans.
     * @param {ProjectLoanDeleteManyArgs} args - Arguments to filter ProjectLoans to delete.
     * @example
     * // Delete a few ProjectLoans
     * const { count } = await prisma.projectLoan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectLoanDeleteManyArgs>(args?: SelectSubset<T, ProjectLoanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectLoans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectLoanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectLoans
     * const projectLoan = await prisma.projectLoan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectLoanUpdateManyArgs>(args: SelectSubset<T, ProjectLoanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectLoans and returns the data updated in the database.
     * @param {ProjectLoanUpdateManyAndReturnArgs} args - Arguments to update many ProjectLoans.
     * @example
     * // Update many ProjectLoans
     * const projectLoan = await prisma.projectLoan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectLoans and only return the `id`
     * const projectLoanWithIdOnly = await prisma.projectLoan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectLoanUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectLoanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectLoanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectLoan.
     * @param {ProjectLoanUpsertArgs} args - Arguments to update or create a ProjectLoan.
     * @example
     * // Update or create a ProjectLoan
     * const projectLoan = await prisma.projectLoan.upsert({
     *   create: {
     *     // ... data to create a ProjectLoan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectLoan we want to update
     *   }
     * })
     */
    upsert<T extends ProjectLoanUpsertArgs>(args: SelectSubset<T, ProjectLoanUpsertArgs<ExtArgs>>): Prisma__ProjectLoanClient<$Result.GetResult<Prisma.$ProjectLoanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectLoans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectLoanCountArgs} args - Arguments to filter ProjectLoans to count.
     * @example
     * // Count the number of ProjectLoans
     * const count = await prisma.projectLoan.count({
     *   where: {
     *     // ... the filter for the ProjectLoans we want to count
     *   }
     * })
    **/
    count<T extends ProjectLoanCountArgs>(
      args?: Subset<T, ProjectLoanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectLoanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectLoan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectLoanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectLoanAggregateArgs>(args: Subset<T, ProjectLoanAggregateArgs>): Prisma.PrismaPromise<GetProjectLoanAggregateType<T>>

    /**
     * Group by ProjectLoan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectLoanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectLoanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectLoanGroupByArgs['orderBy'] }
        : { orderBy?: ProjectLoanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectLoanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectLoanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectLoan model
   */
  readonly fields: ProjectLoanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectLoan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectLoanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectLoan model
   */
  interface ProjectLoanFieldRefs {
    readonly id: FieldRef<"ProjectLoan", 'String'>
    readonly projectId: FieldRef<"ProjectLoan", 'String'>
    readonly userId: FieldRef<"ProjectLoan", 'String'>
    readonly amount: FieldRef<"ProjectLoan", 'Float'>
    readonly status: FieldRef<"ProjectLoan", 'String'>
    readonly createdAt: FieldRef<"ProjectLoan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectLoan findUnique
   */
  export type ProjectLoanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLoan
     */
    select?: ProjectLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLoan
     */
    omit?: ProjectLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLoanInclude<ExtArgs> | null
    /**
     * Filter, which ProjectLoan to fetch.
     */
    where: ProjectLoanWhereUniqueInput
  }

  /**
   * ProjectLoan findUniqueOrThrow
   */
  export type ProjectLoanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLoan
     */
    select?: ProjectLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLoan
     */
    omit?: ProjectLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLoanInclude<ExtArgs> | null
    /**
     * Filter, which ProjectLoan to fetch.
     */
    where: ProjectLoanWhereUniqueInput
  }

  /**
   * ProjectLoan findFirst
   */
  export type ProjectLoanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLoan
     */
    select?: ProjectLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLoan
     */
    omit?: ProjectLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLoanInclude<ExtArgs> | null
    /**
     * Filter, which ProjectLoan to fetch.
     */
    where?: ProjectLoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectLoans to fetch.
     */
    orderBy?: ProjectLoanOrderByWithRelationInput | ProjectLoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectLoans.
     */
    cursor?: ProjectLoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectLoans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectLoans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectLoans.
     */
    distinct?: ProjectLoanScalarFieldEnum | ProjectLoanScalarFieldEnum[]
  }

  /**
   * ProjectLoan findFirstOrThrow
   */
  export type ProjectLoanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLoan
     */
    select?: ProjectLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLoan
     */
    omit?: ProjectLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLoanInclude<ExtArgs> | null
    /**
     * Filter, which ProjectLoan to fetch.
     */
    where?: ProjectLoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectLoans to fetch.
     */
    orderBy?: ProjectLoanOrderByWithRelationInput | ProjectLoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectLoans.
     */
    cursor?: ProjectLoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectLoans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectLoans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectLoans.
     */
    distinct?: ProjectLoanScalarFieldEnum | ProjectLoanScalarFieldEnum[]
  }

  /**
   * ProjectLoan findMany
   */
  export type ProjectLoanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLoan
     */
    select?: ProjectLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLoan
     */
    omit?: ProjectLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLoanInclude<ExtArgs> | null
    /**
     * Filter, which ProjectLoans to fetch.
     */
    where?: ProjectLoanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectLoans to fetch.
     */
    orderBy?: ProjectLoanOrderByWithRelationInput | ProjectLoanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectLoans.
     */
    cursor?: ProjectLoanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectLoans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectLoans.
     */
    skip?: number
    distinct?: ProjectLoanScalarFieldEnum | ProjectLoanScalarFieldEnum[]
  }

  /**
   * ProjectLoan create
   */
  export type ProjectLoanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLoan
     */
    select?: ProjectLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLoan
     */
    omit?: ProjectLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLoanInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectLoan.
     */
    data: XOR<ProjectLoanCreateInput, ProjectLoanUncheckedCreateInput>
  }

  /**
   * ProjectLoan createMany
   */
  export type ProjectLoanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectLoans.
     */
    data: ProjectLoanCreateManyInput | ProjectLoanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectLoan createManyAndReturn
   */
  export type ProjectLoanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLoan
     */
    select?: ProjectLoanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLoan
     */
    omit?: ProjectLoanOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectLoans.
     */
    data: ProjectLoanCreateManyInput | ProjectLoanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLoanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectLoan update
   */
  export type ProjectLoanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLoan
     */
    select?: ProjectLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLoan
     */
    omit?: ProjectLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLoanInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectLoan.
     */
    data: XOR<ProjectLoanUpdateInput, ProjectLoanUncheckedUpdateInput>
    /**
     * Choose, which ProjectLoan to update.
     */
    where: ProjectLoanWhereUniqueInput
  }

  /**
   * ProjectLoan updateMany
   */
  export type ProjectLoanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectLoans.
     */
    data: XOR<ProjectLoanUpdateManyMutationInput, ProjectLoanUncheckedUpdateManyInput>
    /**
     * Filter which ProjectLoans to update
     */
    where?: ProjectLoanWhereInput
    /**
     * Limit how many ProjectLoans to update.
     */
    limit?: number
  }

  /**
   * ProjectLoan updateManyAndReturn
   */
  export type ProjectLoanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLoan
     */
    select?: ProjectLoanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLoan
     */
    omit?: ProjectLoanOmit<ExtArgs> | null
    /**
     * The data used to update ProjectLoans.
     */
    data: XOR<ProjectLoanUpdateManyMutationInput, ProjectLoanUncheckedUpdateManyInput>
    /**
     * Filter which ProjectLoans to update
     */
    where?: ProjectLoanWhereInput
    /**
     * Limit how many ProjectLoans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLoanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectLoan upsert
   */
  export type ProjectLoanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLoan
     */
    select?: ProjectLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLoan
     */
    omit?: ProjectLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLoanInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectLoan to update in case it exists.
     */
    where: ProjectLoanWhereUniqueInput
    /**
     * In case the ProjectLoan found by the `where` argument doesn't exist, create a new ProjectLoan with this data.
     */
    create: XOR<ProjectLoanCreateInput, ProjectLoanUncheckedCreateInput>
    /**
     * In case the ProjectLoan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectLoanUpdateInput, ProjectLoanUncheckedUpdateInput>
  }

  /**
   * ProjectLoan delete
   */
  export type ProjectLoanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLoan
     */
    select?: ProjectLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLoan
     */
    omit?: ProjectLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLoanInclude<ExtArgs> | null
    /**
     * Filter which ProjectLoan to delete.
     */
    where: ProjectLoanWhereUniqueInput
  }

  /**
   * ProjectLoan deleteMany
   */
  export type ProjectLoanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectLoans to delete
     */
    where?: ProjectLoanWhereInput
    /**
     * Limit how many ProjectLoans to delete.
     */
    limit?: number
  }

  /**
   * ProjectLoan without action
   */
  export type ProjectLoanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectLoan
     */
    select?: ProjectLoanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectLoan
     */
    omit?: ProjectLoanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectLoanInclude<ExtArgs> | null
  }


  /**
   * Model Circle
   */

  export type AggregateCircle = {
    _count: CircleCountAggregateOutputType | null
    _avg: CircleAvgAggregateOutputType | null
    _sum: CircleSumAggregateOutputType | null
    _min: CircleMinAggregateOutputType | null
    _max: CircleMaxAggregateOutputType | null
  }

  export type CircleAvgAggregateOutputType = {
    maxMembers: number | null
    monthlyFee: number | null
    funds: number | null
    allocatedFunds: number | null
  }

  export type CircleSumAggregateOutputType = {
    maxMembers: number | null
    monthlyFee: number | null
    funds: number | null
    allocatedFunds: number | null
  }

  export type CircleMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    type: $Enums.CircleType | null
    theme: string | null
    participationMode: $Enums.CircleParticipationMode | null
    maxMembers: number | null
    isPublic: boolean | null
    isActive: boolean | null
    monthlyFee: number | null
    funds: number | null
    allocatedFunds: number | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CircleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    type: $Enums.CircleType | null
    theme: string | null
    participationMode: $Enums.CircleParticipationMode | null
    maxMembers: number | null
    isPublic: boolean | null
    isActive: boolean | null
    monthlyFee: number | null
    funds: number | null
    allocatedFunds: number | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CircleCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    type: number
    theme: number
    participationMode: number
    maxMembers: number
    isPublic: number
    isActive: number
    monthlyFee: number
    funds: number
    allocatedFunds: number
    creatorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CircleAvgAggregateInputType = {
    maxMembers?: true
    monthlyFee?: true
    funds?: true
    allocatedFunds?: true
  }

  export type CircleSumAggregateInputType = {
    maxMembers?: true
    monthlyFee?: true
    funds?: true
    allocatedFunds?: true
  }

  export type CircleMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    type?: true
    theme?: true
    participationMode?: true
    maxMembers?: true
    isPublic?: true
    isActive?: true
    monthlyFee?: true
    funds?: true
    allocatedFunds?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CircleMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    type?: true
    theme?: true
    participationMode?: true
    maxMembers?: true
    isPublic?: true
    isActive?: true
    monthlyFee?: true
    funds?: true
    allocatedFunds?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CircleCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    type?: true
    theme?: true
    participationMode?: true
    maxMembers?: true
    isPublic?: true
    isActive?: true
    monthlyFee?: true
    funds?: true
    allocatedFunds?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CircleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Circle to aggregate.
     */
    where?: CircleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Circles to fetch.
     */
    orderBy?: CircleOrderByWithRelationInput | CircleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CircleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Circles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Circles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Circles
    **/
    _count?: true | CircleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CircleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CircleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CircleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CircleMaxAggregateInputType
  }

  export type GetCircleAggregateType<T extends CircleAggregateArgs> = {
        [P in keyof T & keyof AggregateCircle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCircle[P]>
      : GetScalarType<T[P], AggregateCircle[P]>
  }




  export type CircleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CircleWhereInput
    orderBy?: CircleOrderByWithAggregationInput | CircleOrderByWithAggregationInput[]
    by: CircleScalarFieldEnum[] | CircleScalarFieldEnum
    having?: CircleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CircleCountAggregateInputType | true
    _avg?: CircleAvgAggregateInputType
    _sum?: CircleSumAggregateInputType
    _min?: CircleMinAggregateInputType
    _max?: CircleMaxAggregateInputType
  }

  export type CircleGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    type: $Enums.CircleType
    theme: string | null
    participationMode: $Enums.CircleParticipationMode
    maxMembers: number | null
    isPublic: boolean
    isActive: boolean
    monthlyFee: number | null
    funds: number
    allocatedFunds: number
    creatorId: string
    createdAt: Date
    updatedAt: Date
    _count: CircleCountAggregateOutputType | null
    _avg: CircleAvgAggregateOutputType | null
    _sum: CircleSumAggregateOutputType | null
    _min: CircleMinAggregateOutputType | null
    _max: CircleMaxAggregateOutputType | null
  }

  type GetCircleGroupByPayload<T extends CircleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CircleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CircleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CircleGroupByOutputType[P]>
            : GetScalarType<T[P], CircleGroupByOutputType[P]>
        }
      >
    >


  export type CircleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    type?: boolean
    theme?: boolean
    participationMode?: boolean
    maxMembers?: boolean
    isPublic?: boolean
    isActive?: boolean
    monthlyFee?: boolean
    funds?: boolean
    allocatedFunds?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Circle$membersArgs<ExtArgs>
    projects?: boolean | Circle$projectsArgs<ExtArgs>
    Transaction?: boolean | Circle$TransactionArgs<ExtArgs>
    _count?: boolean | CircleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["circle"]>

  export type CircleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    type?: boolean
    theme?: boolean
    participationMode?: boolean
    maxMembers?: boolean
    isPublic?: boolean
    isActive?: boolean
    monthlyFee?: boolean
    funds?: boolean
    allocatedFunds?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["circle"]>

  export type CircleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    type?: boolean
    theme?: boolean
    participationMode?: boolean
    maxMembers?: boolean
    isPublic?: boolean
    isActive?: boolean
    monthlyFee?: boolean
    funds?: boolean
    allocatedFunds?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["circle"]>

  export type CircleSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    type?: boolean
    theme?: boolean
    participationMode?: boolean
    maxMembers?: boolean
    isPublic?: boolean
    isActive?: boolean
    monthlyFee?: boolean
    funds?: boolean
    allocatedFunds?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CircleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "type" | "theme" | "participationMode" | "maxMembers" | "isPublic" | "isActive" | "monthlyFee" | "funds" | "allocatedFunds" | "creatorId" | "createdAt" | "updatedAt", ExtArgs["result"]["circle"]>
  export type CircleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Circle$membersArgs<ExtArgs>
    projects?: boolean | Circle$projectsArgs<ExtArgs>
    Transaction?: boolean | Circle$TransactionArgs<ExtArgs>
    _count?: boolean | CircleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CircleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CircleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CirclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Circle"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$CircleMemberPayload<ExtArgs>[]
      projects: Prisma.$CircleProjectPayload<ExtArgs>[]
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      type: $Enums.CircleType
      theme: string | null
      participationMode: $Enums.CircleParticipationMode
      maxMembers: number | null
      isPublic: boolean
      isActive: boolean
      monthlyFee: number | null
      funds: number
      allocatedFunds: number
      creatorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["circle"]>
    composites: {}
  }

  type CircleGetPayload<S extends boolean | null | undefined | CircleDefaultArgs> = $Result.GetResult<Prisma.$CirclePayload, S>

  type CircleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CircleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CircleCountAggregateInputType | true
    }

  export interface CircleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Circle'], meta: { name: 'Circle' } }
    /**
     * Find zero or one Circle that matches the filter.
     * @param {CircleFindUniqueArgs} args - Arguments to find a Circle
     * @example
     * // Get one Circle
     * const circle = await prisma.circle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CircleFindUniqueArgs>(args: SelectSubset<T, CircleFindUniqueArgs<ExtArgs>>): Prisma__CircleClient<$Result.GetResult<Prisma.$CirclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Circle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CircleFindUniqueOrThrowArgs} args - Arguments to find a Circle
     * @example
     * // Get one Circle
     * const circle = await prisma.circle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CircleFindUniqueOrThrowArgs>(args: SelectSubset<T, CircleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CircleClient<$Result.GetResult<Prisma.$CirclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Circle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleFindFirstArgs} args - Arguments to find a Circle
     * @example
     * // Get one Circle
     * const circle = await prisma.circle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CircleFindFirstArgs>(args?: SelectSubset<T, CircleFindFirstArgs<ExtArgs>>): Prisma__CircleClient<$Result.GetResult<Prisma.$CirclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Circle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleFindFirstOrThrowArgs} args - Arguments to find a Circle
     * @example
     * // Get one Circle
     * const circle = await prisma.circle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CircleFindFirstOrThrowArgs>(args?: SelectSubset<T, CircleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CircleClient<$Result.GetResult<Prisma.$CirclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Circles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Circles
     * const circles = await prisma.circle.findMany()
     * 
     * // Get first 10 Circles
     * const circles = await prisma.circle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const circleWithIdOnly = await prisma.circle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CircleFindManyArgs>(args?: SelectSubset<T, CircleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CirclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Circle.
     * @param {CircleCreateArgs} args - Arguments to create a Circle.
     * @example
     * // Create one Circle
     * const Circle = await prisma.circle.create({
     *   data: {
     *     // ... data to create a Circle
     *   }
     * })
     * 
     */
    create<T extends CircleCreateArgs>(args: SelectSubset<T, CircleCreateArgs<ExtArgs>>): Prisma__CircleClient<$Result.GetResult<Prisma.$CirclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Circles.
     * @param {CircleCreateManyArgs} args - Arguments to create many Circles.
     * @example
     * // Create many Circles
     * const circle = await prisma.circle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CircleCreateManyArgs>(args?: SelectSubset<T, CircleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Circles and returns the data saved in the database.
     * @param {CircleCreateManyAndReturnArgs} args - Arguments to create many Circles.
     * @example
     * // Create many Circles
     * const circle = await prisma.circle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Circles and only return the `id`
     * const circleWithIdOnly = await prisma.circle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CircleCreateManyAndReturnArgs>(args?: SelectSubset<T, CircleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CirclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Circle.
     * @param {CircleDeleteArgs} args - Arguments to delete one Circle.
     * @example
     * // Delete one Circle
     * const Circle = await prisma.circle.delete({
     *   where: {
     *     // ... filter to delete one Circle
     *   }
     * })
     * 
     */
    delete<T extends CircleDeleteArgs>(args: SelectSubset<T, CircleDeleteArgs<ExtArgs>>): Prisma__CircleClient<$Result.GetResult<Prisma.$CirclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Circle.
     * @param {CircleUpdateArgs} args - Arguments to update one Circle.
     * @example
     * // Update one Circle
     * const circle = await prisma.circle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CircleUpdateArgs>(args: SelectSubset<T, CircleUpdateArgs<ExtArgs>>): Prisma__CircleClient<$Result.GetResult<Prisma.$CirclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Circles.
     * @param {CircleDeleteManyArgs} args - Arguments to filter Circles to delete.
     * @example
     * // Delete a few Circles
     * const { count } = await prisma.circle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CircleDeleteManyArgs>(args?: SelectSubset<T, CircleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Circles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Circles
     * const circle = await prisma.circle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CircleUpdateManyArgs>(args: SelectSubset<T, CircleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Circles and returns the data updated in the database.
     * @param {CircleUpdateManyAndReturnArgs} args - Arguments to update many Circles.
     * @example
     * // Update many Circles
     * const circle = await prisma.circle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Circles and only return the `id`
     * const circleWithIdOnly = await prisma.circle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CircleUpdateManyAndReturnArgs>(args: SelectSubset<T, CircleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CirclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Circle.
     * @param {CircleUpsertArgs} args - Arguments to update or create a Circle.
     * @example
     * // Update or create a Circle
     * const circle = await prisma.circle.upsert({
     *   create: {
     *     // ... data to create a Circle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Circle we want to update
     *   }
     * })
     */
    upsert<T extends CircleUpsertArgs>(args: SelectSubset<T, CircleUpsertArgs<ExtArgs>>): Prisma__CircleClient<$Result.GetResult<Prisma.$CirclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Circles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleCountArgs} args - Arguments to filter Circles to count.
     * @example
     * // Count the number of Circles
     * const count = await prisma.circle.count({
     *   where: {
     *     // ... the filter for the Circles we want to count
     *   }
     * })
    **/
    count<T extends CircleCountArgs>(
      args?: Subset<T, CircleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CircleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Circle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CircleAggregateArgs>(args: Subset<T, CircleAggregateArgs>): Prisma.PrismaPromise<GetCircleAggregateType<T>>

    /**
     * Group by Circle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CircleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CircleGroupByArgs['orderBy'] }
        : { orderBy?: CircleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CircleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCircleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Circle model
   */
  readonly fields: CircleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Circle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CircleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Circle$membersArgs<ExtArgs> = {}>(args?: Subset<T, Circle$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CircleMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends Circle$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Circle$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CircleProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transaction<T extends Circle$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, Circle$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Circle model
   */
  interface CircleFieldRefs {
    readonly id: FieldRef<"Circle", 'String'>
    readonly name: FieldRef<"Circle", 'String'>
    readonly slug: FieldRef<"Circle", 'String'>
    readonly description: FieldRef<"Circle", 'String'>
    readonly type: FieldRef<"Circle", 'CircleType'>
    readonly theme: FieldRef<"Circle", 'String'>
    readonly participationMode: FieldRef<"Circle", 'CircleParticipationMode'>
    readonly maxMembers: FieldRef<"Circle", 'Int'>
    readonly isPublic: FieldRef<"Circle", 'Boolean'>
    readonly isActive: FieldRef<"Circle", 'Boolean'>
    readonly monthlyFee: FieldRef<"Circle", 'Float'>
    readonly funds: FieldRef<"Circle", 'Float'>
    readonly allocatedFunds: FieldRef<"Circle", 'Float'>
    readonly creatorId: FieldRef<"Circle", 'String'>
    readonly createdAt: FieldRef<"Circle", 'DateTime'>
    readonly updatedAt: FieldRef<"Circle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Circle findUnique
   */
  export type CircleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circle
     */
    select?: CircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circle
     */
    omit?: CircleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleInclude<ExtArgs> | null
    /**
     * Filter, which Circle to fetch.
     */
    where: CircleWhereUniqueInput
  }

  /**
   * Circle findUniqueOrThrow
   */
  export type CircleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circle
     */
    select?: CircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circle
     */
    omit?: CircleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleInclude<ExtArgs> | null
    /**
     * Filter, which Circle to fetch.
     */
    where: CircleWhereUniqueInput
  }

  /**
   * Circle findFirst
   */
  export type CircleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circle
     */
    select?: CircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circle
     */
    omit?: CircleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleInclude<ExtArgs> | null
    /**
     * Filter, which Circle to fetch.
     */
    where?: CircleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Circles to fetch.
     */
    orderBy?: CircleOrderByWithRelationInput | CircleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Circles.
     */
    cursor?: CircleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Circles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Circles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Circles.
     */
    distinct?: CircleScalarFieldEnum | CircleScalarFieldEnum[]
  }

  /**
   * Circle findFirstOrThrow
   */
  export type CircleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circle
     */
    select?: CircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circle
     */
    omit?: CircleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleInclude<ExtArgs> | null
    /**
     * Filter, which Circle to fetch.
     */
    where?: CircleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Circles to fetch.
     */
    orderBy?: CircleOrderByWithRelationInput | CircleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Circles.
     */
    cursor?: CircleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Circles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Circles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Circles.
     */
    distinct?: CircleScalarFieldEnum | CircleScalarFieldEnum[]
  }

  /**
   * Circle findMany
   */
  export type CircleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circle
     */
    select?: CircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circle
     */
    omit?: CircleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleInclude<ExtArgs> | null
    /**
     * Filter, which Circles to fetch.
     */
    where?: CircleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Circles to fetch.
     */
    orderBy?: CircleOrderByWithRelationInput | CircleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Circles.
     */
    cursor?: CircleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Circles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Circles.
     */
    skip?: number
    distinct?: CircleScalarFieldEnum | CircleScalarFieldEnum[]
  }

  /**
   * Circle create
   */
  export type CircleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circle
     */
    select?: CircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circle
     */
    omit?: CircleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleInclude<ExtArgs> | null
    /**
     * The data needed to create a Circle.
     */
    data: XOR<CircleCreateInput, CircleUncheckedCreateInput>
  }

  /**
   * Circle createMany
   */
  export type CircleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Circles.
     */
    data: CircleCreateManyInput | CircleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Circle createManyAndReturn
   */
  export type CircleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circle
     */
    select?: CircleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Circle
     */
    omit?: CircleOmit<ExtArgs> | null
    /**
     * The data used to create many Circles.
     */
    data: CircleCreateManyInput | CircleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Circle update
   */
  export type CircleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circle
     */
    select?: CircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circle
     */
    omit?: CircleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleInclude<ExtArgs> | null
    /**
     * The data needed to update a Circle.
     */
    data: XOR<CircleUpdateInput, CircleUncheckedUpdateInput>
    /**
     * Choose, which Circle to update.
     */
    where: CircleWhereUniqueInput
  }

  /**
   * Circle updateMany
   */
  export type CircleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Circles.
     */
    data: XOR<CircleUpdateManyMutationInput, CircleUncheckedUpdateManyInput>
    /**
     * Filter which Circles to update
     */
    where?: CircleWhereInput
    /**
     * Limit how many Circles to update.
     */
    limit?: number
  }

  /**
   * Circle updateManyAndReturn
   */
  export type CircleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circle
     */
    select?: CircleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Circle
     */
    omit?: CircleOmit<ExtArgs> | null
    /**
     * The data used to update Circles.
     */
    data: XOR<CircleUpdateManyMutationInput, CircleUncheckedUpdateManyInput>
    /**
     * Filter which Circles to update
     */
    where?: CircleWhereInput
    /**
     * Limit how many Circles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Circle upsert
   */
  export type CircleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circle
     */
    select?: CircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circle
     */
    omit?: CircleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleInclude<ExtArgs> | null
    /**
     * The filter to search for the Circle to update in case it exists.
     */
    where: CircleWhereUniqueInput
    /**
     * In case the Circle found by the `where` argument doesn't exist, create a new Circle with this data.
     */
    create: XOR<CircleCreateInput, CircleUncheckedCreateInput>
    /**
     * In case the Circle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CircleUpdateInput, CircleUncheckedUpdateInput>
  }

  /**
   * Circle delete
   */
  export type CircleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circle
     */
    select?: CircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circle
     */
    omit?: CircleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleInclude<ExtArgs> | null
    /**
     * Filter which Circle to delete.
     */
    where: CircleWhereUniqueInput
  }

  /**
   * Circle deleteMany
   */
  export type CircleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Circles to delete
     */
    where?: CircleWhereInput
    /**
     * Limit how many Circles to delete.
     */
    limit?: number
  }

  /**
   * Circle.members
   */
  export type Circle$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleMember
     */
    select?: CircleMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleMember
     */
    omit?: CircleMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleMemberInclude<ExtArgs> | null
    where?: CircleMemberWhereInput
    orderBy?: CircleMemberOrderByWithRelationInput | CircleMemberOrderByWithRelationInput[]
    cursor?: CircleMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CircleMemberScalarFieldEnum | CircleMemberScalarFieldEnum[]
  }

  /**
   * Circle.projects
   */
  export type Circle$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleProject
     */
    select?: CircleProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleProject
     */
    omit?: CircleProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleProjectInclude<ExtArgs> | null
    where?: CircleProjectWhereInput
    orderBy?: CircleProjectOrderByWithRelationInput | CircleProjectOrderByWithRelationInput[]
    cursor?: CircleProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CircleProjectScalarFieldEnum | CircleProjectScalarFieldEnum[]
  }

  /**
   * Circle.Transaction
   */
  export type Circle$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Circle without action
   */
  export type CircleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circle
     */
    select?: CircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circle
     */
    omit?: CircleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleInclude<ExtArgs> | null
  }


  /**
   * Model CircleMember
   */

  export type AggregateCircleMember = {
    _count: CircleMemberCountAggregateOutputType | null
    _avg: CircleMemberAvgAggregateOutputType | null
    _sum: CircleMemberSumAggregateOutputType | null
    _min: CircleMemberMinAggregateOutputType | null
    _max: CircleMemberMaxAggregateOutputType | null
  }

  export type CircleMemberAvgAggregateOutputType = {
    xp: number | null
    level: number | null
  }

  export type CircleMemberSumAggregateOutputType = {
    xp: number | null
    level: number | null
  }

  export type CircleMemberMinAggregateOutputType = {
    id: string | null
    circleId: string | null
    userId: string | null
    role: $Enums.CircleMemberRole | null
    joinedAt: Date | null
    xp: number | null
    level: number | null
  }

  export type CircleMemberMaxAggregateOutputType = {
    id: string | null
    circleId: string | null
    userId: string | null
    role: $Enums.CircleMemberRole | null
    joinedAt: Date | null
    xp: number | null
    level: number | null
  }

  export type CircleMemberCountAggregateOutputType = {
    id: number
    circleId: number
    userId: number
    role: number
    joinedAt: number
    xp: number
    level: number
    _all: number
  }


  export type CircleMemberAvgAggregateInputType = {
    xp?: true
    level?: true
  }

  export type CircleMemberSumAggregateInputType = {
    xp?: true
    level?: true
  }

  export type CircleMemberMinAggregateInputType = {
    id?: true
    circleId?: true
    userId?: true
    role?: true
    joinedAt?: true
    xp?: true
    level?: true
  }

  export type CircleMemberMaxAggregateInputType = {
    id?: true
    circleId?: true
    userId?: true
    role?: true
    joinedAt?: true
    xp?: true
    level?: true
  }

  export type CircleMemberCountAggregateInputType = {
    id?: true
    circleId?: true
    userId?: true
    role?: true
    joinedAt?: true
    xp?: true
    level?: true
    _all?: true
  }

  export type CircleMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CircleMember to aggregate.
     */
    where?: CircleMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CircleMembers to fetch.
     */
    orderBy?: CircleMemberOrderByWithRelationInput | CircleMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CircleMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CircleMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CircleMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CircleMembers
    **/
    _count?: true | CircleMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CircleMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CircleMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CircleMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CircleMemberMaxAggregateInputType
  }

  export type GetCircleMemberAggregateType<T extends CircleMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateCircleMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCircleMember[P]>
      : GetScalarType<T[P], AggregateCircleMember[P]>
  }




  export type CircleMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CircleMemberWhereInput
    orderBy?: CircleMemberOrderByWithAggregationInput | CircleMemberOrderByWithAggregationInput[]
    by: CircleMemberScalarFieldEnum[] | CircleMemberScalarFieldEnum
    having?: CircleMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CircleMemberCountAggregateInputType | true
    _avg?: CircleMemberAvgAggregateInputType
    _sum?: CircleMemberSumAggregateInputType
    _min?: CircleMemberMinAggregateInputType
    _max?: CircleMemberMaxAggregateInputType
  }

  export type CircleMemberGroupByOutputType = {
    id: string
    circleId: string
    userId: string
    role: $Enums.CircleMemberRole
    joinedAt: Date
    xp: number
    level: number
    _count: CircleMemberCountAggregateOutputType | null
    _avg: CircleMemberAvgAggregateOutputType | null
    _sum: CircleMemberSumAggregateOutputType | null
    _min: CircleMemberMinAggregateOutputType | null
    _max: CircleMemberMaxAggregateOutputType | null
  }

  type GetCircleMemberGroupByPayload<T extends CircleMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CircleMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CircleMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CircleMemberGroupByOutputType[P]>
            : GetScalarType<T[P], CircleMemberGroupByOutputType[P]>
        }
      >
    >


  export type CircleMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    circleId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    xp?: boolean
    level?: boolean
    circle?: boolean | CircleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["circleMember"]>

  export type CircleMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    circleId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    xp?: boolean
    level?: boolean
    circle?: boolean | CircleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["circleMember"]>

  export type CircleMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    circleId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    xp?: boolean
    level?: boolean
    circle?: boolean | CircleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["circleMember"]>

  export type CircleMemberSelectScalar = {
    id?: boolean
    circleId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    xp?: boolean
    level?: boolean
  }

  export type CircleMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "circleId" | "userId" | "role" | "joinedAt" | "xp" | "level", ExtArgs["result"]["circleMember"]>
  export type CircleMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    circle?: boolean | CircleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CircleMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    circle?: boolean | CircleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CircleMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    circle?: boolean | CircleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CircleMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CircleMember"
    objects: {
      circle: Prisma.$CirclePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      circleId: string
      userId: string
      role: $Enums.CircleMemberRole
      joinedAt: Date
      xp: number
      level: number
    }, ExtArgs["result"]["circleMember"]>
    composites: {}
  }

  type CircleMemberGetPayload<S extends boolean | null | undefined | CircleMemberDefaultArgs> = $Result.GetResult<Prisma.$CircleMemberPayload, S>

  type CircleMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CircleMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CircleMemberCountAggregateInputType | true
    }

  export interface CircleMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CircleMember'], meta: { name: 'CircleMember' } }
    /**
     * Find zero or one CircleMember that matches the filter.
     * @param {CircleMemberFindUniqueArgs} args - Arguments to find a CircleMember
     * @example
     * // Get one CircleMember
     * const circleMember = await prisma.circleMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CircleMemberFindUniqueArgs>(args: SelectSubset<T, CircleMemberFindUniqueArgs<ExtArgs>>): Prisma__CircleMemberClient<$Result.GetResult<Prisma.$CircleMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CircleMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CircleMemberFindUniqueOrThrowArgs} args - Arguments to find a CircleMember
     * @example
     * // Get one CircleMember
     * const circleMember = await prisma.circleMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CircleMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, CircleMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CircleMemberClient<$Result.GetResult<Prisma.$CircleMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CircleMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleMemberFindFirstArgs} args - Arguments to find a CircleMember
     * @example
     * // Get one CircleMember
     * const circleMember = await prisma.circleMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CircleMemberFindFirstArgs>(args?: SelectSubset<T, CircleMemberFindFirstArgs<ExtArgs>>): Prisma__CircleMemberClient<$Result.GetResult<Prisma.$CircleMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CircleMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleMemberFindFirstOrThrowArgs} args - Arguments to find a CircleMember
     * @example
     * // Get one CircleMember
     * const circleMember = await prisma.circleMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CircleMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, CircleMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__CircleMemberClient<$Result.GetResult<Prisma.$CircleMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CircleMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CircleMembers
     * const circleMembers = await prisma.circleMember.findMany()
     * 
     * // Get first 10 CircleMembers
     * const circleMembers = await prisma.circleMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const circleMemberWithIdOnly = await prisma.circleMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CircleMemberFindManyArgs>(args?: SelectSubset<T, CircleMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CircleMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CircleMember.
     * @param {CircleMemberCreateArgs} args - Arguments to create a CircleMember.
     * @example
     * // Create one CircleMember
     * const CircleMember = await prisma.circleMember.create({
     *   data: {
     *     // ... data to create a CircleMember
     *   }
     * })
     * 
     */
    create<T extends CircleMemberCreateArgs>(args: SelectSubset<T, CircleMemberCreateArgs<ExtArgs>>): Prisma__CircleMemberClient<$Result.GetResult<Prisma.$CircleMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CircleMembers.
     * @param {CircleMemberCreateManyArgs} args - Arguments to create many CircleMembers.
     * @example
     * // Create many CircleMembers
     * const circleMember = await prisma.circleMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CircleMemberCreateManyArgs>(args?: SelectSubset<T, CircleMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CircleMembers and returns the data saved in the database.
     * @param {CircleMemberCreateManyAndReturnArgs} args - Arguments to create many CircleMembers.
     * @example
     * // Create many CircleMembers
     * const circleMember = await prisma.circleMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CircleMembers and only return the `id`
     * const circleMemberWithIdOnly = await prisma.circleMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CircleMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, CircleMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CircleMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CircleMember.
     * @param {CircleMemberDeleteArgs} args - Arguments to delete one CircleMember.
     * @example
     * // Delete one CircleMember
     * const CircleMember = await prisma.circleMember.delete({
     *   where: {
     *     // ... filter to delete one CircleMember
     *   }
     * })
     * 
     */
    delete<T extends CircleMemberDeleteArgs>(args: SelectSubset<T, CircleMemberDeleteArgs<ExtArgs>>): Prisma__CircleMemberClient<$Result.GetResult<Prisma.$CircleMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CircleMember.
     * @param {CircleMemberUpdateArgs} args - Arguments to update one CircleMember.
     * @example
     * // Update one CircleMember
     * const circleMember = await prisma.circleMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CircleMemberUpdateArgs>(args: SelectSubset<T, CircleMemberUpdateArgs<ExtArgs>>): Prisma__CircleMemberClient<$Result.GetResult<Prisma.$CircleMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CircleMembers.
     * @param {CircleMemberDeleteManyArgs} args - Arguments to filter CircleMembers to delete.
     * @example
     * // Delete a few CircleMembers
     * const { count } = await prisma.circleMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CircleMemberDeleteManyArgs>(args?: SelectSubset<T, CircleMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CircleMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CircleMembers
     * const circleMember = await prisma.circleMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CircleMemberUpdateManyArgs>(args: SelectSubset<T, CircleMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CircleMembers and returns the data updated in the database.
     * @param {CircleMemberUpdateManyAndReturnArgs} args - Arguments to update many CircleMembers.
     * @example
     * // Update many CircleMembers
     * const circleMember = await prisma.circleMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CircleMembers and only return the `id`
     * const circleMemberWithIdOnly = await prisma.circleMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CircleMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, CircleMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CircleMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CircleMember.
     * @param {CircleMemberUpsertArgs} args - Arguments to update or create a CircleMember.
     * @example
     * // Update or create a CircleMember
     * const circleMember = await prisma.circleMember.upsert({
     *   create: {
     *     // ... data to create a CircleMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CircleMember we want to update
     *   }
     * })
     */
    upsert<T extends CircleMemberUpsertArgs>(args: SelectSubset<T, CircleMemberUpsertArgs<ExtArgs>>): Prisma__CircleMemberClient<$Result.GetResult<Prisma.$CircleMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CircleMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleMemberCountArgs} args - Arguments to filter CircleMembers to count.
     * @example
     * // Count the number of CircleMembers
     * const count = await prisma.circleMember.count({
     *   where: {
     *     // ... the filter for the CircleMembers we want to count
     *   }
     * })
    **/
    count<T extends CircleMemberCountArgs>(
      args?: Subset<T, CircleMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CircleMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CircleMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CircleMemberAggregateArgs>(args: Subset<T, CircleMemberAggregateArgs>): Prisma.PrismaPromise<GetCircleMemberAggregateType<T>>

    /**
     * Group by CircleMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CircleMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CircleMemberGroupByArgs['orderBy'] }
        : { orderBy?: CircleMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CircleMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCircleMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CircleMember model
   */
  readonly fields: CircleMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CircleMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CircleMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    circle<T extends CircleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CircleDefaultArgs<ExtArgs>>): Prisma__CircleClient<$Result.GetResult<Prisma.$CirclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CircleMember model
   */
  interface CircleMemberFieldRefs {
    readonly id: FieldRef<"CircleMember", 'String'>
    readonly circleId: FieldRef<"CircleMember", 'String'>
    readonly userId: FieldRef<"CircleMember", 'String'>
    readonly role: FieldRef<"CircleMember", 'CircleMemberRole'>
    readonly joinedAt: FieldRef<"CircleMember", 'DateTime'>
    readonly xp: FieldRef<"CircleMember", 'Int'>
    readonly level: FieldRef<"CircleMember", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CircleMember findUnique
   */
  export type CircleMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleMember
     */
    select?: CircleMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleMember
     */
    omit?: CircleMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleMemberInclude<ExtArgs> | null
    /**
     * Filter, which CircleMember to fetch.
     */
    where: CircleMemberWhereUniqueInput
  }

  /**
   * CircleMember findUniqueOrThrow
   */
  export type CircleMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleMember
     */
    select?: CircleMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleMember
     */
    omit?: CircleMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleMemberInclude<ExtArgs> | null
    /**
     * Filter, which CircleMember to fetch.
     */
    where: CircleMemberWhereUniqueInput
  }

  /**
   * CircleMember findFirst
   */
  export type CircleMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleMember
     */
    select?: CircleMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleMember
     */
    omit?: CircleMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleMemberInclude<ExtArgs> | null
    /**
     * Filter, which CircleMember to fetch.
     */
    where?: CircleMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CircleMembers to fetch.
     */
    orderBy?: CircleMemberOrderByWithRelationInput | CircleMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CircleMembers.
     */
    cursor?: CircleMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CircleMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CircleMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CircleMembers.
     */
    distinct?: CircleMemberScalarFieldEnum | CircleMemberScalarFieldEnum[]
  }

  /**
   * CircleMember findFirstOrThrow
   */
  export type CircleMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleMember
     */
    select?: CircleMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleMember
     */
    omit?: CircleMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleMemberInclude<ExtArgs> | null
    /**
     * Filter, which CircleMember to fetch.
     */
    where?: CircleMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CircleMembers to fetch.
     */
    orderBy?: CircleMemberOrderByWithRelationInput | CircleMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CircleMembers.
     */
    cursor?: CircleMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CircleMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CircleMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CircleMembers.
     */
    distinct?: CircleMemberScalarFieldEnum | CircleMemberScalarFieldEnum[]
  }

  /**
   * CircleMember findMany
   */
  export type CircleMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleMember
     */
    select?: CircleMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleMember
     */
    omit?: CircleMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleMemberInclude<ExtArgs> | null
    /**
     * Filter, which CircleMembers to fetch.
     */
    where?: CircleMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CircleMembers to fetch.
     */
    orderBy?: CircleMemberOrderByWithRelationInput | CircleMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CircleMembers.
     */
    cursor?: CircleMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CircleMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CircleMembers.
     */
    skip?: number
    distinct?: CircleMemberScalarFieldEnum | CircleMemberScalarFieldEnum[]
  }

  /**
   * CircleMember create
   */
  export type CircleMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleMember
     */
    select?: CircleMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleMember
     */
    omit?: CircleMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a CircleMember.
     */
    data: XOR<CircleMemberCreateInput, CircleMemberUncheckedCreateInput>
  }

  /**
   * CircleMember createMany
   */
  export type CircleMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CircleMembers.
     */
    data: CircleMemberCreateManyInput | CircleMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CircleMember createManyAndReturn
   */
  export type CircleMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleMember
     */
    select?: CircleMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CircleMember
     */
    omit?: CircleMemberOmit<ExtArgs> | null
    /**
     * The data used to create many CircleMembers.
     */
    data: CircleMemberCreateManyInput | CircleMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CircleMember update
   */
  export type CircleMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleMember
     */
    select?: CircleMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleMember
     */
    omit?: CircleMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a CircleMember.
     */
    data: XOR<CircleMemberUpdateInput, CircleMemberUncheckedUpdateInput>
    /**
     * Choose, which CircleMember to update.
     */
    where: CircleMemberWhereUniqueInput
  }

  /**
   * CircleMember updateMany
   */
  export type CircleMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CircleMembers.
     */
    data: XOR<CircleMemberUpdateManyMutationInput, CircleMemberUncheckedUpdateManyInput>
    /**
     * Filter which CircleMembers to update
     */
    where?: CircleMemberWhereInput
    /**
     * Limit how many CircleMembers to update.
     */
    limit?: number
  }

  /**
   * CircleMember updateManyAndReturn
   */
  export type CircleMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleMember
     */
    select?: CircleMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CircleMember
     */
    omit?: CircleMemberOmit<ExtArgs> | null
    /**
     * The data used to update CircleMembers.
     */
    data: XOR<CircleMemberUpdateManyMutationInput, CircleMemberUncheckedUpdateManyInput>
    /**
     * Filter which CircleMembers to update
     */
    where?: CircleMemberWhereInput
    /**
     * Limit how many CircleMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CircleMember upsert
   */
  export type CircleMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleMember
     */
    select?: CircleMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleMember
     */
    omit?: CircleMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the CircleMember to update in case it exists.
     */
    where: CircleMemberWhereUniqueInput
    /**
     * In case the CircleMember found by the `where` argument doesn't exist, create a new CircleMember with this data.
     */
    create: XOR<CircleMemberCreateInput, CircleMemberUncheckedCreateInput>
    /**
     * In case the CircleMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CircleMemberUpdateInput, CircleMemberUncheckedUpdateInput>
  }

  /**
   * CircleMember delete
   */
  export type CircleMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleMember
     */
    select?: CircleMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleMember
     */
    omit?: CircleMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleMemberInclude<ExtArgs> | null
    /**
     * Filter which CircleMember to delete.
     */
    where: CircleMemberWhereUniqueInput
  }

  /**
   * CircleMember deleteMany
   */
  export type CircleMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CircleMembers to delete
     */
    where?: CircleMemberWhereInput
    /**
     * Limit how many CircleMembers to delete.
     */
    limit?: number
  }

  /**
   * CircleMember without action
   */
  export type CircleMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleMember
     */
    select?: CircleMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleMember
     */
    omit?: CircleMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleMemberInclude<ExtArgs> | null
  }


  /**
   * Model CircleProject
   */

  export type AggregateCircleProject = {
    _count: CircleProjectCountAggregateOutputType | null
    _avg: CircleProjectAvgAggregateOutputType | null
    _sum: CircleProjectSumAggregateOutputType | null
    _min: CircleProjectMinAggregateOutputType | null
    _max: CircleProjectMaxAggregateOutputType | null
  }

  export type CircleProjectAvgAggregateOutputType = {
    allocatedAmount: number | null
  }

  export type CircleProjectSumAggregateOutputType = {
    allocatedAmount: number | null
  }

  export type CircleProjectMinAggregateOutputType = {
    id: string | null
    circleId: string | null
    projectId: string | null
    allocatedAmount: number | null
    supportType: string | null
    votedAt: Date | null
    status: string | null
  }

  export type CircleProjectMaxAggregateOutputType = {
    id: string | null
    circleId: string | null
    projectId: string | null
    allocatedAmount: number | null
    supportType: string | null
    votedAt: Date | null
    status: string | null
  }

  export type CircleProjectCountAggregateOutputType = {
    id: number
    circleId: number
    projectId: number
    allocatedAmount: number
    supportType: number
    votedAt: number
    status: number
    _all: number
  }


  export type CircleProjectAvgAggregateInputType = {
    allocatedAmount?: true
  }

  export type CircleProjectSumAggregateInputType = {
    allocatedAmount?: true
  }

  export type CircleProjectMinAggregateInputType = {
    id?: true
    circleId?: true
    projectId?: true
    allocatedAmount?: true
    supportType?: true
    votedAt?: true
    status?: true
  }

  export type CircleProjectMaxAggregateInputType = {
    id?: true
    circleId?: true
    projectId?: true
    allocatedAmount?: true
    supportType?: true
    votedAt?: true
    status?: true
  }

  export type CircleProjectCountAggregateInputType = {
    id?: true
    circleId?: true
    projectId?: true
    allocatedAmount?: true
    supportType?: true
    votedAt?: true
    status?: true
    _all?: true
  }

  export type CircleProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CircleProject to aggregate.
     */
    where?: CircleProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CircleProjects to fetch.
     */
    orderBy?: CircleProjectOrderByWithRelationInput | CircleProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CircleProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CircleProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CircleProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CircleProjects
    **/
    _count?: true | CircleProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CircleProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CircleProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CircleProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CircleProjectMaxAggregateInputType
  }

  export type GetCircleProjectAggregateType<T extends CircleProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateCircleProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCircleProject[P]>
      : GetScalarType<T[P], AggregateCircleProject[P]>
  }




  export type CircleProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CircleProjectWhereInput
    orderBy?: CircleProjectOrderByWithAggregationInput | CircleProjectOrderByWithAggregationInput[]
    by: CircleProjectScalarFieldEnum[] | CircleProjectScalarFieldEnum
    having?: CircleProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CircleProjectCountAggregateInputType | true
    _avg?: CircleProjectAvgAggregateInputType
    _sum?: CircleProjectSumAggregateInputType
    _min?: CircleProjectMinAggregateInputType
    _max?: CircleProjectMaxAggregateInputType
  }

  export type CircleProjectGroupByOutputType = {
    id: string
    circleId: string
    projectId: string
    allocatedAmount: number
    supportType: string
    votedAt: Date | null
    status: string
    _count: CircleProjectCountAggregateOutputType | null
    _avg: CircleProjectAvgAggregateOutputType | null
    _sum: CircleProjectSumAggregateOutputType | null
    _min: CircleProjectMinAggregateOutputType | null
    _max: CircleProjectMaxAggregateOutputType | null
  }

  type GetCircleProjectGroupByPayload<T extends CircleProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CircleProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CircleProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CircleProjectGroupByOutputType[P]>
            : GetScalarType<T[P], CircleProjectGroupByOutputType[P]>
        }
      >
    >


  export type CircleProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    circleId?: boolean
    projectId?: boolean
    allocatedAmount?: boolean
    supportType?: boolean
    votedAt?: boolean
    status?: boolean
    circle?: boolean | CircleDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["circleProject"]>

  export type CircleProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    circleId?: boolean
    projectId?: boolean
    allocatedAmount?: boolean
    supportType?: boolean
    votedAt?: boolean
    status?: boolean
    circle?: boolean | CircleDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["circleProject"]>

  export type CircleProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    circleId?: boolean
    projectId?: boolean
    allocatedAmount?: boolean
    supportType?: boolean
    votedAt?: boolean
    status?: boolean
    circle?: boolean | CircleDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["circleProject"]>

  export type CircleProjectSelectScalar = {
    id?: boolean
    circleId?: boolean
    projectId?: boolean
    allocatedAmount?: boolean
    supportType?: boolean
    votedAt?: boolean
    status?: boolean
  }

  export type CircleProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "circleId" | "projectId" | "allocatedAmount" | "supportType" | "votedAt" | "status", ExtArgs["result"]["circleProject"]>
  export type CircleProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    circle?: boolean | CircleDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type CircleProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    circle?: boolean | CircleDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type CircleProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    circle?: boolean | CircleDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $CircleProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CircleProject"
    objects: {
      circle: Prisma.$CirclePayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      circleId: string
      projectId: string
      allocatedAmount: number
      supportType: string
      votedAt: Date | null
      status: string
    }, ExtArgs["result"]["circleProject"]>
    composites: {}
  }

  type CircleProjectGetPayload<S extends boolean | null | undefined | CircleProjectDefaultArgs> = $Result.GetResult<Prisma.$CircleProjectPayload, S>

  type CircleProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CircleProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CircleProjectCountAggregateInputType | true
    }

  export interface CircleProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CircleProject'], meta: { name: 'CircleProject' } }
    /**
     * Find zero or one CircleProject that matches the filter.
     * @param {CircleProjectFindUniqueArgs} args - Arguments to find a CircleProject
     * @example
     * // Get one CircleProject
     * const circleProject = await prisma.circleProject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CircleProjectFindUniqueArgs>(args: SelectSubset<T, CircleProjectFindUniqueArgs<ExtArgs>>): Prisma__CircleProjectClient<$Result.GetResult<Prisma.$CircleProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CircleProject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CircleProjectFindUniqueOrThrowArgs} args - Arguments to find a CircleProject
     * @example
     * // Get one CircleProject
     * const circleProject = await prisma.circleProject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CircleProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, CircleProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CircleProjectClient<$Result.GetResult<Prisma.$CircleProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CircleProject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleProjectFindFirstArgs} args - Arguments to find a CircleProject
     * @example
     * // Get one CircleProject
     * const circleProject = await prisma.circleProject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CircleProjectFindFirstArgs>(args?: SelectSubset<T, CircleProjectFindFirstArgs<ExtArgs>>): Prisma__CircleProjectClient<$Result.GetResult<Prisma.$CircleProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CircleProject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleProjectFindFirstOrThrowArgs} args - Arguments to find a CircleProject
     * @example
     * // Get one CircleProject
     * const circleProject = await prisma.circleProject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CircleProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, CircleProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__CircleProjectClient<$Result.GetResult<Prisma.$CircleProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CircleProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CircleProjects
     * const circleProjects = await prisma.circleProject.findMany()
     * 
     * // Get first 10 CircleProjects
     * const circleProjects = await prisma.circleProject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const circleProjectWithIdOnly = await prisma.circleProject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CircleProjectFindManyArgs>(args?: SelectSubset<T, CircleProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CircleProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CircleProject.
     * @param {CircleProjectCreateArgs} args - Arguments to create a CircleProject.
     * @example
     * // Create one CircleProject
     * const CircleProject = await prisma.circleProject.create({
     *   data: {
     *     // ... data to create a CircleProject
     *   }
     * })
     * 
     */
    create<T extends CircleProjectCreateArgs>(args: SelectSubset<T, CircleProjectCreateArgs<ExtArgs>>): Prisma__CircleProjectClient<$Result.GetResult<Prisma.$CircleProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CircleProjects.
     * @param {CircleProjectCreateManyArgs} args - Arguments to create many CircleProjects.
     * @example
     * // Create many CircleProjects
     * const circleProject = await prisma.circleProject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CircleProjectCreateManyArgs>(args?: SelectSubset<T, CircleProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CircleProjects and returns the data saved in the database.
     * @param {CircleProjectCreateManyAndReturnArgs} args - Arguments to create many CircleProjects.
     * @example
     * // Create many CircleProjects
     * const circleProject = await prisma.circleProject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CircleProjects and only return the `id`
     * const circleProjectWithIdOnly = await prisma.circleProject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CircleProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, CircleProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CircleProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CircleProject.
     * @param {CircleProjectDeleteArgs} args - Arguments to delete one CircleProject.
     * @example
     * // Delete one CircleProject
     * const CircleProject = await prisma.circleProject.delete({
     *   where: {
     *     // ... filter to delete one CircleProject
     *   }
     * })
     * 
     */
    delete<T extends CircleProjectDeleteArgs>(args: SelectSubset<T, CircleProjectDeleteArgs<ExtArgs>>): Prisma__CircleProjectClient<$Result.GetResult<Prisma.$CircleProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CircleProject.
     * @param {CircleProjectUpdateArgs} args - Arguments to update one CircleProject.
     * @example
     * // Update one CircleProject
     * const circleProject = await prisma.circleProject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CircleProjectUpdateArgs>(args: SelectSubset<T, CircleProjectUpdateArgs<ExtArgs>>): Prisma__CircleProjectClient<$Result.GetResult<Prisma.$CircleProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CircleProjects.
     * @param {CircleProjectDeleteManyArgs} args - Arguments to filter CircleProjects to delete.
     * @example
     * // Delete a few CircleProjects
     * const { count } = await prisma.circleProject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CircleProjectDeleteManyArgs>(args?: SelectSubset<T, CircleProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CircleProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CircleProjects
     * const circleProject = await prisma.circleProject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CircleProjectUpdateManyArgs>(args: SelectSubset<T, CircleProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CircleProjects and returns the data updated in the database.
     * @param {CircleProjectUpdateManyAndReturnArgs} args - Arguments to update many CircleProjects.
     * @example
     * // Update many CircleProjects
     * const circleProject = await prisma.circleProject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CircleProjects and only return the `id`
     * const circleProjectWithIdOnly = await prisma.circleProject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CircleProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, CircleProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CircleProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CircleProject.
     * @param {CircleProjectUpsertArgs} args - Arguments to update or create a CircleProject.
     * @example
     * // Update or create a CircleProject
     * const circleProject = await prisma.circleProject.upsert({
     *   create: {
     *     // ... data to create a CircleProject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CircleProject we want to update
     *   }
     * })
     */
    upsert<T extends CircleProjectUpsertArgs>(args: SelectSubset<T, CircleProjectUpsertArgs<ExtArgs>>): Prisma__CircleProjectClient<$Result.GetResult<Prisma.$CircleProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CircleProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleProjectCountArgs} args - Arguments to filter CircleProjects to count.
     * @example
     * // Count the number of CircleProjects
     * const count = await prisma.circleProject.count({
     *   where: {
     *     // ... the filter for the CircleProjects we want to count
     *   }
     * })
    **/
    count<T extends CircleProjectCountArgs>(
      args?: Subset<T, CircleProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CircleProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CircleProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CircleProjectAggregateArgs>(args: Subset<T, CircleProjectAggregateArgs>): Prisma.PrismaPromise<GetCircleProjectAggregateType<T>>

    /**
     * Group by CircleProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CircleProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CircleProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CircleProjectGroupByArgs['orderBy'] }
        : { orderBy?: CircleProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CircleProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCircleProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CircleProject model
   */
  readonly fields: CircleProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CircleProject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CircleProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    circle<T extends CircleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CircleDefaultArgs<ExtArgs>>): Prisma__CircleClient<$Result.GetResult<Prisma.$CirclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CircleProject model
   */
  interface CircleProjectFieldRefs {
    readonly id: FieldRef<"CircleProject", 'String'>
    readonly circleId: FieldRef<"CircleProject", 'String'>
    readonly projectId: FieldRef<"CircleProject", 'String'>
    readonly allocatedAmount: FieldRef<"CircleProject", 'Float'>
    readonly supportType: FieldRef<"CircleProject", 'String'>
    readonly votedAt: FieldRef<"CircleProject", 'DateTime'>
    readonly status: FieldRef<"CircleProject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CircleProject findUnique
   */
  export type CircleProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleProject
     */
    select?: CircleProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleProject
     */
    omit?: CircleProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleProjectInclude<ExtArgs> | null
    /**
     * Filter, which CircleProject to fetch.
     */
    where: CircleProjectWhereUniqueInput
  }

  /**
   * CircleProject findUniqueOrThrow
   */
  export type CircleProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleProject
     */
    select?: CircleProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleProject
     */
    omit?: CircleProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleProjectInclude<ExtArgs> | null
    /**
     * Filter, which CircleProject to fetch.
     */
    where: CircleProjectWhereUniqueInput
  }

  /**
   * CircleProject findFirst
   */
  export type CircleProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleProject
     */
    select?: CircleProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleProject
     */
    omit?: CircleProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleProjectInclude<ExtArgs> | null
    /**
     * Filter, which CircleProject to fetch.
     */
    where?: CircleProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CircleProjects to fetch.
     */
    orderBy?: CircleProjectOrderByWithRelationInput | CircleProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CircleProjects.
     */
    cursor?: CircleProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CircleProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CircleProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CircleProjects.
     */
    distinct?: CircleProjectScalarFieldEnum | CircleProjectScalarFieldEnum[]
  }

  /**
   * CircleProject findFirstOrThrow
   */
  export type CircleProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleProject
     */
    select?: CircleProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleProject
     */
    omit?: CircleProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleProjectInclude<ExtArgs> | null
    /**
     * Filter, which CircleProject to fetch.
     */
    where?: CircleProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CircleProjects to fetch.
     */
    orderBy?: CircleProjectOrderByWithRelationInput | CircleProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CircleProjects.
     */
    cursor?: CircleProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CircleProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CircleProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CircleProjects.
     */
    distinct?: CircleProjectScalarFieldEnum | CircleProjectScalarFieldEnum[]
  }

  /**
   * CircleProject findMany
   */
  export type CircleProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleProject
     */
    select?: CircleProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleProject
     */
    omit?: CircleProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleProjectInclude<ExtArgs> | null
    /**
     * Filter, which CircleProjects to fetch.
     */
    where?: CircleProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CircleProjects to fetch.
     */
    orderBy?: CircleProjectOrderByWithRelationInput | CircleProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CircleProjects.
     */
    cursor?: CircleProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CircleProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CircleProjects.
     */
    skip?: number
    distinct?: CircleProjectScalarFieldEnum | CircleProjectScalarFieldEnum[]
  }

  /**
   * CircleProject create
   */
  export type CircleProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleProject
     */
    select?: CircleProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleProject
     */
    omit?: CircleProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a CircleProject.
     */
    data: XOR<CircleProjectCreateInput, CircleProjectUncheckedCreateInput>
  }

  /**
   * CircleProject createMany
   */
  export type CircleProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CircleProjects.
     */
    data: CircleProjectCreateManyInput | CircleProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CircleProject createManyAndReturn
   */
  export type CircleProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleProject
     */
    select?: CircleProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CircleProject
     */
    omit?: CircleProjectOmit<ExtArgs> | null
    /**
     * The data used to create many CircleProjects.
     */
    data: CircleProjectCreateManyInput | CircleProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CircleProject update
   */
  export type CircleProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleProject
     */
    select?: CircleProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleProject
     */
    omit?: CircleProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a CircleProject.
     */
    data: XOR<CircleProjectUpdateInput, CircleProjectUncheckedUpdateInput>
    /**
     * Choose, which CircleProject to update.
     */
    where: CircleProjectWhereUniqueInput
  }

  /**
   * CircleProject updateMany
   */
  export type CircleProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CircleProjects.
     */
    data: XOR<CircleProjectUpdateManyMutationInput, CircleProjectUncheckedUpdateManyInput>
    /**
     * Filter which CircleProjects to update
     */
    where?: CircleProjectWhereInput
    /**
     * Limit how many CircleProjects to update.
     */
    limit?: number
  }

  /**
   * CircleProject updateManyAndReturn
   */
  export type CircleProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleProject
     */
    select?: CircleProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CircleProject
     */
    omit?: CircleProjectOmit<ExtArgs> | null
    /**
     * The data used to update CircleProjects.
     */
    data: XOR<CircleProjectUpdateManyMutationInput, CircleProjectUncheckedUpdateManyInput>
    /**
     * Filter which CircleProjects to update
     */
    where?: CircleProjectWhereInput
    /**
     * Limit how many CircleProjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CircleProject upsert
   */
  export type CircleProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleProject
     */
    select?: CircleProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleProject
     */
    omit?: CircleProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the CircleProject to update in case it exists.
     */
    where: CircleProjectWhereUniqueInput
    /**
     * In case the CircleProject found by the `where` argument doesn't exist, create a new CircleProject with this data.
     */
    create: XOR<CircleProjectCreateInput, CircleProjectUncheckedCreateInput>
    /**
     * In case the CircleProject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CircleProjectUpdateInput, CircleProjectUncheckedUpdateInput>
  }

  /**
   * CircleProject delete
   */
  export type CircleProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleProject
     */
    select?: CircleProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleProject
     */
    omit?: CircleProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleProjectInclude<ExtArgs> | null
    /**
     * Filter which CircleProject to delete.
     */
    where: CircleProjectWhereUniqueInput
  }

  /**
   * CircleProject deleteMany
   */
  export type CircleProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CircleProjects to delete
     */
    where?: CircleProjectWhereInput
    /**
     * Limit how many CircleProjects to delete.
     */
    limit?: number
  }

  /**
   * CircleProject without action
   */
  export type CircleProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CircleProject
     */
    select?: CircleProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CircleProject
     */
    omit?: CircleProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleProjectInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    amount: number | null
    currency: string | null
    status: string | null
    description: string | null
    projectId: string | null
    circleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    amount: number | null
    currency: string | null
    status: string | null
    description: string | null
    projectId: string | null
    circleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    amount: number
    currency: number
    status: number
    description: number
    projectId: number
    circleId: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    currency?: true
    status?: true
    description?: true
    projectId?: true
    circleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    currency?: true
    status?: true
    description?: true
    projectId?: true
    circleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    currency?: true
    status?: true
    description?: true
    projectId?: true
    circleId?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    userId: string
    type: string
    amount: number
    currency: string
    status: string
    description: string | null
    projectId: string | null
    circleId: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    description?: boolean
    projectId?: boolean
    circleId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Transaction$projectArgs<ExtArgs>
    circle?: boolean | Transaction$circleArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    description?: boolean
    projectId?: boolean
    circleId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Transaction$projectArgs<ExtArgs>
    circle?: boolean | Transaction$circleArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    description?: boolean
    projectId?: boolean
    circleId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Transaction$projectArgs<ExtArgs>
    circle?: boolean | Transaction$circleArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    description?: boolean
    projectId?: boolean
    circleId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "amount" | "currency" | "status" | "description" | "projectId" | "circleId" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Transaction$projectArgs<ExtArgs>
    circle?: boolean | Transaction$circleArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Transaction$projectArgs<ExtArgs>
    circle?: boolean | Transaction$circleArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | Transaction$projectArgs<ExtArgs>
    circle?: boolean | Transaction$circleArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
      circle: Prisma.$CirclePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      amount: number
      currency: string
      status: string
      description: string | null
      projectId: string | null
      circleId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends Transaction$projectArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    circle<T extends Transaction$circleArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$circleArgs<ExtArgs>>): Prisma__CircleClient<$Result.GetResult<Prisma.$CirclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly userId: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly currency: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly projectId: FieldRef<"Transaction", 'String'>
    readonly circleId: FieldRef<"Transaction", 'String'>
    readonly metadata: FieldRef<"Transaction", 'Json'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.project
   */
  export type Transaction$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Transaction.circle
   */
  export type Transaction$circleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circle
     */
    select?: CircleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circle
     */
    omit?: CircleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CircleInclude<ExtArgs> | null
    where?: CircleWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model UserXP
   */

  export type AggregateUserXP = {
    _count: UserXPCountAggregateOutputType | null
    _avg: UserXPAvgAggregateOutputType | null
    _sum: UserXPSumAggregateOutputType | null
    _min: UserXPMinAggregateOutputType | null
    _max: UserXPMaxAggregateOutputType | null
  }

  export type UserXPAvgAggregateOutputType = {
    totalXP: number | null
    level: number | null
    donationXP: number | null
    investmentXP: number | null
    contentXP: number | null
    communityXP: number | null
  }

  export type UserXPSumAggregateOutputType = {
    totalXP: number | null
    level: number | null
    donationXP: number | null
    investmentXP: number | null
    contentXP: number | null
    communityXP: number | null
  }

  export type UserXPMinAggregateOutputType = {
    id: string | null
    userId: string | null
    totalXP: number | null
    level: number | null
    impactRank: string | null
    donationXP: number | null
    investmentXP: number | null
    contentXP: number | null
    communityXP: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserXPMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    totalXP: number | null
    level: number | null
    impactRank: string | null
    donationXP: number | null
    investmentXP: number | null
    contentXP: number | null
    communityXP: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserXPCountAggregateOutputType = {
    id: number
    userId: number
    totalXP: number
    level: number
    impactRank: number
    donationXP: number
    investmentXP: number
    contentXP: number
    communityXP: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserXPAvgAggregateInputType = {
    totalXP?: true
    level?: true
    donationXP?: true
    investmentXP?: true
    contentXP?: true
    communityXP?: true
  }

  export type UserXPSumAggregateInputType = {
    totalXP?: true
    level?: true
    donationXP?: true
    investmentXP?: true
    contentXP?: true
    communityXP?: true
  }

  export type UserXPMinAggregateInputType = {
    id?: true
    userId?: true
    totalXP?: true
    level?: true
    impactRank?: true
    donationXP?: true
    investmentXP?: true
    contentXP?: true
    communityXP?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserXPMaxAggregateInputType = {
    id?: true
    userId?: true
    totalXP?: true
    level?: true
    impactRank?: true
    donationXP?: true
    investmentXP?: true
    contentXP?: true
    communityXP?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserXPCountAggregateInputType = {
    id?: true
    userId?: true
    totalXP?: true
    level?: true
    impactRank?: true
    donationXP?: true
    investmentXP?: true
    contentXP?: true
    communityXP?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserXPAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserXP to aggregate.
     */
    where?: UserXPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserXPS to fetch.
     */
    orderBy?: UserXPOrderByWithRelationInput | UserXPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserXPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserXPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserXPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserXPS
    **/
    _count?: true | UserXPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserXPAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserXPSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserXPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserXPMaxAggregateInputType
  }

  export type GetUserXPAggregateType<T extends UserXPAggregateArgs> = {
        [P in keyof T & keyof AggregateUserXP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserXP[P]>
      : GetScalarType<T[P], AggregateUserXP[P]>
  }




  export type UserXPGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserXPWhereInput
    orderBy?: UserXPOrderByWithAggregationInput | UserXPOrderByWithAggregationInput[]
    by: UserXPScalarFieldEnum[] | UserXPScalarFieldEnum
    having?: UserXPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserXPCountAggregateInputType | true
    _avg?: UserXPAvgAggregateInputType
    _sum?: UserXPSumAggregateInputType
    _min?: UserXPMinAggregateInputType
    _max?: UserXPMaxAggregateInputType
  }

  export type UserXPGroupByOutputType = {
    id: string
    userId: string
    totalXP: number
    level: number
    impactRank: string | null
    donationXP: number
    investmentXP: number
    contentXP: number
    communityXP: number
    createdAt: Date
    updatedAt: Date
    _count: UserXPCountAggregateOutputType | null
    _avg: UserXPAvgAggregateOutputType | null
    _sum: UserXPSumAggregateOutputType | null
    _min: UserXPMinAggregateOutputType | null
    _max: UserXPMaxAggregateOutputType | null
  }

  type GetUserXPGroupByPayload<T extends UserXPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserXPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserXPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserXPGroupByOutputType[P]>
            : GetScalarType<T[P], UserXPGroupByOutputType[P]>
        }
      >
    >


  export type UserXPSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalXP?: boolean
    level?: boolean
    impactRank?: boolean
    donationXP?: boolean
    investmentXP?: boolean
    contentXP?: boolean
    communityXP?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userXP"]>

  export type UserXPSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalXP?: boolean
    level?: boolean
    impactRank?: boolean
    donationXP?: boolean
    investmentXP?: boolean
    contentXP?: boolean
    communityXP?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userXP"]>

  export type UserXPSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalXP?: boolean
    level?: boolean
    impactRank?: boolean
    donationXP?: boolean
    investmentXP?: boolean
    contentXP?: boolean
    communityXP?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userXP"]>

  export type UserXPSelectScalar = {
    id?: boolean
    userId?: boolean
    totalXP?: boolean
    level?: boolean
    impactRank?: boolean
    donationXP?: boolean
    investmentXP?: boolean
    contentXP?: boolean
    communityXP?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserXPOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "totalXP" | "level" | "impactRank" | "donationXP" | "investmentXP" | "contentXP" | "communityXP" | "createdAt" | "updatedAt", ExtArgs["result"]["userXP"]>
  export type UserXPInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserXPIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserXPIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserXPPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserXP"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      totalXP: number
      level: number
      impactRank: string | null
      donationXP: number
      investmentXP: number
      contentXP: number
      communityXP: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userXP"]>
    composites: {}
  }

  type UserXPGetPayload<S extends boolean | null | undefined | UserXPDefaultArgs> = $Result.GetResult<Prisma.$UserXPPayload, S>

  type UserXPCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserXPFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserXPCountAggregateInputType | true
    }

  export interface UserXPDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserXP'], meta: { name: 'UserXP' } }
    /**
     * Find zero or one UserXP that matches the filter.
     * @param {UserXPFindUniqueArgs} args - Arguments to find a UserXP
     * @example
     * // Get one UserXP
     * const userXP = await prisma.userXP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserXPFindUniqueArgs>(args: SelectSubset<T, UserXPFindUniqueArgs<ExtArgs>>): Prisma__UserXPClient<$Result.GetResult<Prisma.$UserXPPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserXP that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserXPFindUniqueOrThrowArgs} args - Arguments to find a UserXP
     * @example
     * // Get one UserXP
     * const userXP = await prisma.userXP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserXPFindUniqueOrThrowArgs>(args: SelectSubset<T, UserXPFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserXPClient<$Result.GetResult<Prisma.$UserXPPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserXP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserXPFindFirstArgs} args - Arguments to find a UserXP
     * @example
     * // Get one UserXP
     * const userXP = await prisma.userXP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserXPFindFirstArgs>(args?: SelectSubset<T, UserXPFindFirstArgs<ExtArgs>>): Prisma__UserXPClient<$Result.GetResult<Prisma.$UserXPPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserXP that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserXPFindFirstOrThrowArgs} args - Arguments to find a UserXP
     * @example
     * // Get one UserXP
     * const userXP = await prisma.userXP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserXPFindFirstOrThrowArgs>(args?: SelectSubset<T, UserXPFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserXPClient<$Result.GetResult<Prisma.$UserXPPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserXPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserXPFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserXPS
     * const userXPS = await prisma.userXP.findMany()
     * 
     * // Get first 10 UserXPS
     * const userXPS = await prisma.userXP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userXPWithIdOnly = await prisma.userXP.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserXPFindManyArgs>(args?: SelectSubset<T, UserXPFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserXPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserXP.
     * @param {UserXPCreateArgs} args - Arguments to create a UserXP.
     * @example
     * // Create one UserXP
     * const UserXP = await prisma.userXP.create({
     *   data: {
     *     // ... data to create a UserXP
     *   }
     * })
     * 
     */
    create<T extends UserXPCreateArgs>(args: SelectSubset<T, UserXPCreateArgs<ExtArgs>>): Prisma__UserXPClient<$Result.GetResult<Prisma.$UserXPPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserXPS.
     * @param {UserXPCreateManyArgs} args - Arguments to create many UserXPS.
     * @example
     * // Create many UserXPS
     * const userXP = await prisma.userXP.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserXPCreateManyArgs>(args?: SelectSubset<T, UserXPCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserXPS and returns the data saved in the database.
     * @param {UserXPCreateManyAndReturnArgs} args - Arguments to create many UserXPS.
     * @example
     * // Create many UserXPS
     * const userXP = await prisma.userXP.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserXPS and only return the `id`
     * const userXPWithIdOnly = await prisma.userXP.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserXPCreateManyAndReturnArgs>(args?: SelectSubset<T, UserXPCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserXPPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserXP.
     * @param {UserXPDeleteArgs} args - Arguments to delete one UserXP.
     * @example
     * // Delete one UserXP
     * const UserXP = await prisma.userXP.delete({
     *   where: {
     *     // ... filter to delete one UserXP
     *   }
     * })
     * 
     */
    delete<T extends UserXPDeleteArgs>(args: SelectSubset<T, UserXPDeleteArgs<ExtArgs>>): Prisma__UserXPClient<$Result.GetResult<Prisma.$UserXPPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserXP.
     * @param {UserXPUpdateArgs} args - Arguments to update one UserXP.
     * @example
     * // Update one UserXP
     * const userXP = await prisma.userXP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserXPUpdateArgs>(args: SelectSubset<T, UserXPUpdateArgs<ExtArgs>>): Prisma__UserXPClient<$Result.GetResult<Prisma.$UserXPPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserXPS.
     * @param {UserXPDeleteManyArgs} args - Arguments to filter UserXPS to delete.
     * @example
     * // Delete a few UserXPS
     * const { count } = await prisma.userXP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserXPDeleteManyArgs>(args?: SelectSubset<T, UserXPDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserXPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserXPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserXPS
     * const userXP = await prisma.userXP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserXPUpdateManyArgs>(args: SelectSubset<T, UserXPUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserXPS and returns the data updated in the database.
     * @param {UserXPUpdateManyAndReturnArgs} args - Arguments to update many UserXPS.
     * @example
     * // Update many UserXPS
     * const userXP = await prisma.userXP.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserXPS and only return the `id`
     * const userXPWithIdOnly = await prisma.userXP.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserXPUpdateManyAndReturnArgs>(args: SelectSubset<T, UserXPUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserXPPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserXP.
     * @param {UserXPUpsertArgs} args - Arguments to update or create a UserXP.
     * @example
     * // Update or create a UserXP
     * const userXP = await prisma.userXP.upsert({
     *   create: {
     *     // ... data to create a UserXP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserXP we want to update
     *   }
     * })
     */
    upsert<T extends UserXPUpsertArgs>(args: SelectSubset<T, UserXPUpsertArgs<ExtArgs>>): Prisma__UserXPClient<$Result.GetResult<Prisma.$UserXPPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserXPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserXPCountArgs} args - Arguments to filter UserXPS to count.
     * @example
     * // Count the number of UserXPS
     * const count = await prisma.userXP.count({
     *   where: {
     *     // ... the filter for the UserXPS we want to count
     *   }
     * })
    **/
    count<T extends UserXPCountArgs>(
      args?: Subset<T, UserXPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserXPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserXP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserXPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserXPAggregateArgs>(args: Subset<T, UserXPAggregateArgs>): Prisma.PrismaPromise<GetUserXPAggregateType<T>>

    /**
     * Group by UserXP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserXPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserXPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserXPGroupByArgs['orderBy'] }
        : { orderBy?: UserXPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserXPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserXPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserXP model
   */
  readonly fields: UserXPFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserXP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserXPClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserXP model
   */
  interface UserXPFieldRefs {
    readonly id: FieldRef<"UserXP", 'String'>
    readonly userId: FieldRef<"UserXP", 'String'>
    readonly totalXP: FieldRef<"UserXP", 'Int'>
    readonly level: FieldRef<"UserXP", 'Int'>
    readonly impactRank: FieldRef<"UserXP", 'String'>
    readonly donationXP: FieldRef<"UserXP", 'Int'>
    readonly investmentXP: FieldRef<"UserXP", 'Int'>
    readonly contentXP: FieldRef<"UserXP", 'Int'>
    readonly communityXP: FieldRef<"UserXP", 'Int'>
    readonly createdAt: FieldRef<"UserXP", 'DateTime'>
    readonly updatedAt: FieldRef<"UserXP", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserXP findUnique
   */
  export type UserXPFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserXP
     */
    select?: UserXPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserXP
     */
    omit?: UserXPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserXPInclude<ExtArgs> | null
    /**
     * Filter, which UserXP to fetch.
     */
    where: UserXPWhereUniqueInput
  }

  /**
   * UserXP findUniqueOrThrow
   */
  export type UserXPFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserXP
     */
    select?: UserXPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserXP
     */
    omit?: UserXPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserXPInclude<ExtArgs> | null
    /**
     * Filter, which UserXP to fetch.
     */
    where: UserXPWhereUniqueInput
  }

  /**
   * UserXP findFirst
   */
  export type UserXPFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserXP
     */
    select?: UserXPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserXP
     */
    omit?: UserXPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserXPInclude<ExtArgs> | null
    /**
     * Filter, which UserXP to fetch.
     */
    where?: UserXPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserXPS to fetch.
     */
    orderBy?: UserXPOrderByWithRelationInput | UserXPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserXPS.
     */
    cursor?: UserXPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserXPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserXPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserXPS.
     */
    distinct?: UserXPScalarFieldEnum | UserXPScalarFieldEnum[]
  }

  /**
   * UserXP findFirstOrThrow
   */
  export type UserXPFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserXP
     */
    select?: UserXPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserXP
     */
    omit?: UserXPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserXPInclude<ExtArgs> | null
    /**
     * Filter, which UserXP to fetch.
     */
    where?: UserXPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserXPS to fetch.
     */
    orderBy?: UserXPOrderByWithRelationInput | UserXPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserXPS.
     */
    cursor?: UserXPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserXPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserXPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserXPS.
     */
    distinct?: UserXPScalarFieldEnum | UserXPScalarFieldEnum[]
  }

  /**
   * UserXP findMany
   */
  export type UserXPFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserXP
     */
    select?: UserXPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserXP
     */
    omit?: UserXPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserXPInclude<ExtArgs> | null
    /**
     * Filter, which UserXPS to fetch.
     */
    where?: UserXPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserXPS to fetch.
     */
    orderBy?: UserXPOrderByWithRelationInput | UserXPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserXPS.
     */
    cursor?: UserXPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserXPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserXPS.
     */
    skip?: number
    distinct?: UserXPScalarFieldEnum | UserXPScalarFieldEnum[]
  }

  /**
   * UserXP create
   */
  export type UserXPCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserXP
     */
    select?: UserXPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserXP
     */
    omit?: UserXPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserXPInclude<ExtArgs> | null
    /**
     * The data needed to create a UserXP.
     */
    data: XOR<UserXPCreateInput, UserXPUncheckedCreateInput>
  }

  /**
   * UserXP createMany
   */
  export type UserXPCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserXPS.
     */
    data: UserXPCreateManyInput | UserXPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserXP createManyAndReturn
   */
  export type UserXPCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserXP
     */
    select?: UserXPSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserXP
     */
    omit?: UserXPOmit<ExtArgs> | null
    /**
     * The data used to create many UserXPS.
     */
    data: UserXPCreateManyInput | UserXPCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserXPIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserXP update
   */
  export type UserXPUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserXP
     */
    select?: UserXPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserXP
     */
    omit?: UserXPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserXPInclude<ExtArgs> | null
    /**
     * The data needed to update a UserXP.
     */
    data: XOR<UserXPUpdateInput, UserXPUncheckedUpdateInput>
    /**
     * Choose, which UserXP to update.
     */
    where: UserXPWhereUniqueInput
  }

  /**
   * UserXP updateMany
   */
  export type UserXPUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserXPS.
     */
    data: XOR<UserXPUpdateManyMutationInput, UserXPUncheckedUpdateManyInput>
    /**
     * Filter which UserXPS to update
     */
    where?: UserXPWhereInput
    /**
     * Limit how many UserXPS to update.
     */
    limit?: number
  }

  /**
   * UserXP updateManyAndReturn
   */
  export type UserXPUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserXP
     */
    select?: UserXPSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserXP
     */
    omit?: UserXPOmit<ExtArgs> | null
    /**
     * The data used to update UserXPS.
     */
    data: XOR<UserXPUpdateManyMutationInput, UserXPUncheckedUpdateManyInput>
    /**
     * Filter which UserXPS to update
     */
    where?: UserXPWhereInput
    /**
     * Limit how many UserXPS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserXPIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserXP upsert
   */
  export type UserXPUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserXP
     */
    select?: UserXPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserXP
     */
    omit?: UserXPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserXPInclude<ExtArgs> | null
    /**
     * The filter to search for the UserXP to update in case it exists.
     */
    where: UserXPWhereUniqueInput
    /**
     * In case the UserXP found by the `where` argument doesn't exist, create a new UserXP with this data.
     */
    create: XOR<UserXPCreateInput, UserXPUncheckedCreateInput>
    /**
     * In case the UserXP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserXPUpdateInput, UserXPUncheckedUpdateInput>
  }

  /**
   * UserXP delete
   */
  export type UserXPDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserXP
     */
    select?: UserXPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserXP
     */
    omit?: UserXPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserXPInclude<ExtArgs> | null
    /**
     * Filter which UserXP to delete.
     */
    where: UserXPWhereUniqueInput
  }

  /**
   * UserXP deleteMany
   */
  export type UserXPDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserXPS to delete
     */
    where?: UserXPWhereInput
    /**
     * Limit how many UserXPS to delete.
     */
    limit?: number
  }

  /**
   * UserXP without action
   */
  export type UserXPDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserXP
     */
    select?: UserXPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserXP
     */
    omit?: UserXPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserXPInclude<ExtArgs> | null
  }


  /**
   * Model Badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    createdAt: Date | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    createdAt: Date | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    image: number
    criteria: number
    createdAt: number
    _all: number
  }


  export type BadgeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    createdAt?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    createdAt?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    criteria?: true
    createdAt?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badge to aggregate.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type BadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithAggregationInput | BadgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: BadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    image: string | null
    criteria: JsonValue | null
    createdAt: Date
    _count: BadgeCountAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    criteria?: boolean
    createdAt?: boolean
    users?: boolean | Badge$usersArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    criteria?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    criteria?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    criteria?: boolean
    createdAt?: boolean
  }

  export type BadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "image" | "criteria" | "createdAt", ExtArgs["result"]["badge"]>
  export type BadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Badge$usersArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Badge"
    objects: {
      users: Prisma.$UserBadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      image: string | null
      criteria: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<Prisma.$BadgePayload, S>

  type BadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface BadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badge'], meta: { name: 'Badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeFindUniqueArgs>(args: SelectSubset<T, BadgeFindUniqueArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BadgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeFindFirstArgs>(args?: SelectSubset<T, BadgeFindFirstArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeFindManyArgs>(args?: SelectSubset<T, BadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends BadgeCreateArgs>(args: SelectSubset<T, BadgeCreateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Badges.
     * @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeCreateManyArgs>(args?: SelectSubset<T, BadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {BadgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends BadgeDeleteArgs>(args: SelectSubset<T, BadgeDeleteArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeUpdateArgs>(args: SelectSubset<T, BadgeUpdateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeDeleteManyArgs>(args?: SelectSubset<T, BadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeUpdateManyArgs>(args: SelectSubset<T, BadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges and returns the data updated in the database.
     * @param {BadgeUpdateManyAndReturnArgs} args - Arguments to update many Badges.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, BadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends BadgeUpsertArgs>(args: SelectSubset<T, BadgeUpsertArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Badge model
   */
  readonly fields: BadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Badge$usersArgs<ExtArgs> = {}>(args?: Subset<T, Badge$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Badge model
   */
  interface BadgeFieldRefs {
    readonly id: FieldRef<"Badge", 'String'>
    readonly name: FieldRef<"Badge", 'String'>
    readonly description: FieldRef<"Badge", 'String'>
    readonly image: FieldRef<"Badge", 'String'>
    readonly criteria: FieldRef<"Badge", 'Json'>
    readonly createdAt: FieldRef<"Badge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findUniqueOrThrow
   */
  export type BadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findFirstOrThrow
   */
  export type BadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge create
   */
  export type BadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Badge.
     */
    data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
  }

  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge createManyAndReturn
   */
  export type BadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge update
   */
  export type BadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Badge.
     */
    data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    /**
     * Choose, which Badge to update.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
  }

  /**
   * Badge updateManyAndReturn
   */
  export type BadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
  }

  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Badge to update in case it exists.
     */
    where: BadgeWhereUniqueInput
    /**
     * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
     */
    create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    /**
     * In case the Badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
  }

  /**
   * Badge delete
   */
  export type BadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter which Badge to delete.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to delete.
     */
    limit?: number
  }

  /**
   * Badge.users
   */
  export type Badge$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    cursor?: UserBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
  }


  /**
   * Model UserBadge
   */

  export type AggregateUserBadge = {
    _count: UserBadgeCountAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  export type UserBadgeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    badgeId: string | null
    earnedAt: Date | null
  }

  export type UserBadgeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    badgeId: string | null
    earnedAt: Date | null
  }

  export type UserBadgeCountAggregateOutputType = {
    id: number
    userId: number
    badgeId: number
    earnedAt: number
    _all: number
  }


  export type UserBadgeMinAggregateInputType = {
    id?: true
    userId?: true
    badgeId?: true
    earnedAt?: true
  }

  export type UserBadgeMaxAggregateInputType = {
    id?: true
    userId?: true
    badgeId?: true
    earnedAt?: true
  }

  export type UserBadgeCountAggregateInputType = {
    id?: true
    userId?: true
    badgeId?: true
    earnedAt?: true
    _all?: true
  }

  export type UserBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadge to aggregate.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBadges
    **/
    _count?: true | UserBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBadgeMaxAggregateInputType
  }

  export type GetUserBadgeAggregateType<T extends UserBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBadge[P]>
      : GetScalarType<T[P], AggregateUserBadge[P]>
  }




  export type UserBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithAggregationInput | UserBadgeOrderByWithAggregationInput[]
    by: UserBadgeScalarFieldEnum[] | UserBadgeScalarFieldEnum
    having?: UserBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBadgeCountAggregateInputType | true
    _min?: UserBadgeMinAggregateInputType
    _max?: UserBadgeMaxAggregateInputType
  }

  export type UserBadgeGroupByOutputType = {
    id: string
    userId: string
    badgeId: string
    earnedAt: Date
    _count: UserBadgeCountAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  type GetUserBadgeGroupByPayload<T extends UserBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
        }
      >
    >


  export type UserBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    earnedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    earnedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    earnedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectScalar = {
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    earnedAt?: boolean
  }

  export type UserBadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "badgeId" | "earnedAt", ExtArgs["result"]["userBadge"]>
  export type UserBadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }
  export type UserBadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }
  export type UserBadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }

  export type $UserBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBadge"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      badge: Prisma.$BadgePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      badgeId: string
      earnedAt: Date
    }, ExtArgs["result"]["userBadge"]>
    composites: {}
  }

  type UserBadgeGetPayload<S extends boolean | null | undefined | UserBadgeDefaultArgs> = $Result.GetResult<Prisma.$UserBadgePayload, S>

  type UserBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserBadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserBadgeCountAggregateInputType | true
    }

  export interface UserBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBadge'], meta: { name: 'UserBadge' } }
    /**
     * Find zero or one UserBadge that matches the filter.
     * @param {UserBadgeFindUniqueArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBadgeFindUniqueArgs>(args: SelectSubset<T, UserBadgeFindUniqueArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserBadge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserBadgeFindUniqueOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBadgeFindFirstArgs>(args?: SelectSubset<T, UserBadgeFindFirstArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBadges
     * const userBadges = await prisma.userBadge.findMany()
     * 
     * // Get first 10 UserBadges
     * const userBadges = await prisma.userBadge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBadgeWithIdOnly = await prisma.userBadge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBadgeFindManyArgs>(args?: SelectSubset<T, UserBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserBadge.
     * @param {UserBadgeCreateArgs} args - Arguments to create a UserBadge.
     * @example
     * // Create one UserBadge
     * const UserBadge = await prisma.userBadge.create({
     *   data: {
     *     // ... data to create a UserBadge
     *   }
     * })
     * 
     */
    create<T extends UserBadgeCreateArgs>(args: SelectSubset<T, UserBadgeCreateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserBadges.
     * @param {UserBadgeCreateManyArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBadgeCreateManyArgs>(args?: SelectSubset<T, UserBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBadges and returns the data saved in the database.
     * @param {UserBadgeCreateManyAndReturnArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBadges and only return the `id`
     * const userBadgeWithIdOnly = await prisma.userBadge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserBadge.
     * @param {UserBadgeDeleteArgs} args - Arguments to delete one UserBadge.
     * @example
     * // Delete one UserBadge
     * const UserBadge = await prisma.userBadge.delete({
     *   where: {
     *     // ... filter to delete one UserBadge
     *   }
     * })
     * 
     */
    delete<T extends UserBadgeDeleteArgs>(args: SelectSubset<T, UserBadgeDeleteArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserBadge.
     * @param {UserBadgeUpdateArgs} args - Arguments to update one UserBadge.
     * @example
     * // Update one UserBadge
     * const userBadge = await prisma.userBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBadgeUpdateArgs>(args: SelectSubset<T, UserBadgeUpdateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserBadges.
     * @param {UserBadgeDeleteManyArgs} args - Arguments to filter UserBadges to delete.
     * @example
     * // Delete a few UserBadges
     * const { count } = await prisma.userBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBadgeDeleteManyArgs>(args?: SelectSubset<T, UserBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBadges
     * const userBadge = await prisma.userBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBadgeUpdateManyArgs>(args: SelectSubset<T, UserBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBadges and returns the data updated in the database.
     * @param {UserBadgeUpdateManyAndReturnArgs} args - Arguments to update many UserBadges.
     * @example
     * // Update many UserBadges
     * const userBadge = await prisma.userBadge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserBadges and only return the `id`
     * const userBadgeWithIdOnly = await prisma.userBadge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserBadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, UserBadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserBadge.
     * @param {UserBadgeUpsertArgs} args - Arguments to update or create a UserBadge.
     * @example
     * // Update or create a UserBadge
     * const userBadge = await prisma.userBadge.upsert({
     *   create: {
     *     // ... data to create a UserBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBadge we want to update
     *   }
     * })
     */
    upsert<T extends UserBadgeUpsertArgs>(args: SelectSubset<T, UserBadgeUpsertArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeCountArgs} args - Arguments to filter UserBadges to count.
     * @example
     * // Count the number of UserBadges
     * const count = await prisma.userBadge.count({
     *   where: {
     *     // ... the filter for the UserBadges we want to count
     *   }
     * })
    **/
    count<T extends UserBadgeCountArgs>(
      args?: Subset<T, UserBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBadgeAggregateArgs>(args: Subset<T, UserBadgeAggregateArgs>): Prisma.PrismaPromise<GetUserBadgeAggregateType<T>>

    /**
     * Group by UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBadgeGroupByArgs['orderBy'] }
        : { orderBy?: UserBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBadge model
   */
  readonly fields: UserBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    badge<T extends BadgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BadgeDefaultArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBadge model
   */
  interface UserBadgeFieldRefs {
    readonly id: FieldRef<"UserBadge", 'String'>
    readonly userId: FieldRef<"UserBadge", 'String'>
    readonly badgeId: FieldRef<"UserBadge", 'String'>
    readonly earnedAt: FieldRef<"UserBadge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserBadge findUnique
   */
  export type UserBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findUniqueOrThrow
   */
  export type UserBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findFirst
   */
  export type UserBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findFirstOrThrow
   */
  export type UserBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findMany
   */
  export type UserBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadges to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge create
   */
  export type UserBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBadge.
     */
    data: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
  }

  /**
   * UserBadge createMany
   */
  export type UserBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBadges.
     */
    data: UserBadgeCreateManyInput | UserBadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBadge createManyAndReturn
   */
  export type UserBadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * The data used to create many UserBadges.
     */
    data: UserBadgeCreateManyInput | UserBadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBadge update
   */
  export type UserBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBadge.
     */
    data: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
    /**
     * Choose, which UserBadge to update.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge updateMany
   */
  export type UserBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBadges.
     */
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyInput>
    /**
     * Filter which UserBadges to update
     */
    where?: UserBadgeWhereInput
    /**
     * Limit how many UserBadges to update.
     */
    limit?: number
  }

  /**
   * UserBadge updateManyAndReturn
   */
  export type UserBadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * The data used to update UserBadges.
     */
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyInput>
    /**
     * Filter which UserBadges to update
     */
    where?: UserBadgeWhereInput
    /**
     * Limit how many UserBadges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBadge upsert
   */
  export type UserBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBadge to update in case it exists.
     */
    where: UserBadgeWhereUniqueInput
    /**
     * In case the UserBadge found by the `where` argument doesn't exist, create a new UserBadge with this data.
     */
    create: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
    /**
     * In case the UserBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
  }

  /**
   * UserBadge delete
   */
  export type UserBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter which UserBadge to delete.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge deleteMany
   */
  export type UserBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadges to delete
     */
    where?: UserBadgeWhereInput
    /**
     * Limit how many UserBadges to delete.
     */
    limit?: number
  }

  /**
   * UserBadge without action
   */
  export type UserBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    roles: 'roles'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountId: 'accountId',
    providerId: 'providerId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    idToken: 'idToken',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    age: 'age',
    profession: 'profession',
    motivation: 'motivation',
    interests: 'interests',
    experience: 'experience',
    disponibility: 'disponibility',
    bio: 'bio',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    phoneVerified: 'phoneVerified'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const AdressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    street: 'street',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country'
  };

  export type AdressScalarFieldEnum = (typeof AdressScalarFieldEnum)[keyof typeof AdressScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    subtitle: 'subtitle',
    content: 'content',
    contentText: 'contentText',
    excerpt: 'excerpt',
    coverImageUrl: 'coverImageUrl',
    canonicalUrl: 'canonicalUrl',
    ogImageUrl: 'ogImageUrl',
    status: 'status',
    visibility: 'visibility',
    publishedAt: 'publishedAt',
    scheduledAt: 'scheduledAt',
    readingTime: 'readingTime',
    wordCount: 'wordCount',
    language: 'language',
    authorId: 'authorId',
    parentId: 'parentId',
    projectId: 'projectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const MediaAssetScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    type: 'type',
    url: 'url',
    provider: 'provider',
    title: 'title',
    alt: 'alt',
    caption: 'caption',
    position: 'position',
    mimeType: 'mimeType',
    sizeBytes: 'sizeBytes',
    width: 'width',
    height: 'height',
    durationMs: 'durationMs',
    meta: 'meta',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MediaAssetScalarFieldEnum = (typeof MediaAssetScalarFieldEnum)[keyof typeof MediaAssetScalarFieldEnum]


  export const CodeSnippetScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    title: 'title',
    language: 'language',
    filename: 'filename',
    code: 'code',
    highlightedHtml: 'highlightedHtml',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CodeSnippetScalarFieldEnum = (typeof CodeSnippetScalarFieldEnum)[keyof typeof CodeSnippetScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const PostsOnTagsScalarFieldEnum: {
    postId: 'postId',
    tagId: 'tagId',
    assignedAt: 'assignedAt',
    assignedBy: 'assignedBy'
  };

  export type PostsOnTagsScalarFieldEnum = (typeof PostsOnTagsScalarFieldEnum)[keyof typeof PostsOnTagsScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const PostsOnCategoriesScalarFieldEnum: {
    postId: 'postId',
    categoryId: 'categoryId',
    position: 'position',
    assignedAt: 'assignedAt'
  };

  export type PostsOnCategoriesScalarFieldEnum = (typeof PostsOnCategoriesScalarFieldEnum)[keyof typeof PostsOnCategoriesScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    authorId: 'authorId',
    content: 'content',
    contentText: 'contentText',
    status: 'status',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const ReactionScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type ReactionScalarFieldEnum = (typeof ReactionScalarFieldEnum)[keyof typeof ReactionScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    shortDescription: 'shortDescription',
    type: 'type',
    status: 'status',
    category: 'category',
    location: 'location',
    fundingGoal: 'fundingGoal',
    amountRaised: 'amountRaised',
    currency: 'currency',
    startDate: 'startDate',
    endDate: 'endDate',
    duration: 'duration',
    ownerId: 'ownerId',
    organization: 'organization',
    legalStatus: 'legalStatus',
    website: 'website',
    socialMedia: 'socialMedia',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    impactTypes: 'impactTypes',
    impactDescription: 'impactDescription',
    impactIndicators: 'impactIndicators',
    sdgAlignment: 'sdgAlignment',
    images: 'images',
    videos: 'videos',
    documents: 'documents',
    visibility: 'visibility',
    allowComments: 'allowComments',
    enableImpactSprint: 'enableImpactSprint',
    valuation: 'valuation',
    minInvestment: 'minInvestment',
    capitalPercentage: 'capitalPercentage',
    expectedInvestors: 'expectedInvestors',
    taxAdvantages: 'taxAdvantages',
    interestRate: 'interestRate',
    loanDuration: 'loanDuration',
    repaymentFrequency: 'repaymentFrequency',
    minLoanAmount: 'minLoanAmount',
    guarantees: 'guarantees',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectMemberScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type ProjectMemberScalarFieldEnum = (typeof ProjectMemberScalarFieldEnum)[keyof typeof ProjectMemberScalarFieldEnum]


  export const ProjectUpdateScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    title: 'title',
    content: 'content',
    images: 'images',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectUpdateScalarFieldEnum = (typeof ProjectUpdateScalarFieldEnum)[keyof typeof ProjectUpdateScalarFieldEnum]


  export const ProjectRewardScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    amount: 'amount',
    title: 'title',
    description: 'description',
    image: 'image',
    deliveryDate: 'deliveryDate',
    quantity: 'quantity',
    claimed: 'claimed'
  };

  export type ProjectRewardScalarFieldEnum = (typeof ProjectRewardScalarFieldEnum)[keyof typeof ProjectRewardScalarFieldEnum]


  export const ProjectDonationScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    amount: 'amount',
    isAnonymous: 'isAnonymous',
    message: 'message',
    rewardId: 'rewardId',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ProjectDonationScalarFieldEnum = (typeof ProjectDonationScalarFieldEnum)[keyof typeof ProjectDonationScalarFieldEnum]


  export const ProjectInvestmentScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    amount: 'amount',
    shares: 'shares',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ProjectInvestmentScalarFieldEnum = (typeof ProjectInvestmentScalarFieldEnum)[keyof typeof ProjectInvestmentScalarFieldEnum]


  export const ProjectLoanScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ProjectLoanScalarFieldEnum = (typeof ProjectLoanScalarFieldEnum)[keyof typeof ProjectLoanScalarFieldEnum]


  export const CircleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    type: 'type',
    theme: 'theme',
    participationMode: 'participationMode',
    maxMembers: 'maxMembers',
    isPublic: 'isPublic',
    isActive: 'isActive',
    monthlyFee: 'monthlyFee',
    funds: 'funds',
    allocatedFunds: 'allocatedFunds',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CircleScalarFieldEnum = (typeof CircleScalarFieldEnum)[keyof typeof CircleScalarFieldEnum]


  export const CircleMemberScalarFieldEnum: {
    id: 'id',
    circleId: 'circleId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt',
    xp: 'xp',
    level: 'level'
  };

  export type CircleMemberScalarFieldEnum = (typeof CircleMemberScalarFieldEnum)[keyof typeof CircleMemberScalarFieldEnum]


  export const CircleProjectScalarFieldEnum: {
    id: 'id',
    circleId: 'circleId',
    projectId: 'projectId',
    allocatedAmount: 'allocatedAmount',
    supportType: 'supportType',
    votedAt: 'votedAt',
    status: 'status'
  };

  export type CircleProjectScalarFieldEnum = (typeof CircleProjectScalarFieldEnum)[keyof typeof CircleProjectScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    description: 'description',
    projectId: 'projectId',
    circleId: 'circleId',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const UserXPScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    totalXP: 'totalXP',
    level: 'level',
    impactRank: 'impactRank',
    donationXP: 'donationXP',
    investmentXP: 'investmentXP',
    contentXP: 'contentXP',
    communityXP: 'communityXP',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserXPScalarFieldEnum = (typeof UserXPScalarFieldEnum)[keyof typeof UserXPScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    image: 'image',
    criteria: 'criteria',
    createdAt: 'createdAt'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const UserBadgeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    badgeId: 'badgeId',
    earnedAt: 'earnedAt'
  };

  export type UserBadgeScalarFieldEnum = (typeof UserBadgeScalarFieldEnum)[keyof typeof UserBadgeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'PostStatus'
   */
  export type EnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus'>
    


  /**
   * Reference to a field of type 'PostStatus[]'
   */
  export type ListEnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus[]'>
    


  /**
   * Reference to a field of type 'PostVisibility'
   */
  export type EnumPostVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostVisibility'>
    


  /**
   * Reference to a field of type 'PostVisibility[]'
   */
  export type ListEnumPostVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostVisibility[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'CommentStatus'
   */
  export type EnumCommentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommentStatus'>
    


  /**
   * Reference to a field of type 'CommentStatus[]'
   */
  export type ListEnumCommentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommentStatus[]'>
    


  /**
   * Reference to a field of type 'ReactionType'
   */
  export type EnumReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReactionType'>
    


  /**
   * Reference to a field of type 'ReactionType[]'
   */
  export type ListEnumReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReactionType[]'>
    


  /**
   * Reference to a field of type 'ProjectType'
   */
  export type EnumProjectTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectType'>
    


  /**
   * Reference to a field of type 'ProjectType[]'
   */
  export type ListEnumProjectTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectType[]'>
    


  /**
   * Reference to a field of type 'ProjectStatus'
   */
  export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


  /**
   * Reference to a field of type 'ProjectStatus[]'
   */
  export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


  /**
   * Reference to a field of type 'ProjectCategory'
   */
  export type EnumProjectCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectCategory'>
    


  /**
   * Reference to a field of type 'ProjectCategory[]'
   */
  export type ListEnumProjectCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectCategory[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ProjectImpactType[]'
   */
  export type ListEnumProjectImpactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectImpactType[]'>
    


  /**
   * Reference to a field of type 'ProjectImpactType'
   */
  export type EnumProjectImpactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectImpactType'>
    


  /**
   * Reference to a field of type 'CircleType'
   */
  export type EnumCircleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CircleType'>
    


  /**
   * Reference to a field of type 'CircleType[]'
   */
  export type ListEnumCircleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CircleType[]'>
    


  /**
   * Reference to a field of type 'CircleParticipationMode'
   */
  export type EnumCircleParticipationModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CircleParticipationMode'>
    


  /**
   * Reference to a field of type 'CircleParticipationMode[]'
   */
  export type ListEnumCircleParticipationModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CircleParticipationMode[]'>
    


  /**
   * Reference to a field of type 'CircleMemberRole'
   */
  export type EnumCircleMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CircleMemberRole'>
    


  /**
   * Reference to a field of type 'CircleMemberRole[]'
   */
  export type ListEnumCircleMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CircleMemberRole[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    roles?: EnumRoleNullableListFilter<"User">
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    Profile?: ProfileListRelationFilter
    adress?: AdressListRelationFilter
    Post?: PostListRelationFilter
    Project?: ProjectListRelationFilter
    Circle?: CircleListRelationFilter
    Reaction?: ReactionListRelationFilter
    Comment?: CommentListRelationFilter
    ProjectMember?: ProjectMemberListRelationFilter
    ProjectDonation?: ProjectDonationListRelationFilter
    ProjectInvestment?: ProjectInvestmentListRelationFilter
    ProjectLoan?: ProjectLoanListRelationFilter
    CircleMember?: CircleMemberListRelationFilter
    ProjectUpdate?: ProjectUpdateListRelationFilter
    ProjectReward?: ProjectRewardListRelationFilter
    UserBadge?: UserBadgeListRelationFilter
    UserXP?: UserXPListRelationFilter
    Transaction?: TransactionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roles?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    Profile?: ProfileOrderByRelationAggregateInput
    adress?: adressOrderByRelationAggregateInput
    Post?: PostOrderByRelationAggregateInput
    Project?: ProjectOrderByRelationAggregateInput
    Circle?: CircleOrderByRelationAggregateInput
    Reaction?: ReactionOrderByRelationAggregateInput
    Comment?: CommentOrderByRelationAggregateInput
    ProjectMember?: ProjectMemberOrderByRelationAggregateInput
    ProjectDonation?: ProjectDonationOrderByRelationAggregateInput
    ProjectInvestment?: ProjectInvestmentOrderByRelationAggregateInput
    ProjectLoan?: ProjectLoanOrderByRelationAggregateInput
    CircleMember?: CircleMemberOrderByRelationAggregateInput
    ProjectUpdate?: ProjectUpdateOrderByRelationAggregateInput
    ProjectReward?: ProjectRewardOrderByRelationAggregateInput
    UserBadge?: UserBadgeOrderByRelationAggregateInput
    UserXP?: UserXPOrderByRelationAggregateInput
    Transaction?: TransactionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    roles?: EnumRoleNullableListFilter<"User">
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    Profile?: ProfileListRelationFilter
    adress?: AdressListRelationFilter
    Post?: PostListRelationFilter
    Project?: ProjectListRelationFilter
    Circle?: CircleListRelationFilter
    Reaction?: ReactionListRelationFilter
    Comment?: CommentListRelationFilter
    ProjectMember?: ProjectMemberListRelationFilter
    ProjectDonation?: ProjectDonationListRelationFilter
    ProjectInvestment?: ProjectInvestmentListRelationFilter
    ProjectLoan?: ProjectLoanListRelationFilter
    CircleMember?: CircleMemberListRelationFilter
    ProjectUpdate?: ProjectUpdateListRelationFilter
    ProjectReward?: ProjectRewardListRelationFilter
    UserBadge?: UserBadgeListRelationFilter
    UserXP?: UserXPListRelationFilter
    Transaction?: TransactionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roles?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    roles?: EnumRoleNullableListFilter<"User">
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    providerId_accountId?: AccountProviderIdAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "providerId_accountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    age?: IntNullableFilter<"Profile"> | number | null
    profession?: StringNullableFilter<"Profile"> | string | null
    motivation?: StringNullableFilter<"Profile"> | string | null
    interests?: StringNullableListFilter<"Profile">
    experience?: StringNullableFilter<"Profile"> | string | null
    disponibility?: StringNullableFilter<"Profile"> | string | null
    bio?: StringNullableFilter<"Profile"> | string | null
    firstName?: StringNullableFilter<"Profile"> | string | null
    lastName?: StringNullableFilter<"Profile"> | string | null
    phone?: StringNullableFilter<"Profile"> | string | null
    phoneVerified?: BoolFilter<"Profile"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    age?: SortOrderInput | SortOrder
    profession?: SortOrderInput | SortOrder
    motivation?: SortOrderInput | SortOrder
    interests?: SortOrder
    experience?: SortOrderInput | SortOrder
    disponibility?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    phoneVerified?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    age?: IntNullableFilter<"Profile"> | number | null
    profession?: StringNullableFilter<"Profile"> | string | null
    motivation?: StringNullableFilter<"Profile"> | string | null
    interests?: StringNullableListFilter<"Profile">
    experience?: StringNullableFilter<"Profile"> | string | null
    disponibility?: StringNullableFilter<"Profile"> | string | null
    bio?: StringNullableFilter<"Profile"> | string | null
    firstName?: StringNullableFilter<"Profile"> | string | null
    lastName?: StringNullableFilter<"Profile"> | string | null
    phone?: StringNullableFilter<"Profile"> | string | null
    phoneVerified?: BoolFilter<"Profile"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    age?: SortOrderInput | SortOrder
    profession?: SortOrderInput | SortOrder
    motivation?: SortOrderInput | SortOrder
    interests?: SortOrder
    experience?: SortOrderInput | SortOrder
    disponibility?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    phoneVerified?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    userId?: StringWithAggregatesFilter<"Profile"> | string
    age?: IntNullableWithAggregatesFilter<"Profile"> | number | null
    profession?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    motivation?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    interests?: StringNullableListFilter<"Profile">
    experience?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    disponibility?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    phoneVerified?: BoolWithAggregatesFilter<"Profile"> | boolean
  }

  export type adressWhereInput = {
    AND?: adressWhereInput | adressWhereInput[]
    OR?: adressWhereInput[]
    NOT?: adressWhereInput | adressWhereInput[]
    id?: StringFilter<"adress"> | string
    userId?: StringFilter<"adress"> | string
    street?: StringNullableFilter<"adress"> | string | null
    city?: StringNullableFilter<"adress"> | string | null
    state?: StringNullableFilter<"adress"> | string | null
    postalCode?: StringNullableFilter<"adress"> | string | null
    country?: StringNullableFilter<"adress"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type adressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    street?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type adressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: adressWhereInput | adressWhereInput[]
    OR?: adressWhereInput[]
    NOT?: adressWhereInput | adressWhereInput[]
    userId?: StringFilter<"adress"> | string
    street?: StringNullableFilter<"adress"> | string | null
    city?: StringNullableFilter<"adress"> | string | null
    state?: StringNullableFilter<"adress"> | string | null
    postalCode?: StringNullableFilter<"adress"> | string | null
    country?: StringNullableFilter<"adress"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type adressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    street?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    _count?: adressCountOrderByAggregateInput
    _max?: adressMaxOrderByAggregateInput
    _min?: adressMinOrderByAggregateInput
  }

  export type adressScalarWhereWithAggregatesInput = {
    AND?: adressScalarWhereWithAggregatesInput | adressScalarWhereWithAggregatesInput[]
    OR?: adressScalarWhereWithAggregatesInput[]
    NOT?: adressScalarWhereWithAggregatesInput | adressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"adress"> | string
    userId?: StringWithAggregatesFilter<"adress"> | string
    street?: StringNullableWithAggregatesFilter<"adress"> | string | null
    city?: StringNullableWithAggregatesFilter<"adress"> | string | null
    state?: StringNullableWithAggregatesFilter<"adress"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"adress"> | string | null
    country?: StringNullableWithAggregatesFilter<"adress"> | string | null
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    slug?: StringFilter<"Post"> | string
    title?: StringFilter<"Post"> | string
    subtitle?: StringNullableFilter<"Post"> | string | null
    content?: JsonNullableFilter<"Post">
    contentText?: StringNullableFilter<"Post"> | string | null
    excerpt?: StringNullableFilter<"Post"> | string | null
    coverImageUrl?: StringNullableFilter<"Post"> | string | null
    canonicalUrl?: StringNullableFilter<"Post"> | string | null
    ogImageUrl?: StringNullableFilter<"Post"> | string | null
    status?: EnumPostStatusFilter<"Post"> | $Enums.PostStatus
    visibility?: EnumPostVisibilityFilter<"Post"> | $Enums.PostVisibility
    publishedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    scheduledAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    readingTime?: IntNullableFilter<"Post"> | number | null
    wordCount?: IntNullableFilter<"Post"> | number | null
    language?: StringNullableFilter<"Post"> | string | null
    authorId?: StringFilter<"Post"> | string
    parentId?: StringNullableFilter<"Post"> | string | null
    projectId?: StringNullableFilter<"Post"> | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<PostNullableScalarRelationFilter, PostWhereInput> | null
    children?: PostListRelationFilter
    attachments?: MediaAssetListRelationFilter
    codeSnippets?: CodeSnippetListRelationFilter
    tags?: PostsOnTagsListRelationFilter
    categories?: PostsOnCategoriesListRelationFilter
    comments?: CommentListRelationFilter
    reactions?: ReactionListRelationFilter
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    contentText?: SortOrderInput | SortOrder
    excerpt?: SortOrderInput | SortOrder
    coverImageUrl?: SortOrderInput | SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    ogImageUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    visibility?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    readingTime?: SortOrderInput | SortOrder
    wordCount?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    authorId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    parent?: PostOrderByWithRelationInput
    children?: PostOrderByRelationAggregateInput
    attachments?: MediaAssetOrderByRelationAggregateInput
    codeSnippets?: CodeSnippetOrderByRelationAggregateInput
    tags?: PostsOnTagsOrderByRelationAggregateInput
    categories?: PostsOnCategoriesOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    reactions?: ReactionOrderByRelationAggregateInput
    project?: ProjectOrderByWithRelationInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    title?: StringFilter<"Post"> | string
    subtitle?: StringNullableFilter<"Post"> | string | null
    content?: JsonNullableFilter<"Post">
    contentText?: StringNullableFilter<"Post"> | string | null
    excerpt?: StringNullableFilter<"Post"> | string | null
    coverImageUrl?: StringNullableFilter<"Post"> | string | null
    canonicalUrl?: StringNullableFilter<"Post"> | string | null
    ogImageUrl?: StringNullableFilter<"Post"> | string | null
    status?: EnumPostStatusFilter<"Post"> | $Enums.PostStatus
    visibility?: EnumPostVisibilityFilter<"Post"> | $Enums.PostVisibility
    publishedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    scheduledAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    readingTime?: IntNullableFilter<"Post"> | number | null
    wordCount?: IntNullableFilter<"Post"> | number | null
    language?: StringNullableFilter<"Post"> | string | null
    authorId?: StringFilter<"Post"> | string
    parentId?: StringNullableFilter<"Post"> | string | null
    projectId?: StringNullableFilter<"Post"> | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<PostNullableScalarRelationFilter, PostWhereInput> | null
    children?: PostListRelationFilter
    attachments?: MediaAssetListRelationFilter
    codeSnippets?: CodeSnippetListRelationFilter
    tags?: PostsOnTagsListRelationFilter
    categories?: PostsOnCategoriesListRelationFilter
    comments?: CommentListRelationFilter
    reactions?: ReactionListRelationFilter
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }, "id" | "slug">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    contentText?: SortOrderInput | SortOrder
    excerpt?: SortOrderInput | SortOrder
    coverImageUrl?: SortOrderInput | SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    ogImageUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    visibility?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    readingTime?: SortOrderInput | SortOrder
    wordCount?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    authorId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    slug?: StringWithAggregatesFilter<"Post"> | string
    title?: StringWithAggregatesFilter<"Post"> | string
    subtitle?: StringNullableWithAggregatesFilter<"Post"> | string | null
    content?: JsonNullableWithAggregatesFilter<"Post">
    contentText?: StringNullableWithAggregatesFilter<"Post"> | string | null
    excerpt?: StringNullableWithAggregatesFilter<"Post"> | string | null
    coverImageUrl?: StringNullableWithAggregatesFilter<"Post"> | string | null
    canonicalUrl?: StringNullableWithAggregatesFilter<"Post"> | string | null
    ogImageUrl?: StringNullableWithAggregatesFilter<"Post"> | string | null
    status?: EnumPostStatusWithAggregatesFilter<"Post"> | $Enums.PostStatus
    visibility?: EnumPostVisibilityWithAggregatesFilter<"Post"> | $Enums.PostVisibility
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Post"> | Date | string | null
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"Post"> | Date | string | null
    readingTime?: IntNullableWithAggregatesFilter<"Post"> | number | null
    wordCount?: IntNullableWithAggregatesFilter<"Post"> | number | null
    language?: StringNullableWithAggregatesFilter<"Post"> | string | null
    authorId?: StringWithAggregatesFilter<"Post"> | string
    parentId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"Post"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
  }

  export type MediaAssetWhereInput = {
    AND?: MediaAssetWhereInput | MediaAssetWhereInput[]
    OR?: MediaAssetWhereInput[]
    NOT?: MediaAssetWhereInput | MediaAssetWhereInput[]
    id?: StringFilter<"MediaAsset"> | string
    postId?: StringFilter<"MediaAsset"> | string
    type?: EnumMediaTypeFilter<"MediaAsset"> | $Enums.MediaType
    url?: StringFilter<"MediaAsset"> | string
    provider?: StringNullableFilter<"MediaAsset"> | string | null
    title?: StringNullableFilter<"MediaAsset"> | string | null
    alt?: StringNullableFilter<"MediaAsset"> | string | null
    caption?: StringNullableFilter<"MediaAsset"> | string | null
    position?: IntNullableFilter<"MediaAsset"> | number | null
    mimeType?: StringNullableFilter<"MediaAsset"> | string | null
    sizeBytes?: IntNullableFilter<"MediaAsset"> | number | null
    width?: IntNullableFilter<"MediaAsset"> | number | null
    height?: IntNullableFilter<"MediaAsset"> | number | null
    durationMs?: IntNullableFilter<"MediaAsset"> | number | null
    meta?: JsonNullableFilter<"MediaAsset">
    createdAt?: DateTimeFilter<"MediaAsset"> | Date | string
    updatedAt?: DateTimeFilter<"MediaAsset"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }

  export type MediaAssetOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    provider?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    alt?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: PostOrderByWithRelationInput
  }

  export type MediaAssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaAssetWhereInput | MediaAssetWhereInput[]
    OR?: MediaAssetWhereInput[]
    NOT?: MediaAssetWhereInput | MediaAssetWhereInput[]
    postId?: StringFilter<"MediaAsset"> | string
    type?: EnumMediaTypeFilter<"MediaAsset"> | $Enums.MediaType
    url?: StringFilter<"MediaAsset"> | string
    provider?: StringNullableFilter<"MediaAsset"> | string | null
    title?: StringNullableFilter<"MediaAsset"> | string | null
    alt?: StringNullableFilter<"MediaAsset"> | string | null
    caption?: StringNullableFilter<"MediaAsset"> | string | null
    position?: IntNullableFilter<"MediaAsset"> | number | null
    mimeType?: StringNullableFilter<"MediaAsset"> | string | null
    sizeBytes?: IntNullableFilter<"MediaAsset"> | number | null
    width?: IntNullableFilter<"MediaAsset"> | number | null
    height?: IntNullableFilter<"MediaAsset"> | number | null
    durationMs?: IntNullableFilter<"MediaAsset"> | number | null
    meta?: JsonNullableFilter<"MediaAsset">
    createdAt?: DateTimeFilter<"MediaAsset"> | Date | string
    updatedAt?: DateTimeFilter<"MediaAsset"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }, "id">

  export type MediaAssetOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    provider?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    alt?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MediaAssetCountOrderByAggregateInput
    _avg?: MediaAssetAvgOrderByAggregateInput
    _max?: MediaAssetMaxOrderByAggregateInput
    _min?: MediaAssetMinOrderByAggregateInput
    _sum?: MediaAssetSumOrderByAggregateInput
  }

  export type MediaAssetScalarWhereWithAggregatesInput = {
    AND?: MediaAssetScalarWhereWithAggregatesInput | MediaAssetScalarWhereWithAggregatesInput[]
    OR?: MediaAssetScalarWhereWithAggregatesInput[]
    NOT?: MediaAssetScalarWhereWithAggregatesInput | MediaAssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MediaAsset"> | string
    postId?: StringWithAggregatesFilter<"MediaAsset"> | string
    type?: EnumMediaTypeWithAggregatesFilter<"MediaAsset"> | $Enums.MediaType
    url?: StringWithAggregatesFilter<"MediaAsset"> | string
    provider?: StringNullableWithAggregatesFilter<"MediaAsset"> | string | null
    title?: StringNullableWithAggregatesFilter<"MediaAsset"> | string | null
    alt?: StringNullableWithAggregatesFilter<"MediaAsset"> | string | null
    caption?: StringNullableWithAggregatesFilter<"MediaAsset"> | string | null
    position?: IntNullableWithAggregatesFilter<"MediaAsset"> | number | null
    mimeType?: StringNullableWithAggregatesFilter<"MediaAsset"> | string | null
    sizeBytes?: IntNullableWithAggregatesFilter<"MediaAsset"> | number | null
    width?: IntNullableWithAggregatesFilter<"MediaAsset"> | number | null
    height?: IntNullableWithAggregatesFilter<"MediaAsset"> | number | null
    durationMs?: IntNullableWithAggregatesFilter<"MediaAsset"> | number | null
    meta?: JsonNullableWithAggregatesFilter<"MediaAsset">
    createdAt?: DateTimeWithAggregatesFilter<"MediaAsset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MediaAsset"> | Date | string
  }

  export type CodeSnippetWhereInput = {
    AND?: CodeSnippetWhereInput | CodeSnippetWhereInput[]
    OR?: CodeSnippetWhereInput[]
    NOT?: CodeSnippetWhereInput | CodeSnippetWhereInput[]
    id?: StringFilter<"CodeSnippet"> | string
    postId?: StringFilter<"CodeSnippet"> | string
    title?: StringNullableFilter<"CodeSnippet"> | string | null
    language?: StringFilter<"CodeSnippet"> | string
    filename?: StringNullableFilter<"CodeSnippet"> | string | null
    code?: StringFilter<"CodeSnippet"> | string
    highlightedHtml?: StringNullableFilter<"CodeSnippet"> | string | null
    createdAt?: DateTimeFilter<"CodeSnippet"> | Date | string
    updatedAt?: DateTimeFilter<"CodeSnippet"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }

  export type CodeSnippetOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    title?: SortOrderInput | SortOrder
    language?: SortOrder
    filename?: SortOrderInput | SortOrder
    code?: SortOrder
    highlightedHtml?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: PostOrderByWithRelationInput
  }

  export type CodeSnippetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CodeSnippetWhereInput | CodeSnippetWhereInput[]
    OR?: CodeSnippetWhereInput[]
    NOT?: CodeSnippetWhereInput | CodeSnippetWhereInput[]
    postId?: StringFilter<"CodeSnippet"> | string
    title?: StringNullableFilter<"CodeSnippet"> | string | null
    language?: StringFilter<"CodeSnippet"> | string
    filename?: StringNullableFilter<"CodeSnippet"> | string | null
    code?: StringFilter<"CodeSnippet"> | string
    highlightedHtml?: StringNullableFilter<"CodeSnippet"> | string | null
    createdAt?: DateTimeFilter<"CodeSnippet"> | Date | string
    updatedAt?: DateTimeFilter<"CodeSnippet"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }, "id">

  export type CodeSnippetOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    title?: SortOrderInput | SortOrder
    language?: SortOrder
    filename?: SortOrderInput | SortOrder
    code?: SortOrder
    highlightedHtml?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CodeSnippetCountOrderByAggregateInput
    _max?: CodeSnippetMaxOrderByAggregateInput
    _min?: CodeSnippetMinOrderByAggregateInput
  }

  export type CodeSnippetScalarWhereWithAggregatesInput = {
    AND?: CodeSnippetScalarWhereWithAggregatesInput | CodeSnippetScalarWhereWithAggregatesInput[]
    OR?: CodeSnippetScalarWhereWithAggregatesInput[]
    NOT?: CodeSnippetScalarWhereWithAggregatesInput | CodeSnippetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CodeSnippet"> | string
    postId?: StringWithAggregatesFilter<"CodeSnippet"> | string
    title?: StringNullableWithAggregatesFilter<"CodeSnippet"> | string | null
    language?: StringWithAggregatesFilter<"CodeSnippet"> | string
    filename?: StringNullableWithAggregatesFilter<"CodeSnippet"> | string | null
    code?: StringWithAggregatesFilter<"CodeSnippet"> | string
    highlightedHtml?: StringNullableWithAggregatesFilter<"CodeSnippet"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CodeSnippet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CodeSnippet"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    posts?: PostsOnTagsListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posts?: PostsOnTagsOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    description?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    posts?: PostsOnTagsListRelationFilter
  }, "id" | "name" | "slug">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    slug?: StringWithAggregatesFilter<"Tag"> | string
    description?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type PostsOnTagsWhereInput = {
    AND?: PostsOnTagsWhereInput | PostsOnTagsWhereInput[]
    OR?: PostsOnTagsWhereInput[]
    NOT?: PostsOnTagsWhereInput | PostsOnTagsWhereInput[]
    postId?: StringFilter<"PostsOnTags"> | string
    tagId?: StringFilter<"PostsOnTags"> | string
    assignedAt?: DateTimeFilter<"PostsOnTags"> | Date | string
    assignedBy?: StringNullableFilter<"PostsOnTags"> | string | null
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type PostsOnTagsOrderByWithRelationInput = {
    postId?: SortOrder
    tagId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    post?: PostOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type PostsOnTagsWhereUniqueInput = Prisma.AtLeast<{
    postId_tagId?: PostsOnTagsPostIdTagIdCompoundUniqueInput
    AND?: PostsOnTagsWhereInput | PostsOnTagsWhereInput[]
    OR?: PostsOnTagsWhereInput[]
    NOT?: PostsOnTagsWhereInput | PostsOnTagsWhereInput[]
    postId?: StringFilter<"PostsOnTags"> | string
    tagId?: StringFilter<"PostsOnTags"> | string
    assignedAt?: DateTimeFilter<"PostsOnTags"> | Date | string
    assignedBy?: StringNullableFilter<"PostsOnTags"> | string | null
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "postId_tagId">

  export type PostsOnTagsOrderByWithAggregationInput = {
    postId?: SortOrder
    tagId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    _count?: PostsOnTagsCountOrderByAggregateInput
    _max?: PostsOnTagsMaxOrderByAggregateInput
    _min?: PostsOnTagsMinOrderByAggregateInput
  }

  export type PostsOnTagsScalarWhereWithAggregatesInput = {
    AND?: PostsOnTagsScalarWhereWithAggregatesInput | PostsOnTagsScalarWhereWithAggregatesInput[]
    OR?: PostsOnTagsScalarWhereWithAggregatesInput[]
    NOT?: PostsOnTagsScalarWhereWithAggregatesInput | PostsOnTagsScalarWhereWithAggregatesInput[]
    postId?: StringWithAggregatesFilter<"PostsOnTags"> | string
    tagId?: StringWithAggregatesFilter<"PostsOnTags"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"PostsOnTags"> | Date | string
    assignedBy?: StringNullableWithAggregatesFilter<"PostsOnTags"> | string | null
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    posts?: PostsOnCategoriesListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: CategoryOrderByWithRelationInput
    children?: CategoryOrderByRelationAggregateInput
    posts?: PostsOnCategoriesOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    description?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    posts?: PostsOnCategoriesListRelationFilter
  }, "id" | "name" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"Category"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type PostsOnCategoriesWhereInput = {
    AND?: PostsOnCategoriesWhereInput | PostsOnCategoriesWhereInput[]
    OR?: PostsOnCategoriesWhereInput[]
    NOT?: PostsOnCategoriesWhereInput | PostsOnCategoriesWhereInput[]
    postId?: StringFilter<"PostsOnCategories"> | string
    categoryId?: StringFilter<"PostsOnCategories"> | string
    position?: IntNullableFilter<"PostsOnCategories"> | number | null
    assignedAt?: DateTimeFilter<"PostsOnCategories"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }

  export type PostsOnCategoriesOrderByWithRelationInput = {
    postId?: SortOrder
    categoryId?: SortOrder
    position?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    post?: PostOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
  }

  export type PostsOnCategoriesWhereUniqueInput = Prisma.AtLeast<{
    postId_categoryId?: PostsOnCategoriesPostIdCategoryIdCompoundUniqueInput
    AND?: PostsOnCategoriesWhereInput | PostsOnCategoriesWhereInput[]
    OR?: PostsOnCategoriesWhereInput[]
    NOT?: PostsOnCategoriesWhereInput | PostsOnCategoriesWhereInput[]
    postId?: StringFilter<"PostsOnCategories"> | string
    categoryId?: StringFilter<"PostsOnCategories"> | string
    position?: IntNullableFilter<"PostsOnCategories"> | number | null
    assignedAt?: DateTimeFilter<"PostsOnCategories"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }, "postId_categoryId">

  export type PostsOnCategoriesOrderByWithAggregationInput = {
    postId?: SortOrder
    categoryId?: SortOrder
    position?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    _count?: PostsOnCategoriesCountOrderByAggregateInput
    _avg?: PostsOnCategoriesAvgOrderByAggregateInput
    _max?: PostsOnCategoriesMaxOrderByAggregateInput
    _min?: PostsOnCategoriesMinOrderByAggregateInput
    _sum?: PostsOnCategoriesSumOrderByAggregateInput
  }

  export type PostsOnCategoriesScalarWhereWithAggregatesInput = {
    AND?: PostsOnCategoriesScalarWhereWithAggregatesInput | PostsOnCategoriesScalarWhereWithAggregatesInput[]
    OR?: PostsOnCategoriesScalarWhereWithAggregatesInput[]
    NOT?: PostsOnCategoriesScalarWhereWithAggregatesInput | PostsOnCategoriesScalarWhereWithAggregatesInput[]
    postId?: StringWithAggregatesFilter<"PostsOnCategories"> | string
    categoryId?: StringWithAggregatesFilter<"PostsOnCategories"> | string
    position?: IntNullableWithAggregatesFilter<"PostsOnCategories"> | number | null
    assignedAt?: DateTimeWithAggregatesFilter<"PostsOnCategories"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    content?: JsonNullableFilter<"Comment">
    contentText?: StringNullableFilter<"Comment"> | string | null
    status?: EnumCommentStatusFilter<"Comment"> | $Enums.CommentStatus
    parentId?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    children?: CommentListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrderInput | SortOrder
    contentText?: SortOrderInput | SortOrder
    status?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: PostOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    parent?: CommentOrderByWithRelationInput
    children?: CommentOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    content?: JsonNullableFilter<"Comment">
    contentText?: StringNullableFilter<"Comment"> | string | null
    status?: EnumCommentStatusFilter<"Comment"> | $Enums.CommentStatus
    parentId?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    children?: CommentListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrderInput | SortOrder
    contentText?: SortOrderInput | SortOrder
    status?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    postId?: StringWithAggregatesFilter<"Comment"> | string
    authorId?: StringWithAggregatesFilter<"Comment"> | string
    content?: JsonNullableWithAggregatesFilter<"Comment">
    contentText?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    status?: EnumCommentStatusWithAggregatesFilter<"Comment"> | $Enums.CommentStatus
    parentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type ReactionWhereInput = {
    AND?: ReactionWhereInput | ReactionWhereInput[]
    OR?: ReactionWhereInput[]
    NOT?: ReactionWhereInput | ReactionWhereInput[]
    id?: StringFilter<"Reaction"> | string
    postId?: StringFilter<"Reaction"> | string
    userId?: StringFilter<"Reaction"> | string
    type?: EnumReactionTypeFilter<"Reaction"> | $Enums.ReactionType
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReactionOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    post?: PostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId_userId_type?: ReactionPostIdUserIdTypeCompoundUniqueInput
    AND?: ReactionWhereInput | ReactionWhereInput[]
    OR?: ReactionWhereInput[]
    NOT?: ReactionWhereInput | ReactionWhereInput[]
    postId?: StringFilter<"Reaction"> | string
    userId?: StringFilter<"Reaction"> | string
    type?: EnumReactionTypeFilter<"Reaction"> | $Enums.ReactionType
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "postId_userId_type">

  export type ReactionOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: ReactionCountOrderByAggregateInput
    _max?: ReactionMaxOrderByAggregateInput
    _min?: ReactionMinOrderByAggregateInput
  }

  export type ReactionScalarWhereWithAggregatesInput = {
    AND?: ReactionScalarWhereWithAggregatesInput | ReactionScalarWhereWithAggregatesInput[]
    OR?: ReactionScalarWhereWithAggregatesInput[]
    NOT?: ReactionScalarWhereWithAggregatesInput | ReactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reaction"> | string
    postId?: StringWithAggregatesFilter<"Reaction"> | string
    userId?: StringWithAggregatesFilter<"Reaction"> | string
    type?: EnumReactionTypeWithAggregatesFilter<"Reaction"> | $Enums.ReactionType
    createdAt?: DateTimeWithAggregatesFilter<"Reaction"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    slug?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    shortDescription?: StringNullableFilter<"Project"> | string | null
    type?: EnumProjectTypeFilter<"Project"> | $Enums.ProjectType
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    category?: EnumProjectCategoryFilter<"Project"> | $Enums.ProjectCategory
    location?: StringNullableFilter<"Project"> | string | null
    fundingGoal?: FloatFilter<"Project"> | number
    amountRaised?: FloatFilter<"Project"> | number
    currency?: StringFilter<"Project"> | string
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    duration?: IntNullableFilter<"Project"> | number | null
    ownerId?: StringFilter<"Project"> | string
    organization?: StringNullableFilter<"Project"> | string | null
    legalStatus?: StringNullableFilter<"Project"> | string | null
    website?: StringNullableFilter<"Project"> | string | null
    socialMedia?: JsonNullableFilter<"Project">
    contactEmail?: StringNullableFilter<"Project"> | string | null
    contactPhone?: StringNullableFilter<"Project"> | string | null
    impactTypes?: EnumProjectImpactTypeNullableListFilter<"Project">
    impactDescription?: StringNullableFilter<"Project"> | string | null
    impactIndicators?: StringNullableListFilter<"Project">
    sdgAlignment?: IntNullableListFilter<"Project">
    images?: StringNullableListFilter<"Project">
    videos?: StringNullableListFilter<"Project">
    documents?: StringNullableListFilter<"Project">
    visibility?: EnumPostVisibilityFilter<"Project"> | $Enums.PostVisibility
    allowComments?: BoolFilter<"Project"> | boolean
    enableImpactSprint?: BoolFilter<"Project"> | boolean
    valuation?: FloatNullableFilter<"Project"> | number | null
    minInvestment?: FloatNullableFilter<"Project"> | number | null
    capitalPercentage?: FloatNullableFilter<"Project"> | number | null
    expectedInvestors?: IntNullableFilter<"Project"> | number | null
    taxAdvantages?: StringNullableFilter<"Project"> | string | null
    interestRate?: FloatNullableFilter<"Project"> | number | null
    loanDuration?: IntNullableFilter<"Project"> | number | null
    repaymentFrequency?: StringNullableFilter<"Project"> | string | null
    minLoanAmount?: FloatNullableFilter<"Project"> | number | null
    guarantees?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: ProjectMemberListRelationFilter
    posts?: PostListRelationFilter
    updates?: ProjectUpdateListRelationFilter
    rewards?: ProjectRewardListRelationFilter
    donations?: ProjectDonationListRelationFilter
    investments?: ProjectInvestmentListRelationFilter
    loans?: ProjectLoanListRelationFilter
    Transaction?: TransactionListRelationFilter
    CircleProject?: CircleProjectListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    category?: SortOrder
    location?: SortOrderInput | SortOrder
    fundingGoal?: SortOrder
    amountRaised?: SortOrder
    currency?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    organization?: SortOrderInput | SortOrder
    legalStatus?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    socialMedia?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    impactTypes?: SortOrder
    impactDescription?: SortOrderInput | SortOrder
    impactIndicators?: SortOrder
    sdgAlignment?: SortOrder
    images?: SortOrder
    videos?: SortOrder
    documents?: SortOrder
    visibility?: SortOrder
    allowComments?: SortOrder
    enableImpactSprint?: SortOrder
    valuation?: SortOrderInput | SortOrder
    minInvestment?: SortOrderInput | SortOrder
    capitalPercentage?: SortOrderInput | SortOrder
    expectedInvestors?: SortOrderInput | SortOrder
    taxAdvantages?: SortOrderInput | SortOrder
    interestRate?: SortOrderInput | SortOrder
    loanDuration?: SortOrderInput | SortOrder
    repaymentFrequency?: SortOrderInput | SortOrder
    minLoanAmount?: SortOrderInput | SortOrder
    guarantees?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    members?: ProjectMemberOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    updates?: ProjectUpdateOrderByRelationAggregateInput
    rewards?: ProjectRewardOrderByRelationAggregateInput
    donations?: ProjectDonationOrderByRelationAggregateInput
    investments?: ProjectInvestmentOrderByRelationAggregateInput
    loans?: ProjectLoanOrderByRelationAggregateInput
    Transaction?: TransactionOrderByRelationAggregateInput
    CircleProject?: CircleProjectOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    shortDescription?: StringNullableFilter<"Project"> | string | null
    type?: EnumProjectTypeFilter<"Project"> | $Enums.ProjectType
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    category?: EnumProjectCategoryFilter<"Project"> | $Enums.ProjectCategory
    location?: StringNullableFilter<"Project"> | string | null
    fundingGoal?: FloatFilter<"Project"> | number
    amountRaised?: FloatFilter<"Project"> | number
    currency?: StringFilter<"Project"> | string
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    duration?: IntNullableFilter<"Project"> | number | null
    ownerId?: StringFilter<"Project"> | string
    organization?: StringNullableFilter<"Project"> | string | null
    legalStatus?: StringNullableFilter<"Project"> | string | null
    website?: StringNullableFilter<"Project"> | string | null
    socialMedia?: JsonNullableFilter<"Project">
    contactEmail?: StringNullableFilter<"Project"> | string | null
    contactPhone?: StringNullableFilter<"Project"> | string | null
    impactTypes?: EnumProjectImpactTypeNullableListFilter<"Project">
    impactDescription?: StringNullableFilter<"Project"> | string | null
    impactIndicators?: StringNullableListFilter<"Project">
    sdgAlignment?: IntNullableListFilter<"Project">
    images?: StringNullableListFilter<"Project">
    videos?: StringNullableListFilter<"Project">
    documents?: StringNullableListFilter<"Project">
    visibility?: EnumPostVisibilityFilter<"Project"> | $Enums.PostVisibility
    allowComments?: BoolFilter<"Project"> | boolean
    enableImpactSprint?: BoolFilter<"Project"> | boolean
    valuation?: FloatNullableFilter<"Project"> | number | null
    minInvestment?: FloatNullableFilter<"Project"> | number | null
    capitalPercentage?: FloatNullableFilter<"Project"> | number | null
    expectedInvestors?: IntNullableFilter<"Project"> | number | null
    taxAdvantages?: StringNullableFilter<"Project"> | string | null
    interestRate?: FloatNullableFilter<"Project"> | number | null
    loanDuration?: IntNullableFilter<"Project"> | number | null
    repaymentFrequency?: StringNullableFilter<"Project"> | string | null
    minLoanAmount?: FloatNullableFilter<"Project"> | number | null
    guarantees?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: ProjectMemberListRelationFilter
    posts?: PostListRelationFilter
    updates?: ProjectUpdateListRelationFilter
    rewards?: ProjectRewardListRelationFilter
    donations?: ProjectDonationListRelationFilter
    investments?: ProjectInvestmentListRelationFilter
    loans?: ProjectLoanListRelationFilter
    Transaction?: TransactionListRelationFilter
    CircleProject?: CircleProjectListRelationFilter
  }, "id" | "slug">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    category?: SortOrder
    location?: SortOrderInput | SortOrder
    fundingGoal?: SortOrder
    amountRaised?: SortOrder
    currency?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    organization?: SortOrderInput | SortOrder
    legalStatus?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    socialMedia?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    impactTypes?: SortOrder
    impactDescription?: SortOrderInput | SortOrder
    impactIndicators?: SortOrder
    sdgAlignment?: SortOrder
    images?: SortOrder
    videos?: SortOrder
    documents?: SortOrder
    visibility?: SortOrder
    allowComments?: SortOrder
    enableImpactSprint?: SortOrder
    valuation?: SortOrderInput | SortOrder
    minInvestment?: SortOrderInput | SortOrder
    capitalPercentage?: SortOrderInput | SortOrder
    expectedInvestors?: SortOrderInput | SortOrder
    taxAdvantages?: SortOrderInput | SortOrder
    interestRate?: SortOrderInput | SortOrder
    loanDuration?: SortOrderInput | SortOrder
    repaymentFrequency?: SortOrderInput | SortOrder
    minLoanAmount?: SortOrderInput | SortOrder
    guarantees?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    slug?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    shortDescription?: StringNullableWithAggregatesFilter<"Project"> | string | null
    type?: EnumProjectTypeWithAggregatesFilter<"Project"> | $Enums.ProjectType
    status?: EnumProjectStatusWithAggregatesFilter<"Project"> | $Enums.ProjectStatus
    category?: EnumProjectCategoryWithAggregatesFilter<"Project"> | $Enums.ProjectCategory
    location?: StringNullableWithAggregatesFilter<"Project"> | string | null
    fundingGoal?: FloatWithAggregatesFilter<"Project"> | number
    amountRaised?: FloatWithAggregatesFilter<"Project"> | number
    currency?: StringWithAggregatesFilter<"Project"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"Project"> | number | null
    ownerId?: StringWithAggregatesFilter<"Project"> | string
    organization?: StringNullableWithAggregatesFilter<"Project"> | string | null
    legalStatus?: StringNullableWithAggregatesFilter<"Project"> | string | null
    website?: StringNullableWithAggregatesFilter<"Project"> | string | null
    socialMedia?: JsonNullableWithAggregatesFilter<"Project">
    contactEmail?: StringNullableWithAggregatesFilter<"Project"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"Project"> | string | null
    impactTypes?: EnumProjectImpactTypeNullableListFilter<"Project">
    impactDescription?: StringNullableWithAggregatesFilter<"Project"> | string | null
    impactIndicators?: StringNullableListFilter<"Project">
    sdgAlignment?: IntNullableListFilter<"Project">
    images?: StringNullableListFilter<"Project">
    videos?: StringNullableListFilter<"Project">
    documents?: StringNullableListFilter<"Project">
    visibility?: EnumPostVisibilityWithAggregatesFilter<"Project"> | $Enums.PostVisibility
    allowComments?: BoolWithAggregatesFilter<"Project"> | boolean
    enableImpactSprint?: BoolWithAggregatesFilter<"Project"> | boolean
    valuation?: FloatNullableWithAggregatesFilter<"Project"> | number | null
    minInvestment?: FloatNullableWithAggregatesFilter<"Project"> | number | null
    capitalPercentage?: FloatNullableWithAggregatesFilter<"Project"> | number | null
    expectedInvestors?: IntNullableWithAggregatesFilter<"Project"> | number | null
    taxAdvantages?: StringNullableWithAggregatesFilter<"Project"> | string | null
    interestRate?: FloatNullableWithAggregatesFilter<"Project"> | number | null
    loanDuration?: IntNullableWithAggregatesFilter<"Project"> | number | null
    repaymentFrequency?: StringNullableWithAggregatesFilter<"Project"> | string | null
    minLoanAmount?: FloatNullableWithAggregatesFilter<"Project"> | number | null
    guarantees?: StringNullableWithAggregatesFilter<"Project"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type ProjectMemberWhereInput = {
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    id?: StringFilter<"ProjectMember"> | string
    projectId?: StringFilter<"ProjectMember"> | string
    userId?: StringFilter<"ProjectMember"> | string
    role?: StringFilter<"ProjectMember"> | string
    joinedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProjectMemberOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_userId?: ProjectMemberProjectIdUserIdCompoundUniqueInput
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    projectId?: StringFilter<"ProjectMember"> | string
    userId?: StringFilter<"ProjectMember"> | string
    role?: StringFilter<"ProjectMember"> | string
    joinedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "projectId_userId">

  export type ProjectMemberOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    _count?: ProjectMemberCountOrderByAggregateInput
    _max?: ProjectMemberMaxOrderByAggregateInput
    _min?: ProjectMemberMinOrderByAggregateInput
  }

  export type ProjectMemberScalarWhereWithAggregatesInput = {
    AND?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    OR?: ProjectMemberScalarWhereWithAggregatesInput[]
    NOT?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectMember"> | string
    projectId?: StringWithAggregatesFilter<"ProjectMember"> | string
    userId?: StringWithAggregatesFilter<"ProjectMember"> | string
    role?: StringWithAggregatesFilter<"ProjectMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"ProjectMember"> | Date | string
  }

  export type ProjectUpdateWhereInput = {
    AND?: ProjectUpdateWhereInput | ProjectUpdateWhereInput[]
    OR?: ProjectUpdateWhereInput[]
    NOT?: ProjectUpdateWhereInput | ProjectUpdateWhereInput[]
    id?: StringFilter<"ProjectUpdate"> | string
    projectId?: StringFilter<"ProjectUpdate"> | string
    title?: StringFilter<"ProjectUpdate"> | string
    content?: StringFilter<"ProjectUpdate"> | string
    images?: StringNullableListFilter<"ProjectUpdate">
    createdAt?: DateTimeFilter<"ProjectUpdate"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectUpdate"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    User?: UserListRelationFilter
  }

  export type ProjectUpdateOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    images?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    User?: UserOrderByRelationAggregateInput
  }

  export type ProjectUpdateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectUpdateWhereInput | ProjectUpdateWhereInput[]
    OR?: ProjectUpdateWhereInput[]
    NOT?: ProjectUpdateWhereInput | ProjectUpdateWhereInput[]
    projectId?: StringFilter<"ProjectUpdate"> | string
    title?: StringFilter<"ProjectUpdate"> | string
    content?: StringFilter<"ProjectUpdate"> | string
    images?: StringNullableListFilter<"ProjectUpdate">
    createdAt?: DateTimeFilter<"ProjectUpdate"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectUpdate"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    User?: UserListRelationFilter
  }, "id">

  export type ProjectUpdateOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    images?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectUpdateCountOrderByAggregateInput
    _max?: ProjectUpdateMaxOrderByAggregateInput
    _min?: ProjectUpdateMinOrderByAggregateInput
  }

  export type ProjectUpdateScalarWhereWithAggregatesInput = {
    AND?: ProjectUpdateScalarWhereWithAggregatesInput | ProjectUpdateScalarWhereWithAggregatesInput[]
    OR?: ProjectUpdateScalarWhereWithAggregatesInput[]
    NOT?: ProjectUpdateScalarWhereWithAggregatesInput | ProjectUpdateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectUpdate"> | string
    projectId?: StringWithAggregatesFilter<"ProjectUpdate"> | string
    title?: StringWithAggregatesFilter<"ProjectUpdate"> | string
    content?: StringWithAggregatesFilter<"ProjectUpdate"> | string
    images?: StringNullableListFilter<"ProjectUpdate">
    createdAt?: DateTimeWithAggregatesFilter<"ProjectUpdate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectUpdate"> | Date | string
  }

  export type ProjectRewardWhereInput = {
    AND?: ProjectRewardWhereInput | ProjectRewardWhereInput[]
    OR?: ProjectRewardWhereInput[]
    NOT?: ProjectRewardWhereInput | ProjectRewardWhereInput[]
    id?: StringFilter<"ProjectReward"> | string
    projectId?: StringFilter<"ProjectReward"> | string
    amount?: FloatFilter<"ProjectReward"> | number
    title?: StringFilter<"ProjectReward"> | string
    description?: StringFilter<"ProjectReward"> | string
    image?: StringNullableFilter<"ProjectReward"> | string | null
    deliveryDate?: DateTimeNullableFilter<"ProjectReward"> | Date | string | null
    quantity?: IntNullableFilter<"ProjectReward"> | number | null
    claimed?: IntFilter<"ProjectReward"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    ProjectDonation?: ProjectDonationListRelationFilter
    User?: UserListRelationFilter
  }

  export type ProjectRewardOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    amount?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrderInput | SortOrder
    deliveryDate?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    claimed?: SortOrder
    project?: ProjectOrderByWithRelationInput
    ProjectDonation?: ProjectDonationOrderByRelationAggregateInput
    User?: UserOrderByRelationAggregateInput
  }

  export type ProjectRewardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectRewardWhereInput | ProjectRewardWhereInput[]
    OR?: ProjectRewardWhereInput[]
    NOT?: ProjectRewardWhereInput | ProjectRewardWhereInput[]
    projectId?: StringFilter<"ProjectReward"> | string
    amount?: FloatFilter<"ProjectReward"> | number
    title?: StringFilter<"ProjectReward"> | string
    description?: StringFilter<"ProjectReward"> | string
    image?: StringNullableFilter<"ProjectReward"> | string | null
    deliveryDate?: DateTimeNullableFilter<"ProjectReward"> | Date | string | null
    quantity?: IntNullableFilter<"ProjectReward"> | number | null
    claimed?: IntFilter<"ProjectReward"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    ProjectDonation?: ProjectDonationListRelationFilter
    User?: UserListRelationFilter
  }, "id">

  export type ProjectRewardOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    amount?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrderInput | SortOrder
    deliveryDate?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    claimed?: SortOrder
    _count?: ProjectRewardCountOrderByAggregateInput
    _avg?: ProjectRewardAvgOrderByAggregateInput
    _max?: ProjectRewardMaxOrderByAggregateInput
    _min?: ProjectRewardMinOrderByAggregateInput
    _sum?: ProjectRewardSumOrderByAggregateInput
  }

  export type ProjectRewardScalarWhereWithAggregatesInput = {
    AND?: ProjectRewardScalarWhereWithAggregatesInput | ProjectRewardScalarWhereWithAggregatesInput[]
    OR?: ProjectRewardScalarWhereWithAggregatesInput[]
    NOT?: ProjectRewardScalarWhereWithAggregatesInput | ProjectRewardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectReward"> | string
    projectId?: StringWithAggregatesFilter<"ProjectReward"> | string
    amount?: FloatWithAggregatesFilter<"ProjectReward"> | number
    title?: StringWithAggregatesFilter<"ProjectReward"> | string
    description?: StringWithAggregatesFilter<"ProjectReward"> | string
    image?: StringNullableWithAggregatesFilter<"ProjectReward"> | string | null
    deliveryDate?: DateTimeNullableWithAggregatesFilter<"ProjectReward"> | Date | string | null
    quantity?: IntNullableWithAggregatesFilter<"ProjectReward"> | number | null
    claimed?: IntWithAggregatesFilter<"ProjectReward"> | number
  }

  export type ProjectDonationWhereInput = {
    AND?: ProjectDonationWhereInput | ProjectDonationWhereInput[]
    OR?: ProjectDonationWhereInput[]
    NOT?: ProjectDonationWhereInput | ProjectDonationWhereInput[]
    id?: StringFilter<"ProjectDonation"> | string
    projectId?: StringFilter<"ProjectDonation"> | string
    userId?: StringFilter<"ProjectDonation"> | string
    amount?: FloatFilter<"ProjectDonation"> | number
    isAnonymous?: BoolFilter<"ProjectDonation"> | boolean
    message?: StringNullableFilter<"ProjectDonation"> | string | null
    rewardId?: StringNullableFilter<"ProjectDonation"> | string | null
    status?: StringFilter<"ProjectDonation"> | string
    createdAt?: DateTimeFilter<"ProjectDonation"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    reward?: XOR<ProjectRewardNullableScalarRelationFilter, ProjectRewardWhereInput> | null
  }

  export type ProjectDonationOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    isAnonymous?: SortOrder
    message?: SortOrderInput | SortOrder
    rewardId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    reward?: ProjectRewardOrderByWithRelationInput
  }

  export type ProjectDonationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectDonationWhereInput | ProjectDonationWhereInput[]
    OR?: ProjectDonationWhereInput[]
    NOT?: ProjectDonationWhereInput | ProjectDonationWhereInput[]
    projectId?: StringFilter<"ProjectDonation"> | string
    userId?: StringFilter<"ProjectDonation"> | string
    amount?: FloatFilter<"ProjectDonation"> | number
    isAnonymous?: BoolFilter<"ProjectDonation"> | boolean
    message?: StringNullableFilter<"ProjectDonation"> | string | null
    rewardId?: StringNullableFilter<"ProjectDonation"> | string | null
    status?: StringFilter<"ProjectDonation"> | string
    createdAt?: DateTimeFilter<"ProjectDonation"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    reward?: XOR<ProjectRewardNullableScalarRelationFilter, ProjectRewardWhereInput> | null
  }, "id">

  export type ProjectDonationOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    isAnonymous?: SortOrder
    message?: SortOrderInput | SortOrder
    rewardId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ProjectDonationCountOrderByAggregateInput
    _avg?: ProjectDonationAvgOrderByAggregateInput
    _max?: ProjectDonationMaxOrderByAggregateInput
    _min?: ProjectDonationMinOrderByAggregateInput
    _sum?: ProjectDonationSumOrderByAggregateInput
  }

  export type ProjectDonationScalarWhereWithAggregatesInput = {
    AND?: ProjectDonationScalarWhereWithAggregatesInput | ProjectDonationScalarWhereWithAggregatesInput[]
    OR?: ProjectDonationScalarWhereWithAggregatesInput[]
    NOT?: ProjectDonationScalarWhereWithAggregatesInput | ProjectDonationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectDonation"> | string
    projectId?: StringWithAggregatesFilter<"ProjectDonation"> | string
    userId?: StringWithAggregatesFilter<"ProjectDonation"> | string
    amount?: FloatWithAggregatesFilter<"ProjectDonation"> | number
    isAnonymous?: BoolWithAggregatesFilter<"ProjectDonation"> | boolean
    message?: StringNullableWithAggregatesFilter<"ProjectDonation"> | string | null
    rewardId?: StringNullableWithAggregatesFilter<"ProjectDonation"> | string | null
    status?: StringWithAggregatesFilter<"ProjectDonation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProjectDonation"> | Date | string
  }

  export type ProjectInvestmentWhereInput = {
    AND?: ProjectInvestmentWhereInput | ProjectInvestmentWhereInput[]
    OR?: ProjectInvestmentWhereInput[]
    NOT?: ProjectInvestmentWhereInput | ProjectInvestmentWhereInput[]
    id?: StringFilter<"ProjectInvestment"> | string
    projectId?: StringFilter<"ProjectInvestment"> | string
    userId?: StringFilter<"ProjectInvestment"> | string
    amount?: FloatFilter<"ProjectInvestment"> | number
    shares?: FloatNullableFilter<"ProjectInvestment"> | number | null
    status?: StringFilter<"ProjectInvestment"> | string
    createdAt?: DateTimeFilter<"ProjectInvestment"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProjectInvestmentOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    shares?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectInvestmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectInvestmentWhereInput | ProjectInvestmentWhereInput[]
    OR?: ProjectInvestmentWhereInput[]
    NOT?: ProjectInvestmentWhereInput | ProjectInvestmentWhereInput[]
    projectId?: StringFilter<"ProjectInvestment"> | string
    userId?: StringFilter<"ProjectInvestment"> | string
    amount?: FloatFilter<"ProjectInvestment"> | number
    shares?: FloatNullableFilter<"ProjectInvestment"> | number | null
    status?: StringFilter<"ProjectInvestment"> | string
    createdAt?: DateTimeFilter<"ProjectInvestment"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ProjectInvestmentOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    shares?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ProjectInvestmentCountOrderByAggregateInput
    _avg?: ProjectInvestmentAvgOrderByAggregateInput
    _max?: ProjectInvestmentMaxOrderByAggregateInput
    _min?: ProjectInvestmentMinOrderByAggregateInput
    _sum?: ProjectInvestmentSumOrderByAggregateInput
  }

  export type ProjectInvestmentScalarWhereWithAggregatesInput = {
    AND?: ProjectInvestmentScalarWhereWithAggregatesInput | ProjectInvestmentScalarWhereWithAggregatesInput[]
    OR?: ProjectInvestmentScalarWhereWithAggregatesInput[]
    NOT?: ProjectInvestmentScalarWhereWithAggregatesInput | ProjectInvestmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectInvestment"> | string
    projectId?: StringWithAggregatesFilter<"ProjectInvestment"> | string
    userId?: StringWithAggregatesFilter<"ProjectInvestment"> | string
    amount?: FloatWithAggregatesFilter<"ProjectInvestment"> | number
    shares?: FloatNullableWithAggregatesFilter<"ProjectInvestment"> | number | null
    status?: StringWithAggregatesFilter<"ProjectInvestment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProjectInvestment"> | Date | string
  }

  export type ProjectLoanWhereInput = {
    AND?: ProjectLoanWhereInput | ProjectLoanWhereInput[]
    OR?: ProjectLoanWhereInput[]
    NOT?: ProjectLoanWhereInput | ProjectLoanWhereInput[]
    id?: StringFilter<"ProjectLoan"> | string
    projectId?: StringFilter<"ProjectLoan"> | string
    userId?: StringFilter<"ProjectLoan"> | string
    amount?: FloatFilter<"ProjectLoan"> | number
    status?: StringFilter<"ProjectLoan"> | string
    createdAt?: DateTimeFilter<"ProjectLoan"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProjectLoanOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectLoanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectLoanWhereInput | ProjectLoanWhereInput[]
    OR?: ProjectLoanWhereInput[]
    NOT?: ProjectLoanWhereInput | ProjectLoanWhereInput[]
    projectId?: StringFilter<"ProjectLoan"> | string
    userId?: StringFilter<"ProjectLoan"> | string
    amount?: FloatFilter<"ProjectLoan"> | number
    status?: StringFilter<"ProjectLoan"> | string
    createdAt?: DateTimeFilter<"ProjectLoan"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ProjectLoanOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ProjectLoanCountOrderByAggregateInput
    _avg?: ProjectLoanAvgOrderByAggregateInput
    _max?: ProjectLoanMaxOrderByAggregateInput
    _min?: ProjectLoanMinOrderByAggregateInput
    _sum?: ProjectLoanSumOrderByAggregateInput
  }

  export type ProjectLoanScalarWhereWithAggregatesInput = {
    AND?: ProjectLoanScalarWhereWithAggregatesInput | ProjectLoanScalarWhereWithAggregatesInput[]
    OR?: ProjectLoanScalarWhereWithAggregatesInput[]
    NOT?: ProjectLoanScalarWhereWithAggregatesInput | ProjectLoanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectLoan"> | string
    projectId?: StringWithAggregatesFilter<"ProjectLoan"> | string
    userId?: StringWithAggregatesFilter<"ProjectLoan"> | string
    amount?: FloatWithAggregatesFilter<"ProjectLoan"> | number
    status?: StringWithAggregatesFilter<"ProjectLoan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProjectLoan"> | Date | string
  }

  export type CircleWhereInput = {
    AND?: CircleWhereInput | CircleWhereInput[]
    OR?: CircleWhereInput[]
    NOT?: CircleWhereInput | CircleWhereInput[]
    id?: StringFilter<"Circle"> | string
    name?: StringFilter<"Circle"> | string
    slug?: StringFilter<"Circle"> | string
    description?: StringNullableFilter<"Circle"> | string | null
    type?: EnumCircleTypeFilter<"Circle"> | $Enums.CircleType
    theme?: StringNullableFilter<"Circle"> | string | null
    participationMode?: EnumCircleParticipationModeFilter<"Circle"> | $Enums.CircleParticipationMode
    maxMembers?: IntNullableFilter<"Circle"> | number | null
    isPublic?: BoolFilter<"Circle"> | boolean
    isActive?: BoolFilter<"Circle"> | boolean
    monthlyFee?: FloatNullableFilter<"Circle"> | number | null
    funds?: FloatFilter<"Circle"> | number
    allocatedFunds?: FloatFilter<"Circle"> | number
    creatorId?: StringFilter<"Circle"> | string
    createdAt?: DateTimeFilter<"Circle"> | Date | string
    updatedAt?: DateTimeFilter<"Circle"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: CircleMemberListRelationFilter
    projects?: CircleProjectListRelationFilter
    Transaction?: TransactionListRelationFilter
  }

  export type CircleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    theme?: SortOrderInput | SortOrder
    participationMode?: SortOrder
    maxMembers?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    isActive?: SortOrder
    monthlyFee?: SortOrderInput | SortOrder
    funds?: SortOrder
    allocatedFunds?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    members?: CircleMemberOrderByRelationAggregateInput
    projects?: CircleProjectOrderByRelationAggregateInput
    Transaction?: TransactionOrderByRelationAggregateInput
  }

  export type CircleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CircleWhereInput | CircleWhereInput[]
    OR?: CircleWhereInput[]
    NOT?: CircleWhereInput | CircleWhereInput[]
    name?: StringFilter<"Circle"> | string
    description?: StringNullableFilter<"Circle"> | string | null
    type?: EnumCircleTypeFilter<"Circle"> | $Enums.CircleType
    theme?: StringNullableFilter<"Circle"> | string | null
    participationMode?: EnumCircleParticipationModeFilter<"Circle"> | $Enums.CircleParticipationMode
    maxMembers?: IntNullableFilter<"Circle"> | number | null
    isPublic?: BoolFilter<"Circle"> | boolean
    isActive?: BoolFilter<"Circle"> | boolean
    monthlyFee?: FloatNullableFilter<"Circle"> | number | null
    funds?: FloatFilter<"Circle"> | number
    allocatedFunds?: FloatFilter<"Circle"> | number
    creatorId?: StringFilter<"Circle"> | string
    createdAt?: DateTimeFilter<"Circle"> | Date | string
    updatedAt?: DateTimeFilter<"Circle"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: CircleMemberListRelationFilter
    projects?: CircleProjectListRelationFilter
    Transaction?: TransactionListRelationFilter
  }, "id" | "slug">

  export type CircleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    theme?: SortOrderInput | SortOrder
    participationMode?: SortOrder
    maxMembers?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    isActive?: SortOrder
    monthlyFee?: SortOrderInput | SortOrder
    funds?: SortOrder
    allocatedFunds?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CircleCountOrderByAggregateInput
    _avg?: CircleAvgOrderByAggregateInput
    _max?: CircleMaxOrderByAggregateInput
    _min?: CircleMinOrderByAggregateInput
    _sum?: CircleSumOrderByAggregateInput
  }

  export type CircleScalarWhereWithAggregatesInput = {
    AND?: CircleScalarWhereWithAggregatesInput | CircleScalarWhereWithAggregatesInput[]
    OR?: CircleScalarWhereWithAggregatesInput[]
    NOT?: CircleScalarWhereWithAggregatesInput | CircleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Circle"> | string
    name?: StringWithAggregatesFilter<"Circle"> | string
    slug?: StringWithAggregatesFilter<"Circle"> | string
    description?: StringNullableWithAggregatesFilter<"Circle"> | string | null
    type?: EnumCircleTypeWithAggregatesFilter<"Circle"> | $Enums.CircleType
    theme?: StringNullableWithAggregatesFilter<"Circle"> | string | null
    participationMode?: EnumCircleParticipationModeWithAggregatesFilter<"Circle"> | $Enums.CircleParticipationMode
    maxMembers?: IntNullableWithAggregatesFilter<"Circle"> | number | null
    isPublic?: BoolWithAggregatesFilter<"Circle"> | boolean
    isActive?: BoolWithAggregatesFilter<"Circle"> | boolean
    monthlyFee?: FloatNullableWithAggregatesFilter<"Circle"> | number | null
    funds?: FloatWithAggregatesFilter<"Circle"> | number
    allocatedFunds?: FloatWithAggregatesFilter<"Circle"> | number
    creatorId?: StringWithAggregatesFilter<"Circle"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Circle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Circle"> | Date | string
  }

  export type CircleMemberWhereInput = {
    AND?: CircleMemberWhereInput | CircleMemberWhereInput[]
    OR?: CircleMemberWhereInput[]
    NOT?: CircleMemberWhereInput | CircleMemberWhereInput[]
    id?: StringFilter<"CircleMember"> | string
    circleId?: StringFilter<"CircleMember"> | string
    userId?: StringFilter<"CircleMember"> | string
    role?: EnumCircleMemberRoleFilter<"CircleMember"> | $Enums.CircleMemberRole
    joinedAt?: DateTimeFilter<"CircleMember"> | Date | string
    xp?: IntFilter<"CircleMember"> | number
    level?: IntFilter<"CircleMember"> | number
    circle?: XOR<CircleScalarRelationFilter, CircleWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CircleMemberOrderByWithRelationInput = {
    id?: SortOrder
    circleId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    xp?: SortOrder
    level?: SortOrder
    circle?: CircleOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CircleMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    circleId_userId?: CircleMemberCircleIdUserIdCompoundUniqueInput
    AND?: CircleMemberWhereInput | CircleMemberWhereInput[]
    OR?: CircleMemberWhereInput[]
    NOT?: CircleMemberWhereInput | CircleMemberWhereInput[]
    circleId?: StringFilter<"CircleMember"> | string
    userId?: StringFilter<"CircleMember"> | string
    role?: EnumCircleMemberRoleFilter<"CircleMember"> | $Enums.CircleMemberRole
    joinedAt?: DateTimeFilter<"CircleMember"> | Date | string
    xp?: IntFilter<"CircleMember"> | number
    level?: IntFilter<"CircleMember"> | number
    circle?: XOR<CircleScalarRelationFilter, CircleWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "circleId_userId">

  export type CircleMemberOrderByWithAggregationInput = {
    id?: SortOrder
    circleId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    xp?: SortOrder
    level?: SortOrder
    _count?: CircleMemberCountOrderByAggregateInput
    _avg?: CircleMemberAvgOrderByAggregateInput
    _max?: CircleMemberMaxOrderByAggregateInput
    _min?: CircleMemberMinOrderByAggregateInput
    _sum?: CircleMemberSumOrderByAggregateInput
  }

  export type CircleMemberScalarWhereWithAggregatesInput = {
    AND?: CircleMemberScalarWhereWithAggregatesInput | CircleMemberScalarWhereWithAggregatesInput[]
    OR?: CircleMemberScalarWhereWithAggregatesInput[]
    NOT?: CircleMemberScalarWhereWithAggregatesInput | CircleMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CircleMember"> | string
    circleId?: StringWithAggregatesFilter<"CircleMember"> | string
    userId?: StringWithAggregatesFilter<"CircleMember"> | string
    role?: EnumCircleMemberRoleWithAggregatesFilter<"CircleMember"> | $Enums.CircleMemberRole
    joinedAt?: DateTimeWithAggregatesFilter<"CircleMember"> | Date | string
    xp?: IntWithAggregatesFilter<"CircleMember"> | number
    level?: IntWithAggregatesFilter<"CircleMember"> | number
  }

  export type CircleProjectWhereInput = {
    AND?: CircleProjectWhereInput | CircleProjectWhereInput[]
    OR?: CircleProjectWhereInput[]
    NOT?: CircleProjectWhereInput | CircleProjectWhereInput[]
    id?: StringFilter<"CircleProject"> | string
    circleId?: StringFilter<"CircleProject"> | string
    projectId?: StringFilter<"CircleProject"> | string
    allocatedAmount?: FloatFilter<"CircleProject"> | number
    supportType?: StringFilter<"CircleProject"> | string
    votedAt?: DateTimeNullableFilter<"CircleProject"> | Date | string | null
    status?: StringFilter<"CircleProject"> | string
    circle?: XOR<CircleScalarRelationFilter, CircleWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type CircleProjectOrderByWithRelationInput = {
    id?: SortOrder
    circleId?: SortOrder
    projectId?: SortOrder
    allocatedAmount?: SortOrder
    supportType?: SortOrder
    votedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    circle?: CircleOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type CircleProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    circleId_projectId?: CircleProjectCircleIdProjectIdCompoundUniqueInput
    AND?: CircleProjectWhereInput | CircleProjectWhereInput[]
    OR?: CircleProjectWhereInput[]
    NOT?: CircleProjectWhereInput | CircleProjectWhereInput[]
    circleId?: StringFilter<"CircleProject"> | string
    projectId?: StringFilter<"CircleProject"> | string
    allocatedAmount?: FloatFilter<"CircleProject"> | number
    supportType?: StringFilter<"CircleProject"> | string
    votedAt?: DateTimeNullableFilter<"CircleProject"> | Date | string | null
    status?: StringFilter<"CircleProject"> | string
    circle?: XOR<CircleScalarRelationFilter, CircleWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id" | "circleId_projectId">

  export type CircleProjectOrderByWithAggregationInput = {
    id?: SortOrder
    circleId?: SortOrder
    projectId?: SortOrder
    allocatedAmount?: SortOrder
    supportType?: SortOrder
    votedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: CircleProjectCountOrderByAggregateInput
    _avg?: CircleProjectAvgOrderByAggregateInput
    _max?: CircleProjectMaxOrderByAggregateInput
    _min?: CircleProjectMinOrderByAggregateInput
    _sum?: CircleProjectSumOrderByAggregateInput
  }

  export type CircleProjectScalarWhereWithAggregatesInput = {
    AND?: CircleProjectScalarWhereWithAggregatesInput | CircleProjectScalarWhereWithAggregatesInput[]
    OR?: CircleProjectScalarWhereWithAggregatesInput[]
    NOT?: CircleProjectScalarWhereWithAggregatesInput | CircleProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CircleProject"> | string
    circleId?: StringWithAggregatesFilter<"CircleProject"> | string
    projectId?: StringWithAggregatesFilter<"CircleProject"> | string
    allocatedAmount?: FloatWithAggregatesFilter<"CircleProject"> | number
    supportType?: StringWithAggregatesFilter<"CircleProject"> | string
    votedAt?: DateTimeNullableWithAggregatesFilter<"CircleProject"> | Date | string | null
    status?: StringWithAggregatesFilter<"CircleProject"> | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    type?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    currency?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    description?: StringNullableFilter<"Transaction"> | string | null
    projectId?: StringNullableFilter<"Transaction"> | string | null
    circleId?: StringNullableFilter<"Transaction"> | string | null
    metadata?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    circle?: XOR<CircleNullableScalarRelationFilter, CircleWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    circleId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    circle?: CircleOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    userId?: StringFilter<"Transaction"> | string
    type?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    currency?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    description?: StringNullableFilter<"Transaction"> | string | null
    projectId?: StringNullableFilter<"Transaction"> | string | null
    circleId?: StringNullableFilter<"Transaction"> | string | null
    metadata?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    circle?: XOR<CircleNullableScalarRelationFilter, CircleWhereInput> | null
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    circleId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    userId?: StringWithAggregatesFilter<"Transaction"> | string
    type?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    currency?: StringWithAggregatesFilter<"Transaction"> | string
    status?: StringWithAggregatesFilter<"Transaction"> | string
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    projectId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    circleId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Transaction">
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type UserXPWhereInput = {
    AND?: UserXPWhereInput | UserXPWhereInput[]
    OR?: UserXPWhereInput[]
    NOT?: UserXPWhereInput | UserXPWhereInput[]
    id?: StringFilter<"UserXP"> | string
    userId?: StringFilter<"UserXP"> | string
    totalXP?: IntFilter<"UserXP"> | number
    level?: IntFilter<"UserXP"> | number
    impactRank?: StringNullableFilter<"UserXP"> | string | null
    donationXP?: IntFilter<"UserXP"> | number
    investmentXP?: IntFilter<"UserXP"> | number
    contentXP?: IntFilter<"UserXP"> | number
    communityXP?: IntFilter<"UserXP"> | number
    createdAt?: DateTimeFilter<"UserXP"> | Date | string
    updatedAt?: DateTimeFilter<"UserXP"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserXPOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalXP?: SortOrder
    level?: SortOrder
    impactRank?: SortOrderInput | SortOrder
    donationXP?: SortOrder
    investmentXP?: SortOrder
    contentXP?: SortOrder
    communityXP?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserXPWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserXPWhereInput | UserXPWhereInput[]
    OR?: UserXPWhereInput[]
    NOT?: UserXPWhereInput | UserXPWhereInput[]
    totalXP?: IntFilter<"UserXP"> | number
    level?: IntFilter<"UserXP"> | number
    impactRank?: StringNullableFilter<"UserXP"> | string | null
    donationXP?: IntFilter<"UserXP"> | number
    investmentXP?: IntFilter<"UserXP"> | number
    contentXP?: IntFilter<"UserXP"> | number
    communityXP?: IntFilter<"UserXP"> | number
    createdAt?: DateTimeFilter<"UserXP"> | Date | string
    updatedAt?: DateTimeFilter<"UserXP"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserXPOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalXP?: SortOrder
    level?: SortOrder
    impactRank?: SortOrderInput | SortOrder
    donationXP?: SortOrder
    investmentXP?: SortOrder
    contentXP?: SortOrder
    communityXP?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserXPCountOrderByAggregateInput
    _avg?: UserXPAvgOrderByAggregateInput
    _max?: UserXPMaxOrderByAggregateInput
    _min?: UserXPMinOrderByAggregateInput
    _sum?: UserXPSumOrderByAggregateInput
  }

  export type UserXPScalarWhereWithAggregatesInput = {
    AND?: UserXPScalarWhereWithAggregatesInput | UserXPScalarWhereWithAggregatesInput[]
    OR?: UserXPScalarWhereWithAggregatesInput[]
    NOT?: UserXPScalarWhereWithAggregatesInput | UserXPScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserXP"> | string
    userId?: StringWithAggregatesFilter<"UserXP"> | string
    totalXP?: IntWithAggregatesFilter<"UserXP"> | number
    level?: IntWithAggregatesFilter<"UserXP"> | number
    impactRank?: StringNullableWithAggregatesFilter<"UserXP"> | string | null
    donationXP?: IntWithAggregatesFilter<"UserXP"> | number
    investmentXP?: IntWithAggregatesFilter<"UserXP"> | number
    contentXP?: IntWithAggregatesFilter<"UserXP"> | number
    communityXP?: IntWithAggregatesFilter<"UserXP"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserXP"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserXP"> | Date | string
  }

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    id?: StringFilter<"Badge"> | string
    name?: StringFilter<"Badge"> | string
    description?: StringNullableFilter<"Badge"> | string | null
    image?: StringNullableFilter<"Badge"> | string | null
    criteria?: JsonNullableFilter<"Badge">
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    users?: UserBadgeListRelationFilter
  }

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    criteria?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    users?: UserBadgeOrderByRelationAggregateInput
  }

  export type BadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    name?: StringFilter<"Badge"> | string
    description?: StringNullableFilter<"Badge"> | string | null
    image?: StringNullableFilter<"Badge"> | string | null
    criteria?: JsonNullableFilter<"Badge">
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    users?: UserBadgeListRelationFilter
  }, "id">

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    criteria?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BadgeCountOrderByAggregateInput
    _max?: BadgeMaxOrderByAggregateInput
    _min?: BadgeMinOrderByAggregateInput
  }

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    OR?: BadgeScalarWhereWithAggregatesInput[]
    NOT?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Badge"> | string
    name?: StringWithAggregatesFilter<"Badge"> | string
    description?: StringNullableWithAggregatesFilter<"Badge"> | string | null
    image?: StringNullableWithAggregatesFilter<"Badge"> | string | null
    criteria?: JsonNullableWithAggregatesFilter<"Badge">
    createdAt?: DateTimeWithAggregatesFilter<"Badge"> | Date | string
  }

  export type UserBadgeWhereInput = {
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    id?: StringFilter<"UserBadge"> | string
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: StringFilter<"UserBadge"> | string
    earnedAt?: DateTimeFilter<"UserBadge"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    badge?: XOR<BadgeScalarRelationFilter, BadgeWhereInput>
  }

  export type UserBadgeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    badge?: BadgeOrderByWithRelationInput
  }

  export type UserBadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_badgeId?: UserBadgeUserIdBadgeIdCompoundUniqueInput
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: StringFilter<"UserBadge"> | string
    earnedAt?: DateTimeFilter<"UserBadge"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    badge?: XOR<BadgeScalarRelationFilter, BadgeWhereInput>
  }, "id" | "userId_badgeId">

  export type UserBadgeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
    _count?: UserBadgeCountOrderByAggregateInput
    _max?: UserBadgeMaxOrderByAggregateInput
    _min?: UserBadgeMinOrderByAggregateInput
  }

  export type UserBadgeScalarWhereWithAggregatesInput = {
    AND?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    OR?: UserBadgeScalarWhereWithAggregatesInput[]
    NOT?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserBadge"> | string
    userId?: StringWithAggregatesFilter<"UserBadge"> | string
    badgeId?: StringWithAggregatesFilter<"UserBadge"> | string
    earnedAt?: DateTimeWithAggregatesFilter<"UserBadge"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedManyWithoutUserInput
    adress?: adressCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutAuthorInput
    Project?: ProjectCreateNestedManyWithoutOwnerInput
    Circle?: CircleCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeCreateNestedManyWithoutUserInput
    UserXP?: UserXPCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    adress?: adressUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutAuthorInput
    Project?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    Circle?: CircleUncheckedCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanUncheckedCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateUncheckedCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardUncheckedCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    UserXP?: UserXPUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateManyWithoutUserNestedInput
    adress?: adressUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    adress?: adressUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUncheckedUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUncheckedUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUncheckedUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    age?: number | null
    profession?: string | null
    motivation?: string | null
    interests?: ProfileCreateinterestsInput | string[]
    experience?: string | null
    disponibility?: string | null
    bio?: string | null
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    phoneVerified?: boolean
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    age?: number | null
    profession?: string | null
    motivation?: string | null
    interests?: ProfileCreateinterestsInput | string[]
    experience?: string | null
    disponibility?: string | null
    bio?: string | null
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    phoneVerified?: boolean
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    motivation?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: ProfileUpdateinterestsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    disponibility?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    motivation?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: ProfileUpdateinterestsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    disponibility?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    age?: number | null
    profession?: string | null
    motivation?: string | null
    interests?: ProfileCreateinterestsInput | string[]
    experience?: string | null
    disponibility?: string | null
    bio?: string | null
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    phoneVerified?: boolean
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    motivation?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: ProfileUpdateinterestsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    disponibility?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    motivation?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: ProfileUpdateinterestsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    disponibility?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type adressCreateInput = {
    id?: string
    street?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    user: UserCreateNestedOneWithoutAdressInput
  }

  export type adressUncheckedCreateInput = {
    id?: string
    userId: string
    street?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
  }

  export type adressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAdressNestedInput
  }

  export type adressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type adressCreateManyInput = {
    id?: string
    userId: string
    street?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
  }

  export type adressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type adressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostCreateInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostInput
    parent?: PostCreateNestedOneWithoutChildrenInput
    children?: PostCreateNestedManyWithoutParentInput
    attachments?: MediaAssetCreateNestedManyWithoutPostInput
    codeSnippets?: CodeSnippetCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    project?: ProjectCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    authorId: string
    parentId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PostUncheckedCreateNestedManyWithoutParentInput
    attachments?: MediaAssetUncheckedCreateNestedManyWithoutPostInput
    codeSnippets?: CodeSnippetUncheckedCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsUncheckedCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostNestedInput
    parent?: PostUpdateOneWithoutChildrenNestedInput
    children?: PostUpdateManyWithoutParentNestedInput
    attachments?: MediaAssetUpdateManyWithoutPostNestedInput
    codeSnippets?: CodeSnippetUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    project?: ProjectUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PostUncheckedUpdateManyWithoutParentNestedInput
    attachments?: MediaAssetUncheckedUpdateManyWithoutPostNestedInput
    codeSnippets?: CodeSnippetUncheckedUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUncheckedUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    authorId: string
    parentId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAssetCreateInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    provider?: string | null
    title?: string | null
    alt?: string | null
    caption?: string | null
    position?: number | null
    mimeType?: string | null
    sizeBytes?: number | null
    width?: number | null
    height?: number | null
    durationMs?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutAttachmentsInput
  }

  export type MediaAssetUncheckedCreateInput = {
    id?: string
    postId: string
    type: $Enums.MediaType
    url: string
    provider?: string | null
    title?: string | null
    alt?: string | null
    caption?: string | null
    position?: number | null
    mimeType?: string | null
    sizeBytes?: number | null
    width?: number | null
    height?: number | null
    durationMs?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaAssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type MediaAssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAssetCreateManyInput = {
    id?: string
    postId: string
    type: $Enums.MediaType
    url: string
    provider?: string | null
    title?: string | null
    alt?: string | null
    caption?: string | null
    position?: number | null
    mimeType?: string | null
    sizeBytes?: number | null
    width?: number | null
    height?: number | null
    durationMs?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaAssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSnippetCreateInput = {
    id?: string
    title?: string | null
    language: string
    filename?: string | null
    code: string
    highlightedHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutCodeSnippetsInput
  }

  export type CodeSnippetUncheckedCreateInput = {
    id?: string
    postId: string
    title?: string | null
    language: string
    filename?: string | null
    code: string
    highlightedHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeSnippetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    highlightedHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCodeSnippetsNestedInput
  }

  export type CodeSnippetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    highlightedHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSnippetCreateManyInput = {
    id?: string
    postId: string
    title?: string | null
    language: string
    filename?: string | null
    code: string
    highlightedHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeSnippetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    highlightedHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSnippetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    highlightedHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsOnTagsCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsOnTagsUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsOnTagsUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsOnTagsUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsOnTagsCreateInput = {
    assignedAt?: Date | string
    assignedBy?: string | null
    post: PostCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutPostsInput
  }

  export type PostsOnTagsUncheckedCreateInput = {
    postId: string
    tagId: string
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type PostsOnTagsUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    post?: PostUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostsOnTagsUncheckedUpdateInput = {
    postId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostsOnTagsCreateManyInput = {
    postId: string
    tagId: string
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type PostsOnTagsUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostsOnTagsUncheckedUpdateManyInput = {
    postId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    posts?: PostsOnCategoriesCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    posts?: PostsOnCategoriesUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    posts?: PostsOnCategoriesUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    posts?: PostsOnCategoriesUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsOnCategoriesCreateInput = {
    position?: number | null
    assignedAt?: Date | string
    post: PostCreateNestedOneWithoutCategoriesInput
    category: CategoryCreateNestedOneWithoutPostsInput
  }

  export type PostsOnCategoriesUncheckedCreateInput = {
    postId: string
    categoryId: string
    position?: number | null
    assignedAt?: Date | string
  }

  export type PostsOnCategoriesUpdateInput = {
    position?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCategoriesNestedInput
    category?: CategoryUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostsOnCategoriesUncheckedUpdateInput = {
    postId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsOnCategoriesCreateManyInput = {
    postId: string
    categoryId: string
    position?: number | null
    assignedAt?: Date | string
  }

  export type PostsOnCategoriesUpdateManyMutationInput = {
    position?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsOnCategoriesUncheckedUpdateManyInput = {
    postId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    status?: $Enums.CommentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    postId: string
    authorId: string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    status?: $Enums.CommentStatus
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    postId: string
    authorId: string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    status?: $Enums.CommentStatus
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionCreateInput = {
    id?: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutReactionsInput
    user: UserCreateNestedOneWithoutReactionInput
  }

  export type ReactionUncheckedCreateInput = {
    id?: string
    postId: string
    userId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type ReactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutReactionsNestedInput
    user?: UserUpdateOneRequiredWithoutReactionNestedInput
  }

  export type ReactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionCreateManyInput = {
    id?: string
    postId: string
    userId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type ReactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutProjectInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    posts?: PostCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanCreateNestedManyWithoutProjectInput
    Transaction?: TransactionCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    ownerId: string
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    posts?: PostUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardUncheckedCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationUncheckedCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentUncheckedCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanUncheckedCreateNestedManyWithoutProjectInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutProjectNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    posts?: PostUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    posts?: PostUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUncheckedUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUncheckedUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUncheckedUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUncheckedUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    ownerId: string
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateInput = {
    id?: string
    role: string
    joinedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutProjectMemberInput
  }

  export type ProjectMemberUncheckedCreateInput = {
    id?: string
    projectId: string
    userId: string
    role: string
    joinedAt?: Date | string
  }

  export type ProjectMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutProjectMemberNestedInput
  }

  export type ProjectMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateManyInput = {
    id?: string
    projectId: string
    userId: string
    role: string
    joinedAt?: Date | string
  }

  export type ProjectMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateCreateInput = {
    id?: string
    title: string
    content: string
    images?: ProjectUpdateCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutUpdatesInput
    User?: UserCreateNestedManyWithoutProjectUpdateInput
  }

  export type ProjectUpdateUncheckedCreateInput = {
    id?: string
    projectId: string
    title: string
    content: string
    images?: ProjectUpdateCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    User?: UserUncheckedCreateNestedManyWithoutProjectUpdateInput
  }

  export type ProjectUpdateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ProjectUpdateUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUpdatesNestedInput
    User?: UserUpdateManyWithoutProjectUpdateNestedInput
  }

  export type ProjectUpdateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ProjectUpdateUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUncheckedUpdateManyWithoutProjectUpdateNestedInput
  }

  export type ProjectUpdateCreateManyInput = {
    id?: string
    projectId: string
    title: string
    content: string
    images?: ProjectUpdateCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ProjectUpdateUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ProjectUpdateUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectRewardCreateInput = {
    id?: string
    amount: number
    title: string
    description: string
    image?: string | null
    deliveryDate?: Date | string | null
    quantity?: number | null
    claimed?: number
    project: ProjectCreateNestedOneWithoutRewardsInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutRewardInput
    User?: UserCreateNestedManyWithoutProjectRewardInput
  }

  export type ProjectRewardUncheckedCreateInput = {
    id?: string
    projectId: string
    amount: number
    title: string
    description: string
    image?: string | null
    deliveryDate?: Date | string | null
    quantity?: number | null
    claimed?: number
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutRewardInput
    User?: UserUncheckedCreateNestedManyWithoutProjectRewardInput
  }

  export type ProjectRewardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    claimed?: IntFieldUpdateOperationsInput | number
    project?: ProjectUpdateOneRequiredWithoutRewardsNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutRewardNestedInput
    User?: UserUpdateManyWithoutProjectRewardNestedInput
  }

  export type ProjectRewardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    claimed?: IntFieldUpdateOperationsInput | number
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutRewardNestedInput
    User?: UserUncheckedUpdateManyWithoutProjectRewardNestedInput
  }

  export type ProjectRewardCreateManyInput = {
    id?: string
    projectId: string
    amount: number
    title: string
    description: string
    image?: string | null
    deliveryDate?: Date | string | null
    quantity?: number | null
    claimed?: number
  }

  export type ProjectRewardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    claimed?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectRewardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    claimed?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectDonationCreateInput = {
    id?: string
    amount: number
    isAnonymous?: boolean
    message?: string | null
    status?: string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutDonationsInput
    user: UserCreateNestedOneWithoutProjectDonationInput
    reward?: ProjectRewardCreateNestedOneWithoutProjectDonationInput
  }

  export type ProjectDonationUncheckedCreateInput = {
    id?: string
    projectId: string
    userId: string
    amount: number
    isAnonymous?: boolean
    message?: string | null
    rewardId?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type ProjectDonationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDonationsNestedInput
    user?: UserUpdateOneRequiredWithoutProjectDonationNestedInput
    reward?: ProjectRewardUpdateOneWithoutProjectDonationNestedInput
  }

  export type ProjectDonationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    rewardId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDonationCreateManyInput = {
    id?: string
    projectId: string
    userId: string
    amount: number
    isAnonymous?: boolean
    message?: string | null
    rewardId?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type ProjectDonationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDonationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    rewardId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInvestmentCreateInput = {
    id?: string
    amount: number
    shares?: number | null
    status?: string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutInvestmentsInput
    user: UserCreateNestedOneWithoutProjectInvestmentInput
  }

  export type ProjectInvestmentUncheckedCreateInput = {
    id?: string
    projectId: string
    userId: string
    amount: number
    shares?: number | null
    status?: string
    createdAt?: Date | string
  }

  export type ProjectInvestmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    shares?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutInvestmentsNestedInput
    user?: UserUpdateOneRequiredWithoutProjectInvestmentNestedInput
  }

  export type ProjectInvestmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    shares?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInvestmentCreateManyInput = {
    id?: string
    projectId: string
    userId: string
    amount: number
    shares?: number | null
    status?: string
    createdAt?: Date | string
  }

  export type ProjectInvestmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    shares?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInvestmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    shares?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectLoanCreateInput = {
    id?: string
    amount: number
    status?: string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutLoansInput
    user: UserCreateNestedOneWithoutProjectLoanInput
  }

  export type ProjectLoanUncheckedCreateInput = {
    id?: string
    projectId: string
    userId: string
    amount: number
    status?: string
    createdAt?: Date | string
  }

  export type ProjectLoanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutLoansNestedInput
    user?: UserUpdateOneRequiredWithoutProjectLoanNestedInput
  }

  export type ProjectLoanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectLoanCreateManyInput = {
    id?: string
    projectId: string
    userId: string
    amount: number
    status?: string
    createdAt?: Date | string
  }

  export type ProjectLoanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectLoanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CircleCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: $Enums.CircleType
    theme?: string | null
    participationMode: $Enums.CircleParticipationMode
    maxMembers?: number | null
    isPublic?: boolean
    isActive?: boolean
    monthlyFee?: number | null
    funds?: number
    allocatedFunds?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCircleInput
    members?: CircleMemberCreateNestedManyWithoutCircleInput
    projects?: CircleProjectCreateNestedManyWithoutCircleInput
    Transaction?: TransactionCreateNestedManyWithoutCircleInput
  }

  export type CircleUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: $Enums.CircleType
    theme?: string | null
    participationMode: $Enums.CircleParticipationMode
    maxMembers?: number | null
    isPublic?: boolean
    isActive?: boolean
    monthlyFee?: number | null
    funds?: number
    allocatedFunds?: number
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CircleMemberUncheckedCreateNestedManyWithoutCircleInput
    projects?: CircleProjectUncheckedCreateNestedManyWithoutCircleInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutCircleInput
  }

  export type CircleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCircleTypeFieldUpdateOperationsInput | $Enums.CircleType
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    participationMode?: EnumCircleParticipationModeFieldUpdateOperationsInput | $Enums.CircleParticipationMode
    maxMembers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    funds?: FloatFieldUpdateOperationsInput | number
    allocatedFunds?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCircleNestedInput
    members?: CircleMemberUpdateManyWithoutCircleNestedInput
    projects?: CircleProjectUpdateManyWithoutCircleNestedInput
    Transaction?: TransactionUpdateManyWithoutCircleNestedInput
  }

  export type CircleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCircleTypeFieldUpdateOperationsInput | $Enums.CircleType
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    participationMode?: EnumCircleParticipationModeFieldUpdateOperationsInput | $Enums.CircleParticipationMode
    maxMembers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    funds?: FloatFieldUpdateOperationsInput | number
    allocatedFunds?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CircleMemberUncheckedUpdateManyWithoutCircleNestedInput
    projects?: CircleProjectUncheckedUpdateManyWithoutCircleNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutCircleNestedInput
  }

  export type CircleCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: $Enums.CircleType
    theme?: string | null
    participationMode: $Enums.CircleParticipationMode
    maxMembers?: number | null
    isPublic?: boolean
    isActive?: boolean
    monthlyFee?: number | null
    funds?: number
    allocatedFunds?: number
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CircleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCircleTypeFieldUpdateOperationsInput | $Enums.CircleType
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    participationMode?: EnumCircleParticipationModeFieldUpdateOperationsInput | $Enums.CircleParticipationMode
    maxMembers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    funds?: FloatFieldUpdateOperationsInput | number
    allocatedFunds?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CircleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCircleTypeFieldUpdateOperationsInput | $Enums.CircleType
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    participationMode?: EnumCircleParticipationModeFieldUpdateOperationsInput | $Enums.CircleParticipationMode
    maxMembers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    funds?: FloatFieldUpdateOperationsInput | number
    allocatedFunds?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CircleMemberCreateInput = {
    id?: string
    role: $Enums.CircleMemberRole
    joinedAt?: Date | string
    xp?: number
    level?: number
    circle: CircleCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutCircleMemberInput
  }

  export type CircleMemberUncheckedCreateInput = {
    id?: string
    circleId: string
    userId: string
    role: $Enums.CircleMemberRole
    joinedAt?: Date | string
    xp?: number
    level?: number
  }

  export type CircleMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumCircleMemberRoleFieldUpdateOperationsInput | $Enums.CircleMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    circle?: CircleUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutCircleMemberNestedInput
  }

  export type CircleMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    circleId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumCircleMemberRoleFieldUpdateOperationsInput | $Enums.CircleMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type CircleMemberCreateManyInput = {
    id?: string
    circleId: string
    userId: string
    role: $Enums.CircleMemberRole
    joinedAt?: Date | string
    xp?: number
    level?: number
  }

  export type CircleMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumCircleMemberRoleFieldUpdateOperationsInput | $Enums.CircleMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type CircleMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    circleId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumCircleMemberRoleFieldUpdateOperationsInput | $Enums.CircleMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type CircleProjectCreateInput = {
    id?: string
    allocatedAmount?: number
    supportType: string
    votedAt?: Date | string | null
    status?: string
    circle: CircleCreateNestedOneWithoutProjectsInput
    project: ProjectCreateNestedOneWithoutCircleProjectInput
  }

  export type CircleProjectUncheckedCreateInput = {
    id?: string
    circleId: string
    projectId: string
    allocatedAmount?: number
    supportType: string
    votedAt?: Date | string | null
    status?: string
  }

  export type CircleProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: FloatFieldUpdateOperationsInput | number
    supportType?: StringFieldUpdateOperationsInput | string
    votedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    circle?: CircleUpdateOneRequiredWithoutProjectsNestedInput
    project?: ProjectUpdateOneRequiredWithoutCircleProjectNestedInput
  }

  export type CircleProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    circleId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: FloatFieldUpdateOperationsInput | number
    supportType?: StringFieldUpdateOperationsInput | string
    votedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type CircleProjectCreateManyInput = {
    id?: string
    circleId: string
    projectId: string
    allocatedAmount?: number
    supportType: string
    votedAt?: Date | string | null
    status?: string
  }

  export type CircleProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: FloatFieldUpdateOperationsInput | number
    supportType?: StringFieldUpdateOperationsInput | string
    votedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type CircleProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    circleId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: FloatFieldUpdateOperationsInput | number
    supportType?: StringFieldUpdateOperationsInput | string
    votedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionCreateInput = {
    id?: string
    type: string
    amount: number
    currency?: string
    status?: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionInput
    project?: ProjectCreateNestedOneWithoutTransactionInput
    circle?: CircleCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    amount: number
    currency?: string
    status?: string
    description?: string | null
    projectId?: string | null
    circleId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionNestedInput
    project?: ProjectUpdateOneWithoutTransactionNestedInput
    circle?: CircleUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    circleId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    userId: string
    type: string
    amount: number
    currency?: string
    status?: string
    description?: string | null
    projectId?: string | null
    circleId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    circleId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserXPCreateInput = {
    id?: string
    totalXP?: number
    level?: number
    impactRank?: string | null
    donationXP?: number
    investmentXP?: number
    contentXP?: number
    communityXP?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserXPInput
  }

  export type UserXPUncheckedCreateInput = {
    id?: string
    userId: string
    totalXP?: number
    level?: number
    impactRank?: string | null
    donationXP?: number
    investmentXP?: number
    contentXP?: number
    communityXP?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserXPUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    impactRank?: NullableStringFieldUpdateOperationsInput | string | null
    donationXP?: IntFieldUpdateOperationsInput | number
    investmentXP?: IntFieldUpdateOperationsInput | number
    contentXP?: IntFieldUpdateOperationsInput | number
    communityXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserXPNestedInput
  }

  export type UserXPUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    impactRank?: NullableStringFieldUpdateOperationsInput | string | null
    donationXP?: IntFieldUpdateOperationsInput | number
    investmentXP?: IntFieldUpdateOperationsInput | number
    contentXP?: IntFieldUpdateOperationsInput | number
    communityXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserXPCreateManyInput = {
    id?: string
    userId: string
    totalXP?: number
    level?: number
    impactRank?: string | null
    donationXP?: number
    investmentXP?: number
    contentXP?: number
    communityXP?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserXPUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    impactRank?: NullableStringFieldUpdateOperationsInput | string | null
    donationXP?: IntFieldUpdateOperationsInput | number
    investmentXP?: IntFieldUpdateOperationsInput | number
    contentXP?: IntFieldUpdateOperationsInput | number
    communityXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserXPUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    impactRank?: NullableStringFieldUpdateOperationsInput | string | null
    donationXP?: IntFieldUpdateOperationsInput | number
    investmentXP?: IntFieldUpdateOperationsInput | number
    contentXP?: IntFieldUpdateOperationsInput | number
    communityXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    criteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    users?: UserBadgeCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    criteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    users?: UserBadgeUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserBadgeUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserBadgeUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    criteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateInput = {
    id?: string
    earnedAt?: Date | string
    user: UserCreateNestedOneWithoutUserBadgeInput
    badge: BadgeCreateNestedOneWithoutUsersInput
  }

  export type UserBadgeUncheckedCreateInput = {
    id?: string
    userId: string
    badgeId: string
    earnedAt?: Date | string
  }

  export type UserBadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserBadgeNestedInput
    badge?: BadgeUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserBadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateManyInput = {
    id?: string
    userId: string
    badgeId: string
    earnedAt?: Date | string
  }

  export type UserBadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumRoleNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    has?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type ProfileListRelationFilter = {
    every?: ProfileWhereInput
    some?: ProfileWhereInput
    none?: ProfileWhereInput
  }

  export type AdressListRelationFilter = {
    every?: adressWhereInput
    some?: adressWhereInput
    none?: adressWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type CircleListRelationFilter = {
    every?: CircleWhereInput
    some?: CircleWhereInput
    none?: CircleWhereInput
  }

  export type ReactionListRelationFilter = {
    every?: ReactionWhereInput
    some?: ReactionWhereInput
    none?: ReactionWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type ProjectMemberListRelationFilter = {
    every?: ProjectMemberWhereInput
    some?: ProjectMemberWhereInput
    none?: ProjectMemberWhereInput
  }

  export type ProjectDonationListRelationFilter = {
    every?: ProjectDonationWhereInput
    some?: ProjectDonationWhereInput
    none?: ProjectDonationWhereInput
  }

  export type ProjectInvestmentListRelationFilter = {
    every?: ProjectInvestmentWhereInput
    some?: ProjectInvestmentWhereInput
    none?: ProjectInvestmentWhereInput
  }

  export type ProjectLoanListRelationFilter = {
    every?: ProjectLoanWhereInput
    some?: ProjectLoanWhereInput
    none?: ProjectLoanWhereInput
  }

  export type CircleMemberListRelationFilter = {
    every?: CircleMemberWhereInput
    some?: CircleMemberWhereInput
    none?: CircleMemberWhereInput
  }

  export type ProjectUpdateListRelationFilter = {
    every?: ProjectUpdateWhereInput
    some?: ProjectUpdateWhereInput
    none?: ProjectUpdateWhereInput
  }

  export type ProjectRewardListRelationFilter = {
    every?: ProjectRewardWhereInput
    some?: ProjectRewardWhereInput
    none?: ProjectRewardWhereInput
  }

  export type UserBadgeListRelationFilter = {
    every?: UserBadgeWhereInput
    some?: UserBadgeWhereInput
    none?: UserBadgeWhereInput
  }

  export type UserXPListRelationFilter = {
    every?: UserXPWhereInput
    some?: UserXPWhereInput
    none?: UserXPWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type adressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CircleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectDonationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectInvestmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectLoanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CircleMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectUpdateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectRewardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserXPOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roles?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountProviderIdAccountIdCompoundUniqueInput = {
    providerId: string
    accountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    age?: SortOrder
    profession?: SortOrder
    motivation?: SortOrder
    interests?: SortOrder
    experience?: SortOrder
    disponibility?: SortOrder
    bio?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    phoneVerified?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    age?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    age?: SortOrder
    profession?: SortOrder
    motivation?: SortOrder
    experience?: SortOrder
    disponibility?: SortOrder
    bio?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    phoneVerified?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    age?: SortOrder
    profession?: SortOrder
    motivation?: SortOrder
    experience?: SortOrder
    disponibility?: SortOrder
    bio?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    phoneVerified?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    age?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type adressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
  }

  export type adressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
  }

  export type adressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type EnumPostVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityFilter<$PrismaModel> | $Enums.PostVisibility
  }

  export type PostNullableScalarRelationFilter = {
    is?: PostWhereInput | null
    isNot?: PostWhereInput | null
  }

  export type MediaAssetListRelationFilter = {
    every?: MediaAssetWhereInput
    some?: MediaAssetWhereInput
    none?: MediaAssetWhereInput
  }

  export type CodeSnippetListRelationFilter = {
    every?: CodeSnippetWhereInput
    some?: CodeSnippetWhereInput
    none?: CodeSnippetWhereInput
  }

  export type PostsOnTagsListRelationFilter = {
    every?: PostsOnTagsWhereInput
    some?: PostsOnTagsWhereInput
    none?: PostsOnTagsWhereInput
  }

  export type PostsOnCategoriesListRelationFilter = {
    every?: PostsOnCategoriesWhereInput
    some?: PostsOnCategoriesWhereInput
    none?: PostsOnCategoriesWhereInput
  }

  export type ProjectNullableScalarRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type MediaAssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CodeSnippetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostsOnTagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostsOnCategoriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    content?: SortOrder
    contentText?: SortOrder
    excerpt?: SortOrder
    coverImageUrl?: SortOrder
    canonicalUrl?: SortOrder
    ogImageUrl?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    publishedAt?: SortOrder
    scheduledAt?: SortOrder
    readingTime?: SortOrder
    wordCount?: SortOrder
    language?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    readingTime?: SortOrder
    wordCount?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    contentText?: SortOrder
    excerpt?: SortOrder
    coverImageUrl?: SortOrder
    canonicalUrl?: SortOrder
    ogImageUrl?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    publishedAt?: SortOrder
    scheduledAt?: SortOrder
    readingTime?: SortOrder
    wordCount?: SortOrder
    language?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    contentText?: SortOrder
    excerpt?: SortOrder
    coverImageUrl?: SortOrder
    canonicalUrl?: SortOrder
    ogImageUrl?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    publishedAt?: SortOrder
    scheduledAt?: SortOrder
    readingTime?: SortOrder
    wordCount?: SortOrder
    language?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    readingTime?: SortOrder
    wordCount?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type EnumPostVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.PostVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostVisibilityFilter<$PrismaModel>
    _max?: NestedEnumPostVisibilityFilter<$PrismaModel>
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type PostScalarRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type MediaAssetCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    provider?: SortOrder
    title?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    position?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    width?: SortOrder
    height?: SortOrder
    durationMs?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaAssetAvgOrderByAggregateInput = {
    position?: SortOrder
    sizeBytes?: SortOrder
    width?: SortOrder
    height?: SortOrder
    durationMs?: SortOrder
  }

  export type MediaAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    provider?: SortOrder
    title?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    position?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    width?: SortOrder
    height?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaAssetMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    provider?: SortOrder
    title?: SortOrder
    alt?: SortOrder
    caption?: SortOrder
    position?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    width?: SortOrder
    height?: SortOrder
    durationMs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaAssetSumOrderByAggregateInput = {
    position?: SortOrder
    sizeBytes?: SortOrder
    width?: SortOrder
    height?: SortOrder
    durationMs?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type CodeSnippetCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    title?: SortOrder
    language?: SortOrder
    filename?: SortOrder
    code?: SortOrder
    highlightedHtml?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CodeSnippetMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    title?: SortOrder
    language?: SortOrder
    filename?: SortOrder
    code?: SortOrder
    highlightedHtml?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CodeSnippetMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    title?: SortOrder
    language?: SortOrder
    filename?: SortOrder
    code?: SortOrder
    highlightedHtml?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type PostsOnTagsPostIdTagIdCompoundUniqueInput = {
    postId: string
    tagId: string
  }

  export type PostsOnTagsCountOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type PostsOnTagsMaxOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type PostsOnTagsMinOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type PostsOnCategoriesPostIdCategoryIdCompoundUniqueInput = {
    postId: string
    categoryId: string
  }

  export type PostsOnCategoriesCountOrderByAggregateInput = {
    postId?: SortOrder
    categoryId?: SortOrder
    position?: SortOrder
    assignedAt?: SortOrder
  }

  export type PostsOnCategoriesAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type PostsOnCategoriesMaxOrderByAggregateInput = {
    postId?: SortOrder
    categoryId?: SortOrder
    position?: SortOrder
    assignedAt?: SortOrder
  }

  export type PostsOnCategoriesMinOrderByAggregateInput = {
    postId?: SortOrder
    categoryId?: SortOrder
    position?: SortOrder
    assignedAt?: SortOrder
  }

  export type PostsOnCategoriesSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type EnumCommentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentStatus | EnumCommentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommentStatusFilter<$PrismaModel> | $Enums.CommentStatus
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    contentText?: SortOrder
    status?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    contentText?: SortOrder
    status?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    contentText?: SortOrder
    status?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCommentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentStatus | EnumCommentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommentStatusWithAggregatesFilter<$PrismaModel> | $Enums.CommentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommentStatusFilter<$PrismaModel>
    _max?: NestedEnumCommentStatusFilter<$PrismaModel>
  }

  export type EnumReactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeFilter<$PrismaModel> | $Enums.ReactionType
  }

  export type ReactionPostIdUserIdTypeCompoundUniqueInput = {
    postId: string
    userId: string
    type: $Enums.ReactionType
  }

  export type ReactionCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ReactionMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumReactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeFilter<$PrismaModel>
  }

  export type EnumProjectTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectType | EnumProjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectTypeFilter<$PrismaModel> | $Enums.ProjectType
  }

  export type EnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type EnumProjectCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectCategory | EnumProjectCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectCategory[] | ListEnumProjectCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectCategory[] | ListEnumProjectCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectCategoryFilter<$PrismaModel> | $Enums.ProjectCategory
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumProjectImpactTypeNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectImpactType[] | ListEnumProjectImpactTypeFieldRefInput<$PrismaModel> | null
    has?: $Enums.ProjectImpactType | EnumProjectImpactTypeFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.ProjectImpactType[] | ListEnumProjectImpactTypeFieldRefInput<$PrismaModel>
    hasSome?: $Enums.ProjectImpactType[] | ListEnumProjectImpactTypeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CircleProjectListRelationFilter = {
    every?: CircleProjectWhereInput
    some?: CircleProjectWhereInput
    none?: CircleProjectWhereInput
  }

  export type CircleProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    type?: SortOrder
    status?: SortOrder
    category?: SortOrder
    location?: SortOrder
    fundingGoal?: SortOrder
    amountRaised?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    ownerId?: SortOrder
    organization?: SortOrder
    legalStatus?: SortOrder
    website?: SortOrder
    socialMedia?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    impactTypes?: SortOrder
    impactDescription?: SortOrder
    impactIndicators?: SortOrder
    sdgAlignment?: SortOrder
    images?: SortOrder
    videos?: SortOrder
    documents?: SortOrder
    visibility?: SortOrder
    allowComments?: SortOrder
    enableImpactSprint?: SortOrder
    valuation?: SortOrder
    minInvestment?: SortOrder
    capitalPercentage?: SortOrder
    expectedInvestors?: SortOrder
    taxAdvantages?: SortOrder
    interestRate?: SortOrder
    loanDuration?: SortOrder
    repaymentFrequency?: SortOrder
    minLoanAmount?: SortOrder
    guarantees?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    fundingGoal?: SortOrder
    amountRaised?: SortOrder
    duration?: SortOrder
    sdgAlignment?: SortOrder
    valuation?: SortOrder
    minInvestment?: SortOrder
    capitalPercentage?: SortOrder
    expectedInvestors?: SortOrder
    interestRate?: SortOrder
    loanDuration?: SortOrder
    minLoanAmount?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    type?: SortOrder
    status?: SortOrder
    category?: SortOrder
    location?: SortOrder
    fundingGoal?: SortOrder
    amountRaised?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    ownerId?: SortOrder
    organization?: SortOrder
    legalStatus?: SortOrder
    website?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    impactDescription?: SortOrder
    visibility?: SortOrder
    allowComments?: SortOrder
    enableImpactSprint?: SortOrder
    valuation?: SortOrder
    minInvestment?: SortOrder
    capitalPercentage?: SortOrder
    expectedInvestors?: SortOrder
    taxAdvantages?: SortOrder
    interestRate?: SortOrder
    loanDuration?: SortOrder
    repaymentFrequency?: SortOrder
    minLoanAmount?: SortOrder
    guarantees?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    type?: SortOrder
    status?: SortOrder
    category?: SortOrder
    location?: SortOrder
    fundingGoal?: SortOrder
    amountRaised?: SortOrder
    currency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    ownerId?: SortOrder
    organization?: SortOrder
    legalStatus?: SortOrder
    website?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    impactDescription?: SortOrder
    visibility?: SortOrder
    allowComments?: SortOrder
    enableImpactSprint?: SortOrder
    valuation?: SortOrder
    minInvestment?: SortOrder
    capitalPercentage?: SortOrder
    expectedInvestors?: SortOrder
    taxAdvantages?: SortOrder
    interestRate?: SortOrder
    loanDuration?: SortOrder
    repaymentFrequency?: SortOrder
    minLoanAmount?: SortOrder
    guarantees?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    fundingGoal?: SortOrder
    amountRaised?: SortOrder
    duration?: SortOrder
    sdgAlignment?: SortOrder
    valuation?: SortOrder
    minInvestment?: SortOrder
    capitalPercentage?: SortOrder
    expectedInvestors?: SortOrder
    interestRate?: SortOrder
    loanDuration?: SortOrder
    minLoanAmount?: SortOrder
  }

  export type EnumProjectTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectType | EnumProjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProjectType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectTypeFilter<$PrismaModel>
    _max?: NestedEnumProjectTypeFilter<$PrismaModel>
  }

  export type EnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type EnumProjectCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectCategory | EnumProjectCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectCategory[] | ListEnumProjectCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectCategory[] | ListEnumProjectCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ProjectCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectCategoryFilter<$PrismaModel>
    _max?: NestedEnumProjectCategoryFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectMemberProjectIdUserIdCompoundUniqueInput = {
    projectId: string
    userId: string
  }

  export type ProjectMemberCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type ProjectMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type ProjectMemberMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectUpdateCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    images?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectUpdateMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectUpdateMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ProjectRewardCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    amount?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    deliveryDate?: SortOrder
    quantity?: SortOrder
    claimed?: SortOrder
  }

  export type ProjectRewardAvgOrderByAggregateInput = {
    amount?: SortOrder
    quantity?: SortOrder
    claimed?: SortOrder
  }

  export type ProjectRewardMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    amount?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    deliveryDate?: SortOrder
    quantity?: SortOrder
    claimed?: SortOrder
  }

  export type ProjectRewardMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    amount?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    deliveryDate?: SortOrder
    quantity?: SortOrder
    claimed?: SortOrder
  }

  export type ProjectRewardSumOrderByAggregateInput = {
    amount?: SortOrder
    quantity?: SortOrder
    claimed?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ProjectRewardNullableScalarRelationFilter = {
    is?: ProjectRewardWhereInput | null
    isNot?: ProjectRewardWhereInput | null
  }

  export type ProjectDonationCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    isAnonymous?: SortOrder
    message?: SortOrder
    rewardId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectDonationAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ProjectDonationMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    isAnonymous?: SortOrder
    message?: SortOrder
    rewardId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectDonationMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    isAnonymous?: SortOrder
    message?: SortOrder
    rewardId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectDonationSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ProjectInvestmentCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    shares?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectInvestmentAvgOrderByAggregateInput = {
    amount?: SortOrder
    shares?: SortOrder
  }

  export type ProjectInvestmentMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    shares?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectInvestmentMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    shares?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectInvestmentSumOrderByAggregateInput = {
    amount?: SortOrder
    shares?: SortOrder
  }

  export type ProjectLoanCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectLoanAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ProjectLoanMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectLoanMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectLoanSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumCircleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CircleType | EnumCircleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CircleType[] | ListEnumCircleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CircleType[] | ListEnumCircleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCircleTypeFilter<$PrismaModel> | $Enums.CircleType
  }

  export type EnumCircleParticipationModeFilter<$PrismaModel = never> = {
    equals?: $Enums.CircleParticipationMode | EnumCircleParticipationModeFieldRefInput<$PrismaModel>
    in?: $Enums.CircleParticipationMode[] | ListEnumCircleParticipationModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CircleParticipationMode[] | ListEnumCircleParticipationModeFieldRefInput<$PrismaModel>
    not?: NestedEnumCircleParticipationModeFilter<$PrismaModel> | $Enums.CircleParticipationMode
  }

  export type CircleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    type?: SortOrder
    theme?: SortOrder
    participationMode?: SortOrder
    maxMembers?: SortOrder
    isPublic?: SortOrder
    isActive?: SortOrder
    monthlyFee?: SortOrder
    funds?: SortOrder
    allocatedFunds?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CircleAvgOrderByAggregateInput = {
    maxMembers?: SortOrder
    monthlyFee?: SortOrder
    funds?: SortOrder
    allocatedFunds?: SortOrder
  }

  export type CircleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    type?: SortOrder
    theme?: SortOrder
    participationMode?: SortOrder
    maxMembers?: SortOrder
    isPublic?: SortOrder
    isActive?: SortOrder
    monthlyFee?: SortOrder
    funds?: SortOrder
    allocatedFunds?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CircleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    type?: SortOrder
    theme?: SortOrder
    participationMode?: SortOrder
    maxMembers?: SortOrder
    isPublic?: SortOrder
    isActive?: SortOrder
    monthlyFee?: SortOrder
    funds?: SortOrder
    allocatedFunds?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CircleSumOrderByAggregateInput = {
    maxMembers?: SortOrder
    monthlyFee?: SortOrder
    funds?: SortOrder
    allocatedFunds?: SortOrder
  }

  export type EnumCircleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CircleType | EnumCircleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CircleType[] | ListEnumCircleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CircleType[] | ListEnumCircleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCircleTypeWithAggregatesFilter<$PrismaModel> | $Enums.CircleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCircleTypeFilter<$PrismaModel>
    _max?: NestedEnumCircleTypeFilter<$PrismaModel>
  }

  export type EnumCircleParticipationModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CircleParticipationMode | EnumCircleParticipationModeFieldRefInput<$PrismaModel>
    in?: $Enums.CircleParticipationMode[] | ListEnumCircleParticipationModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CircleParticipationMode[] | ListEnumCircleParticipationModeFieldRefInput<$PrismaModel>
    not?: NestedEnumCircleParticipationModeWithAggregatesFilter<$PrismaModel> | $Enums.CircleParticipationMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCircleParticipationModeFilter<$PrismaModel>
    _max?: NestedEnumCircleParticipationModeFilter<$PrismaModel>
  }

  export type EnumCircleMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.CircleMemberRole | EnumCircleMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CircleMemberRole[] | ListEnumCircleMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CircleMemberRole[] | ListEnumCircleMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCircleMemberRoleFilter<$PrismaModel> | $Enums.CircleMemberRole
  }

  export type CircleScalarRelationFilter = {
    is?: CircleWhereInput
    isNot?: CircleWhereInput
  }

  export type CircleMemberCircleIdUserIdCompoundUniqueInput = {
    circleId: string
    userId: string
  }

  export type CircleMemberCountOrderByAggregateInput = {
    id?: SortOrder
    circleId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    xp?: SortOrder
    level?: SortOrder
  }

  export type CircleMemberAvgOrderByAggregateInput = {
    xp?: SortOrder
    level?: SortOrder
  }

  export type CircleMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    circleId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    xp?: SortOrder
    level?: SortOrder
  }

  export type CircleMemberMinOrderByAggregateInput = {
    id?: SortOrder
    circleId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    xp?: SortOrder
    level?: SortOrder
  }

  export type CircleMemberSumOrderByAggregateInput = {
    xp?: SortOrder
    level?: SortOrder
  }

  export type EnumCircleMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CircleMemberRole | EnumCircleMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CircleMemberRole[] | ListEnumCircleMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CircleMemberRole[] | ListEnumCircleMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCircleMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.CircleMemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCircleMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumCircleMemberRoleFilter<$PrismaModel>
  }

  export type CircleProjectCircleIdProjectIdCompoundUniqueInput = {
    circleId: string
    projectId: string
  }

  export type CircleProjectCountOrderByAggregateInput = {
    id?: SortOrder
    circleId?: SortOrder
    projectId?: SortOrder
    allocatedAmount?: SortOrder
    supportType?: SortOrder
    votedAt?: SortOrder
    status?: SortOrder
  }

  export type CircleProjectAvgOrderByAggregateInput = {
    allocatedAmount?: SortOrder
  }

  export type CircleProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    circleId?: SortOrder
    projectId?: SortOrder
    allocatedAmount?: SortOrder
    supportType?: SortOrder
    votedAt?: SortOrder
    status?: SortOrder
  }

  export type CircleProjectMinOrderByAggregateInput = {
    id?: SortOrder
    circleId?: SortOrder
    projectId?: SortOrder
    allocatedAmount?: SortOrder
    supportType?: SortOrder
    votedAt?: SortOrder
    status?: SortOrder
  }

  export type CircleProjectSumOrderByAggregateInput = {
    allocatedAmount?: SortOrder
  }

  export type CircleNullableScalarRelationFilter = {
    is?: CircleWhereInput | null
    isNot?: CircleWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrder
    projectId?: SortOrder
    circleId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrder
    projectId?: SortOrder
    circleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    description?: SortOrder
    projectId?: SortOrder
    circleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type UserXPCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalXP?: SortOrder
    level?: SortOrder
    impactRank?: SortOrder
    donationXP?: SortOrder
    investmentXP?: SortOrder
    contentXP?: SortOrder
    communityXP?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserXPAvgOrderByAggregateInput = {
    totalXP?: SortOrder
    level?: SortOrder
    donationXP?: SortOrder
    investmentXP?: SortOrder
    contentXP?: SortOrder
    communityXP?: SortOrder
  }

  export type UserXPMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalXP?: SortOrder
    level?: SortOrder
    impactRank?: SortOrder
    donationXP?: SortOrder
    investmentXP?: SortOrder
    contentXP?: SortOrder
    communityXP?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserXPMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalXP?: SortOrder
    level?: SortOrder
    impactRank?: SortOrder
    donationXP?: SortOrder
    investmentXP?: SortOrder
    contentXP?: SortOrder
    communityXP?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserXPSumOrderByAggregateInput = {
    totalXP?: SortOrder
    level?: SortOrder
    donationXP?: SortOrder
    investmentXP?: SortOrder
    contentXP?: SortOrder
    communityXP?: SortOrder
  }

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    criteria?: SortOrder
    createdAt?: SortOrder
  }

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
  }

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
  }

  export type BadgeScalarRelationFilter = {
    is?: BadgeWhereInput
    isNot?: BadgeWhereInput
  }

  export type UserBadgeUserIdBadgeIdCompoundUniqueInput = {
    userId: string
    badgeId: string
  }

  export type UserBadgeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
  }

  export type UserBadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
  }

  export type UserBadgeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    earnedAt?: SortOrder
  }

  export type UserCreaterolesInput = {
    set: $Enums.Role[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ProfileCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput> | ProfileCreateWithoutUserInput[] | ProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput | ProfileCreateOrConnectWithoutUserInput[]
    createMany?: ProfileCreateManyUserInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type adressCreateNestedManyWithoutUserInput = {
    create?: XOR<adressCreateWithoutUserInput, adressUncheckedCreateWithoutUserInput> | adressCreateWithoutUserInput[] | adressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: adressCreateOrConnectWithoutUserInput | adressCreateOrConnectWithoutUserInput[]
    createMany?: adressCreateManyUserInputEnvelope
    connect?: adressWhereUniqueInput | adressWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type CircleCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CircleCreateWithoutCreatorInput, CircleUncheckedCreateWithoutCreatorInput> | CircleCreateWithoutCreatorInput[] | CircleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CircleCreateOrConnectWithoutCreatorInput | CircleCreateOrConnectWithoutCreatorInput[]
    createMany?: CircleCreateManyCreatorInputEnvelope
    connect?: CircleWhereUniqueInput | CircleWhereUniqueInput[]
  }

  export type ReactionCreateNestedManyWithoutUserInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ProjectMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type ProjectDonationCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectDonationCreateWithoutUserInput, ProjectDonationUncheckedCreateWithoutUserInput> | ProjectDonationCreateWithoutUserInput[] | ProjectDonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectDonationCreateOrConnectWithoutUserInput | ProjectDonationCreateOrConnectWithoutUserInput[]
    createMany?: ProjectDonationCreateManyUserInputEnvelope
    connect?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
  }

  export type ProjectInvestmentCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectInvestmentCreateWithoutUserInput, ProjectInvestmentUncheckedCreateWithoutUserInput> | ProjectInvestmentCreateWithoutUserInput[] | ProjectInvestmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectInvestmentCreateOrConnectWithoutUserInput | ProjectInvestmentCreateOrConnectWithoutUserInput[]
    createMany?: ProjectInvestmentCreateManyUserInputEnvelope
    connect?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
  }

  export type ProjectLoanCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectLoanCreateWithoutUserInput, ProjectLoanUncheckedCreateWithoutUserInput> | ProjectLoanCreateWithoutUserInput[] | ProjectLoanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectLoanCreateOrConnectWithoutUserInput | ProjectLoanCreateOrConnectWithoutUserInput[]
    createMany?: ProjectLoanCreateManyUserInputEnvelope
    connect?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
  }

  export type CircleMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<CircleMemberCreateWithoutUserInput, CircleMemberUncheckedCreateWithoutUserInput> | CircleMemberCreateWithoutUserInput[] | CircleMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CircleMemberCreateOrConnectWithoutUserInput | CircleMemberCreateOrConnectWithoutUserInput[]
    createMany?: CircleMemberCreateManyUserInputEnvelope
    connect?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
  }

  export type ProjectUpdateCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectUpdateCreateWithoutUserInput, ProjectUpdateUncheckedCreateWithoutUserInput> | ProjectUpdateCreateWithoutUserInput[] | ProjectUpdateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutUserInput | ProjectUpdateCreateOrConnectWithoutUserInput[]
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
  }

  export type ProjectRewardCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectRewardCreateWithoutUserInput, ProjectRewardUncheckedCreateWithoutUserInput> | ProjectRewardCreateWithoutUserInput[] | ProjectRewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectRewardCreateOrConnectWithoutUserInput | ProjectRewardCreateOrConnectWithoutUserInput[]
    connect?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
  }

  export type UserBadgeCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserXPCreateNestedManyWithoutUserInput = {
    create?: XOR<UserXPCreateWithoutUserInput, UserXPUncheckedCreateWithoutUserInput> | UserXPCreateWithoutUserInput[] | UserXPUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserXPCreateOrConnectWithoutUserInput | UserXPCreateOrConnectWithoutUserInput[]
    createMany?: UserXPCreateManyUserInputEnvelope
    connect?: UserXPWhereUniqueInput | UserXPWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput> | ProfileCreateWithoutUserInput[] | ProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput | ProfileCreateOrConnectWithoutUserInput[]
    createMany?: ProfileCreateManyUserInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type adressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<adressCreateWithoutUserInput, adressUncheckedCreateWithoutUserInput> | adressCreateWithoutUserInput[] | adressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: adressCreateOrConnectWithoutUserInput | adressCreateOrConnectWithoutUserInput[]
    createMany?: adressCreateManyUserInputEnvelope
    connect?: adressWhereUniqueInput | adressWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type CircleUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CircleCreateWithoutCreatorInput, CircleUncheckedCreateWithoutCreatorInput> | CircleCreateWithoutCreatorInput[] | CircleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CircleCreateOrConnectWithoutCreatorInput | CircleCreateOrConnectWithoutCreatorInput[]
    createMany?: CircleCreateManyCreatorInputEnvelope
    connect?: CircleWhereUniqueInput | CircleWhereUniqueInput[]
  }

  export type ReactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type ProjectDonationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectDonationCreateWithoutUserInput, ProjectDonationUncheckedCreateWithoutUserInput> | ProjectDonationCreateWithoutUserInput[] | ProjectDonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectDonationCreateOrConnectWithoutUserInput | ProjectDonationCreateOrConnectWithoutUserInput[]
    createMany?: ProjectDonationCreateManyUserInputEnvelope
    connect?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
  }

  export type ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectInvestmentCreateWithoutUserInput, ProjectInvestmentUncheckedCreateWithoutUserInput> | ProjectInvestmentCreateWithoutUserInput[] | ProjectInvestmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectInvestmentCreateOrConnectWithoutUserInput | ProjectInvestmentCreateOrConnectWithoutUserInput[]
    createMany?: ProjectInvestmentCreateManyUserInputEnvelope
    connect?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
  }

  export type ProjectLoanUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectLoanCreateWithoutUserInput, ProjectLoanUncheckedCreateWithoutUserInput> | ProjectLoanCreateWithoutUserInput[] | ProjectLoanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectLoanCreateOrConnectWithoutUserInput | ProjectLoanCreateOrConnectWithoutUserInput[]
    createMany?: ProjectLoanCreateManyUserInputEnvelope
    connect?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
  }

  export type CircleMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CircleMemberCreateWithoutUserInput, CircleMemberUncheckedCreateWithoutUserInput> | CircleMemberCreateWithoutUserInput[] | CircleMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CircleMemberCreateOrConnectWithoutUserInput | CircleMemberCreateOrConnectWithoutUserInput[]
    createMany?: CircleMemberCreateManyUserInputEnvelope
    connect?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
  }

  export type ProjectUpdateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectUpdateCreateWithoutUserInput, ProjectUpdateUncheckedCreateWithoutUserInput> | ProjectUpdateCreateWithoutUserInput[] | ProjectUpdateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutUserInput | ProjectUpdateCreateOrConnectWithoutUserInput[]
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
  }

  export type ProjectRewardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectRewardCreateWithoutUserInput, ProjectRewardUncheckedCreateWithoutUserInput> | ProjectRewardCreateWithoutUserInput[] | ProjectRewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectRewardCreateOrConnectWithoutUserInput | ProjectRewardCreateOrConnectWithoutUserInput[]
    connect?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
  }

  export type UserBadgeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserXPUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserXPCreateWithoutUserInput, UserXPUncheckedCreateWithoutUserInput> | UserXPCreateWithoutUserInput[] | UserXPUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserXPCreateOrConnectWithoutUserInput | UserXPCreateOrConnectWithoutUserInput[]
    createMany?: UserXPCreateManyUserInputEnvelope
    connect?: UserXPWhereUniqueInput | UserXPWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdaterolesInput = {
    set?: $Enums.Role[]
    push?: $Enums.Role | $Enums.Role[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ProfileUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput> | ProfileCreateWithoutUserInput[] | ProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput | ProfileCreateOrConnectWithoutUserInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutUserInput | ProfileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfileCreateManyUserInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutUserInput | ProfileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutUserInput | ProfileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type adressUpdateManyWithoutUserNestedInput = {
    create?: XOR<adressCreateWithoutUserInput, adressUncheckedCreateWithoutUserInput> | adressCreateWithoutUserInput[] | adressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: adressCreateOrConnectWithoutUserInput | adressCreateOrConnectWithoutUserInput[]
    upsert?: adressUpsertWithWhereUniqueWithoutUserInput | adressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: adressCreateManyUserInputEnvelope
    set?: adressWhereUniqueInput | adressWhereUniqueInput[]
    disconnect?: adressWhereUniqueInput | adressWhereUniqueInput[]
    delete?: adressWhereUniqueInput | adressWhereUniqueInput[]
    connect?: adressWhereUniqueInput | adressWhereUniqueInput[]
    update?: adressUpdateWithWhereUniqueWithoutUserInput | adressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: adressUpdateManyWithWhereWithoutUserInput | adressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: adressScalarWhereInput | adressScalarWhereInput[]
  }

  export type PostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOwnerInput | ProjectUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOwnerInput | ProjectUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOwnerInput | ProjectUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type CircleUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CircleCreateWithoutCreatorInput, CircleUncheckedCreateWithoutCreatorInput> | CircleCreateWithoutCreatorInput[] | CircleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CircleCreateOrConnectWithoutCreatorInput | CircleCreateOrConnectWithoutCreatorInput[]
    upsert?: CircleUpsertWithWhereUniqueWithoutCreatorInput | CircleUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CircleCreateManyCreatorInputEnvelope
    set?: CircleWhereUniqueInput | CircleWhereUniqueInput[]
    disconnect?: CircleWhereUniqueInput | CircleWhereUniqueInput[]
    delete?: CircleWhereUniqueInput | CircleWhereUniqueInput[]
    connect?: CircleWhereUniqueInput | CircleWhereUniqueInput[]
    update?: CircleUpdateWithWhereUniqueWithoutCreatorInput | CircleUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CircleUpdateManyWithWhereWithoutCreatorInput | CircleUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CircleScalarWhereInput | CircleScalarWhereInput[]
  }

  export type ReactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutUserInput | ReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutUserInput | ReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutUserInput | ReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ProjectMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type ProjectDonationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectDonationCreateWithoutUserInput, ProjectDonationUncheckedCreateWithoutUserInput> | ProjectDonationCreateWithoutUserInput[] | ProjectDonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectDonationCreateOrConnectWithoutUserInput | ProjectDonationCreateOrConnectWithoutUserInput[]
    upsert?: ProjectDonationUpsertWithWhereUniqueWithoutUserInput | ProjectDonationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectDonationCreateManyUserInputEnvelope
    set?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    disconnect?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    delete?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    connect?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    update?: ProjectDonationUpdateWithWhereUniqueWithoutUserInput | ProjectDonationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectDonationUpdateManyWithWhereWithoutUserInput | ProjectDonationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectDonationScalarWhereInput | ProjectDonationScalarWhereInput[]
  }

  export type ProjectInvestmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectInvestmentCreateWithoutUserInput, ProjectInvestmentUncheckedCreateWithoutUserInput> | ProjectInvestmentCreateWithoutUserInput[] | ProjectInvestmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectInvestmentCreateOrConnectWithoutUserInput | ProjectInvestmentCreateOrConnectWithoutUserInput[]
    upsert?: ProjectInvestmentUpsertWithWhereUniqueWithoutUserInput | ProjectInvestmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectInvestmentCreateManyUserInputEnvelope
    set?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
    disconnect?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
    delete?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
    connect?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
    update?: ProjectInvestmentUpdateWithWhereUniqueWithoutUserInput | ProjectInvestmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectInvestmentUpdateManyWithWhereWithoutUserInput | ProjectInvestmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectInvestmentScalarWhereInput | ProjectInvestmentScalarWhereInput[]
  }

  export type ProjectLoanUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectLoanCreateWithoutUserInput, ProjectLoanUncheckedCreateWithoutUserInput> | ProjectLoanCreateWithoutUserInput[] | ProjectLoanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectLoanCreateOrConnectWithoutUserInput | ProjectLoanCreateOrConnectWithoutUserInput[]
    upsert?: ProjectLoanUpsertWithWhereUniqueWithoutUserInput | ProjectLoanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectLoanCreateManyUserInputEnvelope
    set?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
    disconnect?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
    delete?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
    connect?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
    update?: ProjectLoanUpdateWithWhereUniqueWithoutUserInput | ProjectLoanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectLoanUpdateManyWithWhereWithoutUserInput | ProjectLoanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectLoanScalarWhereInput | ProjectLoanScalarWhereInput[]
  }

  export type CircleMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<CircleMemberCreateWithoutUserInput, CircleMemberUncheckedCreateWithoutUserInput> | CircleMemberCreateWithoutUserInput[] | CircleMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CircleMemberCreateOrConnectWithoutUserInput | CircleMemberCreateOrConnectWithoutUserInput[]
    upsert?: CircleMemberUpsertWithWhereUniqueWithoutUserInput | CircleMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CircleMemberCreateManyUserInputEnvelope
    set?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
    disconnect?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
    delete?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
    connect?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
    update?: CircleMemberUpdateWithWhereUniqueWithoutUserInput | CircleMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CircleMemberUpdateManyWithWhereWithoutUserInput | CircleMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CircleMemberScalarWhereInput | CircleMemberScalarWhereInput[]
  }

  export type ProjectUpdateUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectUpdateCreateWithoutUserInput, ProjectUpdateUncheckedCreateWithoutUserInput> | ProjectUpdateCreateWithoutUserInput[] | ProjectUpdateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutUserInput | ProjectUpdateCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpdateUpsertWithWhereUniqueWithoutUserInput | ProjectUpdateUpsertWithWhereUniqueWithoutUserInput[]
    set?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    disconnect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    delete?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    update?: ProjectUpdateUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateUpdateManyWithWhereWithoutUserInput | ProjectUpdateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectUpdateScalarWhereInput | ProjectUpdateScalarWhereInput[]
  }

  export type ProjectRewardUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectRewardCreateWithoutUserInput, ProjectRewardUncheckedCreateWithoutUserInput> | ProjectRewardCreateWithoutUserInput[] | ProjectRewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectRewardCreateOrConnectWithoutUserInput | ProjectRewardCreateOrConnectWithoutUserInput[]
    upsert?: ProjectRewardUpsertWithWhereUniqueWithoutUserInput | ProjectRewardUpsertWithWhereUniqueWithoutUserInput[]
    set?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
    disconnect?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
    delete?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
    connect?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
    update?: ProjectRewardUpdateWithWhereUniqueWithoutUserInput | ProjectRewardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectRewardUpdateManyWithWhereWithoutUserInput | ProjectRewardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectRewardScalarWhereInput | ProjectRewardScalarWhereInput[]
  }

  export type UserBadgeUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutUserInput | UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutUserInput | UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutUserInput | UserBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserXPUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserXPCreateWithoutUserInput, UserXPUncheckedCreateWithoutUserInput> | UserXPCreateWithoutUserInput[] | UserXPUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserXPCreateOrConnectWithoutUserInput | UserXPCreateOrConnectWithoutUserInput[]
    upsert?: UserXPUpsertWithWhereUniqueWithoutUserInput | UserXPUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserXPCreateManyUserInputEnvelope
    set?: UserXPWhereUniqueInput | UserXPWhereUniqueInput[]
    disconnect?: UserXPWhereUniqueInput | UserXPWhereUniqueInput[]
    delete?: UserXPWhereUniqueInput | UserXPWhereUniqueInput[]
    connect?: UserXPWhereUniqueInput | UserXPWhereUniqueInput[]
    update?: UserXPUpdateWithWhereUniqueWithoutUserInput | UserXPUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserXPUpdateManyWithWhereWithoutUserInput | UserXPUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserXPScalarWhereInput | UserXPScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput> | ProfileCreateWithoutUserInput[] | ProfileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput | ProfileCreateOrConnectWithoutUserInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutUserInput | ProfileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfileCreateManyUserInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutUserInput | ProfileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutUserInput | ProfileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type adressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<adressCreateWithoutUserInput, adressUncheckedCreateWithoutUserInput> | adressCreateWithoutUserInput[] | adressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: adressCreateOrConnectWithoutUserInput | adressCreateOrConnectWithoutUserInput[]
    upsert?: adressUpsertWithWhereUniqueWithoutUserInput | adressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: adressCreateManyUserInputEnvelope
    set?: adressWhereUniqueInput | adressWhereUniqueInput[]
    disconnect?: adressWhereUniqueInput | adressWhereUniqueInput[]
    delete?: adressWhereUniqueInput | adressWhereUniqueInput[]
    connect?: adressWhereUniqueInput | adressWhereUniqueInput[]
    update?: adressUpdateWithWhereUniqueWithoutUserInput | adressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: adressUpdateManyWithWhereWithoutUserInput | adressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: adressScalarWhereInput | adressScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOwnerInput | ProjectUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOwnerInput | ProjectUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOwnerInput | ProjectUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type CircleUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CircleCreateWithoutCreatorInput, CircleUncheckedCreateWithoutCreatorInput> | CircleCreateWithoutCreatorInput[] | CircleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CircleCreateOrConnectWithoutCreatorInput | CircleCreateOrConnectWithoutCreatorInput[]
    upsert?: CircleUpsertWithWhereUniqueWithoutCreatorInput | CircleUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CircleCreateManyCreatorInputEnvelope
    set?: CircleWhereUniqueInput | CircleWhereUniqueInput[]
    disconnect?: CircleWhereUniqueInput | CircleWhereUniqueInput[]
    delete?: CircleWhereUniqueInput | CircleWhereUniqueInput[]
    connect?: CircleWhereUniqueInput | CircleWhereUniqueInput[]
    update?: CircleUpdateWithWhereUniqueWithoutCreatorInput | CircleUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CircleUpdateManyWithWhereWithoutCreatorInput | CircleUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CircleScalarWhereInput | CircleScalarWhereInput[]
  }

  export type ReactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutUserInput | ReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutUserInput | ReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutUserInput | ReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type ProjectDonationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectDonationCreateWithoutUserInput, ProjectDonationUncheckedCreateWithoutUserInput> | ProjectDonationCreateWithoutUserInput[] | ProjectDonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectDonationCreateOrConnectWithoutUserInput | ProjectDonationCreateOrConnectWithoutUserInput[]
    upsert?: ProjectDonationUpsertWithWhereUniqueWithoutUserInput | ProjectDonationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectDonationCreateManyUserInputEnvelope
    set?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    disconnect?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    delete?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    connect?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    update?: ProjectDonationUpdateWithWhereUniqueWithoutUserInput | ProjectDonationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectDonationUpdateManyWithWhereWithoutUserInput | ProjectDonationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectDonationScalarWhereInput | ProjectDonationScalarWhereInput[]
  }

  export type ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectInvestmentCreateWithoutUserInput, ProjectInvestmentUncheckedCreateWithoutUserInput> | ProjectInvestmentCreateWithoutUserInput[] | ProjectInvestmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectInvestmentCreateOrConnectWithoutUserInput | ProjectInvestmentCreateOrConnectWithoutUserInput[]
    upsert?: ProjectInvestmentUpsertWithWhereUniqueWithoutUserInput | ProjectInvestmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectInvestmentCreateManyUserInputEnvelope
    set?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
    disconnect?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
    delete?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
    connect?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
    update?: ProjectInvestmentUpdateWithWhereUniqueWithoutUserInput | ProjectInvestmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectInvestmentUpdateManyWithWhereWithoutUserInput | ProjectInvestmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectInvestmentScalarWhereInput | ProjectInvestmentScalarWhereInput[]
  }

  export type ProjectLoanUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectLoanCreateWithoutUserInput, ProjectLoanUncheckedCreateWithoutUserInput> | ProjectLoanCreateWithoutUserInput[] | ProjectLoanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectLoanCreateOrConnectWithoutUserInput | ProjectLoanCreateOrConnectWithoutUserInput[]
    upsert?: ProjectLoanUpsertWithWhereUniqueWithoutUserInput | ProjectLoanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectLoanCreateManyUserInputEnvelope
    set?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
    disconnect?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
    delete?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
    connect?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
    update?: ProjectLoanUpdateWithWhereUniqueWithoutUserInput | ProjectLoanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectLoanUpdateManyWithWhereWithoutUserInput | ProjectLoanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectLoanScalarWhereInput | ProjectLoanScalarWhereInput[]
  }

  export type CircleMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CircleMemberCreateWithoutUserInput, CircleMemberUncheckedCreateWithoutUserInput> | CircleMemberCreateWithoutUserInput[] | CircleMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CircleMemberCreateOrConnectWithoutUserInput | CircleMemberCreateOrConnectWithoutUserInput[]
    upsert?: CircleMemberUpsertWithWhereUniqueWithoutUserInput | CircleMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CircleMemberCreateManyUserInputEnvelope
    set?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
    disconnect?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
    delete?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
    connect?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
    update?: CircleMemberUpdateWithWhereUniqueWithoutUserInput | CircleMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CircleMemberUpdateManyWithWhereWithoutUserInput | CircleMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CircleMemberScalarWhereInput | CircleMemberScalarWhereInput[]
  }

  export type ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectUpdateCreateWithoutUserInput, ProjectUpdateUncheckedCreateWithoutUserInput> | ProjectUpdateCreateWithoutUserInput[] | ProjectUpdateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutUserInput | ProjectUpdateCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpdateUpsertWithWhereUniqueWithoutUserInput | ProjectUpdateUpsertWithWhereUniqueWithoutUserInput[]
    set?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    disconnect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    delete?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    update?: ProjectUpdateUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateUpdateManyWithWhereWithoutUserInput | ProjectUpdateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectUpdateScalarWhereInput | ProjectUpdateScalarWhereInput[]
  }

  export type ProjectRewardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectRewardCreateWithoutUserInput, ProjectRewardUncheckedCreateWithoutUserInput> | ProjectRewardCreateWithoutUserInput[] | ProjectRewardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectRewardCreateOrConnectWithoutUserInput | ProjectRewardCreateOrConnectWithoutUserInput[]
    upsert?: ProjectRewardUpsertWithWhereUniqueWithoutUserInput | ProjectRewardUpsertWithWhereUniqueWithoutUserInput[]
    set?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
    disconnect?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
    delete?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
    connect?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
    update?: ProjectRewardUpdateWithWhereUniqueWithoutUserInput | ProjectRewardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectRewardUpdateManyWithWhereWithoutUserInput | ProjectRewardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectRewardScalarWhereInput | ProjectRewardScalarWhereInput[]
  }

  export type UserBadgeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutUserInput | UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutUserInput | UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutUserInput | UserBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserXPUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserXPCreateWithoutUserInput, UserXPUncheckedCreateWithoutUserInput> | UserXPCreateWithoutUserInput[] | UserXPUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserXPCreateOrConnectWithoutUserInput | UserXPCreateOrConnectWithoutUserInput[]
    upsert?: UserXPUpsertWithWhereUniqueWithoutUserInput | UserXPUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserXPCreateManyUserInputEnvelope
    set?: UserXPWhereUniqueInput | UserXPWhereUniqueInput[]
    disconnect?: UserXPWhereUniqueInput | UserXPWhereUniqueInput[]
    delete?: UserXPWhereUniqueInput | UserXPWhereUniqueInput[]
    connect?: UserXPWhereUniqueInput | UserXPWhereUniqueInput[]
    update?: UserXPUpdateWithWhereUniqueWithoutUserInput | UserXPUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserXPUpdateManyWithWhereWithoutUserInput | UserXPUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserXPScalarWhereInput | UserXPScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type ProfileCreateinterestsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProfileUpdateinterestsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutAdressInput = {
    create?: XOR<UserCreateWithoutAdressInput, UserUncheckedCreateWithoutAdressInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdressInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdressNestedInput = {
    create?: XOR<UserCreateWithoutAdressInput, UserUncheckedCreateWithoutAdressInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdressInput
    upsert?: UserUpsertWithoutAdressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdressInput, UserUpdateWithoutAdressInput>, UserUncheckedUpdateWithoutAdressInput>
  }

  export type UserCreateNestedOneWithoutPostInput = {
    create?: XOR<UserCreateWithoutPostInput, UserUncheckedCreateWithoutPostInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostInput
    connect?: UserWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutChildrenInput = {
    create?: XOR<PostCreateWithoutChildrenInput, PostUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: PostCreateOrConnectWithoutChildrenInput
    connect?: PostWhereUniqueInput
  }

  export type PostCreateNestedManyWithoutParentInput = {
    create?: XOR<PostCreateWithoutParentInput, PostUncheckedCreateWithoutParentInput> | PostCreateWithoutParentInput[] | PostUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PostCreateOrConnectWithoutParentInput | PostCreateOrConnectWithoutParentInput[]
    createMany?: PostCreateManyParentInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type MediaAssetCreateNestedManyWithoutPostInput = {
    create?: XOR<MediaAssetCreateWithoutPostInput, MediaAssetUncheckedCreateWithoutPostInput> | MediaAssetCreateWithoutPostInput[] | MediaAssetUncheckedCreateWithoutPostInput[]
    connectOrCreate?: MediaAssetCreateOrConnectWithoutPostInput | MediaAssetCreateOrConnectWithoutPostInput[]
    createMany?: MediaAssetCreateManyPostInputEnvelope
    connect?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
  }

  export type CodeSnippetCreateNestedManyWithoutPostInput = {
    create?: XOR<CodeSnippetCreateWithoutPostInput, CodeSnippetUncheckedCreateWithoutPostInput> | CodeSnippetCreateWithoutPostInput[] | CodeSnippetUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CodeSnippetCreateOrConnectWithoutPostInput | CodeSnippetCreateOrConnectWithoutPostInput[]
    createMany?: CodeSnippetCreateManyPostInputEnvelope
    connect?: CodeSnippetWhereUniqueInput | CodeSnippetWhereUniqueInput[]
  }

  export type PostsOnTagsCreateNestedManyWithoutPostInput = {
    create?: XOR<PostsOnTagsCreateWithoutPostInput, PostsOnTagsUncheckedCreateWithoutPostInput> | PostsOnTagsCreateWithoutPostInput[] | PostsOnTagsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostsOnTagsCreateOrConnectWithoutPostInput | PostsOnTagsCreateOrConnectWithoutPostInput[]
    createMany?: PostsOnTagsCreateManyPostInputEnvelope
    connect?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
  }

  export type PostsOnCategoriesCreateNestedManyWithoutPostInput = {
    create?: XOR<PostsOnCategoriesCreateWithoutPostInput, PostsOnCategoriesUncheckedCreateWithoutPostInput> | PostsOnCategoriesCreateWithoutPostInput[] | PostsOnCategoriesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostsOnCategoriesCreateOrConnectWithoutPostInput | PostsOnCategoriesCreateOrConnectWithoutPostInput[]
    createMany?: PostsOnCategoriesCreateManyPostInputEnvelope
    connect?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReactionCreateNestedManyWithoutPostInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput> | ReactionCreateWithoutPostInput[] | ReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput | ReactionCreateOrConnectWithoutPostInput[]
    createMany?: ReactionCreateManyPostInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type ProjectCreateNestedOneWithoutPostsInput = {
    create?: XOR<ProjectCreateWithoutPostsInput, ProjectUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPostsInput
    connect?: ProjectWhereUniqueInput
  }

  export type PostUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<PostCreateWithoutParentInput, PostUncheckedCreateWithoutParentInput> | PostCreateWithoutParentInput[] | PostUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PostCreateOrConnectWithoutParentInput | PostCreateOrConnectWithoutParentInput[]
    createMany?: PostCreateManyParentInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type MediaAssetUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<MediaAssetCreateWithoutPostInput, MediaAssetUncheckedCreateWithoutPostInput> | MediaAssetCreateWithoutPostInput[] | MediaAssetUncheckedCreateWithoutPostInput[]
    connectOrCreate?: MediaAssetCreateOrConnectWithoutPostInput | MediaAssetCreateOrConnectWithoutPostInput[]
    createMany?: MediaAssetCreateManyPostInputEnvelope
    connect?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
  }

  export type CodeSnippetUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CodeSnippetCreateWithoutPostInput, CodeSnippetUncheckedCreateWithoutPostInput> | CodeSnippetCreateWithoutPostInput[] | CodeSnippetUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CodeSnippetCreateOrConnectWithoutPostInput | CodeSnippetCreateOrConnectWithoutPostInput[]
    createMany?: CodeSnippetCreateManyPostInputEnvelope
    connect?: CodeSnippetWhereUniqueInput | CodeSnippetWhereUniqueInput[]
  }

  export type PostsOnTagsUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostsOnTagsCreateWithoutPostInput, PostsOnTagsUncheckedCreateWithoutPostInput> | PostsOnTagsCreateWithoutPostInput[] | PostsOnTagsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostsOnTagsCreateOrConnectWithoutPostInput | PostsOnTagsCreateOrConnectWithoutPostInput[]
    createMany?: PostsOnTagsCreateManyPostInputEnvelope
    connect?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
  }

  export type PostsOnCategoriesUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostsOnCategoriesCreateWithoutPostInput, PostsOnCategoriesUncheckedCreateWithoutPostInput> | PostsOnCategoriesCreateWithoutPostInput[] | PostsOnCategoriesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostsOnCategoriesCreateOrConnectWithoutPostInput | PostsOnCategoriesCreateOrConnectWithoutPostInput[]
    createMany?: PostsOnCategoriesCreateManyPostInputEnvelope
    connect?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReactionUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput> | ReactionCreateWithoutPostInput[] | ReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput | ReactionCreateOrConnectWithoutPostInput[]
    createMany?: ReactionCreateManyPostInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type EnumPostStatusFieldUpdateOperationsInput = {
    set?: $Enums.PostStatus
  }

  export type EnumPostVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.PostVisibility
  }

  export type UserUpdateOneRequiredWithoutPostNestedInput = {
    create?: XOR<UserCreateWithoutPostInput, UserUncheckedCreateWithoutPostInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostInput
    upsert?: UserUpsertWithoutPostInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostInput, UserUpdateWithoutPostInput>, UserUncheckedUpdateWithoutPostInput>
  }

  export type PostUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<PostCreateWithoutChildrenInput, PostUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: PostCreateOrConnectWithoutChildrenInput
    upsert?: PostUpsertWithoutChildrenInput
    disconnect?: PostWhereInput | boolean
    delete?: PostWhereInput | boolean
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutChildrenInput, PostUpdateWithoutChildrenInput>, PostUncheckedUpdateWithoutChildrenInput>
  }

  export type PostUpdateManyWithoutParentNestedInput = {
    create?: XOR<PostCreateWithoutParentInput, PostUncheckedCreateWithoutParentInput> | PostCreateWithoutParentInput[] | PostUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PostCreateOrConnectWithoutParentInput | PostCreateOrConnectWithoutParentInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutParentInput | PostUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PostCreateManyParentInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutParentInput | PostUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: PostUpdateManyWithWhereWithoutParentInput | PostUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type MediaAssetUpdateManyWithoutPostNestedInput = {
    create?: XOR<MediaAssetCreateWithoutPostInput, MediaAssetUncheckedCreateWithoutPostInput> | MediaAssetCreateWithoutPostInput[] | MediaAssetUncheckedCreateWithoutPostInput[]
    connectOrCreate?: MediaAssetCreateOrConnectWithoutPostInput | MediaAssetCreateOrConnectWithoutPostInput[]
    upsert?: MediaAssetUpsertWithWhereUniqueWithoutPostInput | MediaAssetUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: MediaAssetCreateManyPostInputEnvelope
    set?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
    disconnect?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
    delete?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
    connect?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
    update?: MediaAssetUpdateWithWhereUniqueWithoutPostInput | MediaAssetUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: MediaAssetUpdateManyWithWhereWithoutPostInput | MediaAssetUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: MediaAssetScalarWhereInput | MediaAssetScalarWhereInput[]
  }

  export type CodeSnippetUpdateManyWithoutPostNestedInput = {
    create?: XOR<CodeSnippetCreateWithoutPostInput, CodeSnippetUncheckedCreateWithoutPostInput> | CodeSnippetCreateWithoutPostInput[] | CodeSnippetUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CodeSnippetCreateOrConnectWithoutPostInput | CodeSnippetCreateOrConnectWithoutPostInput[]
    upsert?: CodeSnippetUpsertWithWhereUniqueWithoutPostInput | CodeSnippetUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CodeSnippetCreateManyPostInputEnvelope
    set?: CodeSnippetWhereUniqueInput | CodeSnippetWhereUniqueInput[]
    disconnect?: CodeSnippetWhereUniqueInput | CodeSnippetWhereUniqueInput[]
    delete?: CodeSnippetWhereUniqueInput | CodeSnippetWhereUniqueInput[]
    connect?: CodeSnippetWhereUniqueInput | CodeSnippetWhereUniqueInput[]
    update?: CodeSnippetUpdateWithWhereUniqueWithoutPostInput | CodeSnippetUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CodeSnippetUpdateManyWithWhereWithoutPostInput | CodeSnippetUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CodeSnippetScalarWhereInput | CodeSnippetScalarWhereInput[]
  }

  export type PostsOnTagsUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostsOnTagsCreateWithoutPostInput, PostsOnTagsUncheckedCreateWithoutPostInput> | PostsOnTagsCreateWithoutPostInput[] | PostsOnTagsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostsOnTagsCreateOrConnectWithoutPostInput | PostsOnTagsCreateOrConnectWithoutPostInput[]
    upsert?: PostsOnTagsUpsertWithWhereUniqueWithoutPostInput | PostsOnTagsUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostsOnTagsCreateManyPostInputEnvelope
    set?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
    disconnect?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
    delete?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
    connect?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
    update?: PostsOnTagsUpdateWithWhereUniqueWithoutPostInput | PostsOnTagsUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostsOnTagsUpdateManyWithWhereWithoutPostInput | PostsOnTagsUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostsOnTagsScalarWhereInput | PostsOnTagsScalarWhereInput[]
  }

  export type PostsOnCategoriesUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostsOnCategoriesCreateWithoutPostInput, PostsOnCategoriesUncheckedCreateWithoutPostInput> | PostsOnCategoriesCreateWithoutPostInput[] | PostsOnCategoriesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostsOnCategoriesCreateOrConnectWithoutPostInput | PostsOnCategoriesCreateOrConnectWithoutPostInput[]
    upsert?: PostsOnCategoriesUpsertWithWhereUniqueWithoutPostInput | PostsOnCategoriesUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostsOnCategoriesCreateManyPostInputEnvelope
    set?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
    disconnect?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
    delete?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
    connect?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
    update?: PostsOnCategoriesUpdateWithWhereUniqueWithoutPostInput | PostsOnCategoriesUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostsOnCategoriesUpdateManyWithWhereWithoutPostInput | PostsOnCategoriesUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostsOnCategoriesScalarWhereInput | PostsOnCategoriesScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReactionUpdateManyWithoutPostNestedInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput> | ReactionCreateWithoutPostInput[] | ReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput | ReactionCreateOrConnectWithoutPostInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutPostInput | ReactionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ReactionCreateManyPostInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutPostInput | ReactionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutPostInput | ReactionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type ProjectUpdateOneWithoutPostsNestedInput = {
    create?: XOR<ProjectCreateWithoutPostsInput, ProjectUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPostsInput
    upsert?: ProjectUpsertWithoutPostsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPostsInput, ProjectUpdateWithoutPostsInput>, ProjectUncheckedUpdateWithoutPostsInput>
  }

  export type PostUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<PostCreateWithoutParentInput, PostUncheckedCreateWithoutParentInput> | PostCreateWithoutParentInput[] | PostUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PostCreateOrConnectWithoutParentInput | PostCreateOrConnectWithoutParentInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutParentInput | PostUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PostCreateManyParentInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutParentInput | PostUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: PostUpdateManyWithWhereWithoutParentInput | PostUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type MediaAssetUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<MediaAssetCreateWithoutPostInput, MediaAssetUncheckedCreateWithoutPostInput> | MediaAssetCreateWithoutPostInput[] | MediaAssetUncheckedCreateWithoutPostInput[]
    connectOrCreate?: MediaAssetCreateOrConnectWithoutPostInput | MediaAssetCreateOrConnectWithoutPostInput[]
    upsert?: MediaAssetUpsertWithWhereUniqueWithoutPostInput | MediaAssetUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: MediaAssetCreateManyPostInputEnvelope
    set?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
    disconnect?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
    delete?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
    connect?: MediaAssetWhereUniqueInput | MediaAssetWhereUniqueInput[]
    update?: MediaAssetUpdateWithWhereUniqueWithoutPostInput | MediaAssetUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: MediaAssetUpdateManyWithWhereWithoutPostInput | MediaAssetUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: MediaAssetScalarWhereInput | MediaAssetScalarWhereInput[]
  }

  export type CodeSnippetUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CodeSnippetCreateWithoutPostInput, CodeSnippetUncheckedCreateWithoutPostInput> | CodeSnippetCreateWithoutPostInput[] | CodeSnippetUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CodeSnippetCreateOrConnectWithoutPostInput | CodeSnippetCreateOrConnectWithoutPostInput[]
    upsert?: CodeSnippetUpsertWithWhereUniqueWithoutPostInput | CodeSnippetUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CodeSnippetCreateManyPostInputEnvelope
    set?: CodeSnippetWhereUniqueInput | CodeSnippetWhereUniqueInput[]
    disconnect?: CodeSnippetWhereUniqueInput | CodeSnippetWhereUniqueInput[]
    delete?: CodeSnippetWhereUniqueInput | CodeSnippetWhereUniqueInput[]
    connect?: CodeSnippetWhereUniqueInput | CodeSnippetWhereUniqueInput[]
    update?: CodeSnippetUpdateWithWhereUniqueWithoutPostInput | CodeSnippetUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CodeSnippetUpdateManyWithWhereWithoutPostInput | CodeSnippetUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CodeSnippetScalarWhereInput | CodeSnippetScalarWhereInput[]
  }

  export type PostsOnTagsUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostsOnTagsCreateWithoutPostInput, PostsOnTagsUncheckedCreateWithoutPostInput> | PostsOnTagsCreateWithoutPostInput[] | PostsOnTagsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostsOnTagsCreateOrConnectWithoutPostInput | PostsOnTagsCreateOrConnectWithoutPostInput[]
    upsert?: PostsOnTagsUpsertWithWhereUniqueWithoutPostInput | PostsOnTagsUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostsOnTagsCreateManyPostInputEnvelope
    set?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
    disconnect?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
    delete?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
    connect?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
    update?: PostsOnTagsUpdateWithWhereUniqueWithoutPostInput | PostsOnTagsUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostsOnTagsUpdateManyWithWhereWithoutPostInput | PostsOnTagsUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostsOnTagsScalarWhereInput | PostsOnTagsScalarWhereInput[]
  }

  export type PostsOnCategoriesUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostsOnCategoriesCreateWithoutPostInput, PostsOnCategoriesUncheckedCreateWithoutPostInput> | PostsOnCategoriesCreateWithoutPostInput[] | PostsOnCategoriesUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostsOnCategoriesCreateOrConnectWithoutPostInput | PostsOnCategoriesCreateOrConnectWithoutPostInput[]
    upsert?: PostsOnCategoriesUpsertWithWhereUniqueWithoutPostInput | PostsOnCategoriesUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostsOnCategoriesCreateManyPostInputEnvelope
    set?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
    disconnect?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
    delete?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
    connect?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
    update?: PostsOnCategoriesUpdateWithWhereUniqueWithoutPostInput | PostsOnCategoriesUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostsOnCategoriesUpdateManyWithWhereWithoutPostInput | PostsOnCategoriesUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostsOnCategoriesScalarWhereInput | PostsOnCategoriesScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReactionUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput> | ReactionCreateWithoutPostInput[] | ReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput | ReactionCreateOrConnectWithoutPostInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutPostInput | ReactionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ReactionCreateManyPostInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutPostInput | ReactionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutPostInput | ReactionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<PostCreateWithoutAttachmentsInput, PostUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutAttachmentsInput
    connect?: PostWhereUniqueInput
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type PostUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<PostCreateWithoutAttachmentsInput, PostUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutAttachmentsInput
    upsert?: PostUpsertWithoutAttachmentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutAttachmentsInput, PostUpdateWithoutAttachmentsInput>, PostUncheckedUpdateWithoutAttachmentsInput>
  }

  export type PostCreateNestedOneWithoutCodeSnippetsInput = {
    create?: XOR<PostCreateWithoutCodeSnippetsInput, PostUncheckedCreateWithoutCodeSnippetsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCodeSnippetsInput
    connect?: PostWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutCodeSnippetsNestedInput = {
    create?: XOR<PostCreateWithoutCodeSnippetsInput, PostUncheckedCreateWithoutCodeSnippetsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCodeSnippetsInput
    upsert?: PostUpsertWithoutCodeSnippetsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCodeSnippetsInput, PostUpdateWithoutCodeSnippetsInput>, PostUncheckedUpdateWithoutCodeSnippetsInput>
  }

  export type PostsOnTagsCreateNestedManyWithoutTagInput = {
    create?: XOR<PostsOnTagsCreateWithoutTagInput, PostsOnTagsUncheckedCreateWithoutTagInput> | PostsOnTagsCreateWithoutTagInput[] | PostsOnTagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostsOnTagsCreateOrConnectWithoutTagInput | PostsOnTagsCreateOrConnectWithoutTagInput[]
    createMany?: PostsOnTagsCreateManyTagInputEnvelope
    connect?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
  }

  export type PostsOnTagsUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<PostsOnTagsCreateWithoutTagInput, PostsOnTagsUncheckedCreateWithoutTagInput> | PostsOnTagsCreateWithoutTagInput[] | PostsOnTagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostsOnTagsCreateOrConnectWithoutTagInput | PostsOnTagsCreateOrConnectWithoutTagInput[]
    createMany?: PostsOnTagsCreateManyTagInputEnvelope
    connect?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
  }

  export type PostsOnTagsUpdateManyWithoutTagNestedInput = {
    create?: XOR<PostsOnTagsCreateWithoutTagInput, PostsOnTagsUncheckedCreateWithoutTagInput> | PostsOnTagsCreateWithoutTagInput[] | PostsOnTagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostsOnTagsCreateOrConnectWithoutTagInput | PostsOnTagsCreateOrConnectWithoutTagInput[]
    upsert?: PostsOnTagsUpsertWithWhereUniqueWithoutTagInput | PostsOnTagsUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PostsOnTagsCreateManyTagInputEnvelope
    set?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
    disconnect?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
    delete?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
    connect?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
    update?: PostsOnTagsUpdateWithWhereUniqueWithoutTagInput | PostsOnTagsUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PostsOnTagsUpdateManyWithWhereWithoutTagInput | PostsOnTagsUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PostsOnTagsScalarWhereInput | PostsOnTagsScalarWhereInput[]
  }

  export type PostsOnTagsUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<PostsOnTagsCreateWithoutTagInput, PostsOnTagsUncheckedCreateWithoutTagInput> | PostsOnTagsCreateWithoutTagInput[] | PostsOnTagsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostsOnTagsCreateOrConnectWithoutTagInput | PostsOnTagsCreateOrConnectWithoutTagInput[]
    upsert?: PostsOnTagsUpsertWithWhereUniqueWithoutTagInput | PostsOnTagsUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PostsOnTagsCreateManyTagInputEnvelope
    set?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
    disconnect?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
    delete?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
    connect?: PostsOnTagsWhereUniqueInput | PostsOnTagsWhereUniqueInput[]
    update?: PostsOnTagsUpdateWithWhereUniqueWithoutTagInput | PostsOnTagsUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PostsOnTagsUpdateManyWithWhereWithoutTagInput | PostsOnTagsUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PostsOnTagsScalarWhereInput | PostsOnTagsScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutTagsInput = {
    create?: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput>
    connectOrCreate?: PostCreateOrConnectWithoutTagsInput
    connect?: PostWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutPostsInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput
    connect?: TagWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput>
    connectOrCreate?: PostCreateOrConnectWithoutTagsInput
    upsert?: PostUpsertWithoutTagsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutTagsInput, PostUpdateWithoutTagsInput>, PostUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput
    upsert?: TagUpsertWithoutPostsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutPostsInput, TagUpdateWithoutPostsInput>, TagUncheckedUpdateWithoutPostsInput>
  }

  export type CategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type PostsOnCategoriesCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PostsOnCategoriesCreateWithoutCategoryInput, PostsOnCategoriesUncheckedCreateWithoutCategoryInput> | PostsOnCategoriesCreateWithoutCategoryInput[] | PostsOnCategoriesUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PostsOnCategoriesCreateOrConnectWithoutCategoryInput | PostsOnCategoriesCreateOrConnectWithoutCategoryInput[]
    createMany?: PostsOnCategoriesCreateManyCategoryInputEnvelope
    connect?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type PostsOnCategoriesUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PostsOnCategoriesCreateWithoutCategoryInput, PostsOnCategoriesUncheckedCreateWithoutCategoryInput> | PostsOnCategoriesCreateWithoutCategoryInput[] | PostsOnCategoriesUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PostsOnCategoriesCreateOrConnectWithoutCategoryInput | PostsOnCategoriesCreateOrConnectWithoutCategoryInput[]
    createMany?: PostsOnCategoriesCreateManyCategoryInputEnvelope
    connect?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
  }

  export type CategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    upsert?: CategoryUpsertWithoutChildrenInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutChildrenInput, CategoryUpdateWithoutChildrenInput>, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type PostsOnCategoriesUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PostsOnCategoriesCreateWithoutCategoryInput, PostsOnCategoriesUncheckedCreateWithoutCategoryInput> | PostsOnCategoriesCreateWithoutCategoryInput[] | PostsOnCategoriesUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PostsOnCategoriesCreateOrConnectWithoutCategoryInput | PostsOnCategoriesCreateOrConnectWithoutCategoryInput[]
    upsert?: PostsOnCategoriesUpsertWithWhereUniqueWithoutCategoryInput | PostsOnCategoriesUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PostsOnCategoriesCreateManyCategoryInputEnvelope
    set?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
    disconnect?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
    delete?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
    connect?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
    update?: PostsOnCategoriesUpdateWithWhereUniqueWithoutCategoryInput | PostsOnCategoriesUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PostsOnCategoriesUpdateManyWithWhereWithoutCategoryInput | PostsOnCategoriesUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PostsOnCategoriesScalarWhereInput | PostsOnCategoriesScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type PostsOnCategoriesUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PostsOnCategoriesCreateWithoutCategoryInput, PostsOnCategoriesUncheckedCreateWithoutCategoryInput> | PostsOnCategoriesCreateWithoutCategoryInput[] | PostsOnCategoriesUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PostsOnCategoriesCreateOrConnectWithoutCategoryInput | PostsOnCategoriesCreateOrConnectWithoutCategoryInput[]
    upsert?: PostsOnCategoriesUpsertWithWhereUniqueWithoutCategoryInput | PostsOnCategoriesUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PostsOnCategoriesCreateManyCategoryInputEnvelope
    set?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
    disconnect?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
    delete?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
    connect?: PostsOnCategoriesWhereUniqueInput | PostsOnCategoriesWhereUniqueInput[]
    update?: PostsOnCategoriesUpdateWithWhereUniqueWithoutCategoryInput | PostsOnCategoriesUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PostsOnCategoriesUpdateManyWithWhereWithoutCategoryInput | PostsOnCategoriesUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PostsOnCategoriesScalarWhereInput | PostsOnCategoriesScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<PostCreateWithoutCategoriesInput, PostUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: PostCreateOrConnectWithoutCategoriesInput
    connect?: PostWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutPostsInput = {
    create?: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPostsInput
    connect?: CategoryWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<PostCreateWithoutCategoriesInput, PostUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: PostCreateOrConnectWithoutCategoriesInput
    upsert?: PostUpsertWithoutCategoriesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCategoriesInput, PostUpdateWithoutCategoriesInput>, PostUncheckedUpdateWithoutCategoriesInput>
  }

  export type CategoryUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPostsInput
    upsert?: CategoryUpsertWithoutPostsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutPostsInput, CategoryUpdateWithoutPostsInput>, CategoryUncheckedUpdateWithoutPostsInput>
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CommentCreateOrConnectWithoutChildrenInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EnumCommentStatusFieldUpdateOperationsInput = {
    set?: $Enums.CommentStatus
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentNestedInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    upsert?: UserUpsertWithoutCommentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentInput, UserUpdateWithoutCommentInput>, UserUncheckedUpdateWithoutCommentInput>
  }

  export type CommentUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CommentCreateOrConnectWithoutChildrenInput
    upsert?: CommentUpsertWithoutChildrenInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutChildrenInput, CommentUpdateWithoutChildrenInput>, CommentUncheckedUpdateWithoutChildrenInput>
  }

  export type CommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutReactionsInput = {
    create?: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: PostCreateOrConnectWithoutReactionsInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReactionInput = {
    create?: XOR<UserCreateWithoutReactionInput, UserUncheckedCreateWithoutReactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutReactionInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReactionType
  }

  export type PostUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: PostCreateOrConnectWithoutReactionsInput
    upsert?: PostUpsertWithoutReactionsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutReactionsInput, PostUpdateWithoutReactionsInput>, PostUncheckedUpdateWithoutReactionsInput>
  }

  export type UserUpdateOneRequiredWithoutReactionNestedInput = {
    create?: XOR<UserCreateWithoutReactionInput, UserUncheckedCreateWithoutReactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutReactionInput
    upsert?: UserUpsertWithoutReactionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReactionInput, UserUpdateWithoutReactionInput>, UserUncheckedUpdateWithoutReactionInput>
  }

  export type ProjectCreateimpactTypesInput = {
    set: $Enums.ProjectImpactType[]
  }

  export type ProjectCreateimpactIndicatorsInput = {
    set: string[]
  }

  export type ProjectCreatesdgAlignmentInput = {
    set: number[]
  }

  export type ProjectCreateimagesInput = {
    set: string[]
  }

  export type ProjectCreatevideosInput = {
    set: string[]
  }

  export type ProjectCreatedocumentsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutProjectInput = {
    create?: XOR<UserCreateWithoutProjectInput, UserUncheckedCreateWithoutProjectInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectMemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutProjectInput = {
    create?: XOR<PostCreateWithoutProjectInput, PostUncheckedCreateWithoutProjectInput> | PostCreateWithoutProjectInput[] | PostUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PostCreateOrConnectWithoutProjectInput | PostCreateOrConnectWithoutProjectInput[]
    createMany?: PostCreateManyProjectInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ProjectUpdateCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectUpdateCreateWithoutProjectInput, ProjectUpdateUncheckedCreateWithoutProjectInput> | ProjectUpdateCreateWithoutProjectInput[] | ProjectUpdateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutProjectInput | ProjectUpdateCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectUpdateCreateManyProjectInputEnvelope
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
  }

  export type ProjectRewardCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectRewardCreateWithoutProjectInput, ProjectRewardUncheckedCreateWithoutProjectInput> | ProjectRewardCreateWithoutProjectInput[] | ProjectRewardUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectRewardCreateOrConnectWithoutProjectInput | ProjectRewardCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectRewardCreateManyProjectInputEnvelope
    connect?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
  }

  export type ProjectDonationCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectDonationCreateWithoutProjectInput, ProjectDonationUncheckedCreateWithoutProjectInput> | ProjectDonationCreateWithoutProjectInput[] | ProjectDonationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDonationCreateOrConnectWithoutProjectInput | ProjectDonationCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectDonationCreateManyProjectInputEnvelope
    connect?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
  }

  export type ProjectInvestmentCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectInvestmentCreateWithoutProjectInput, ProjectInvestmentUncheckedCreateWithoutProjectInput> | ProjectInvestmentCreateWithoutProjectInput[] | ProjectInvestmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectInvestmentCreateOrConnectWithoutProjectInput | ProjectInvestmentCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectInvestmentCreateManyProjectInputEnvelope
    connect?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
  }

  export type ProjectLoanCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectLoanCreateWithoutProjectInput, ProjectLoanUncheckedCreateWithoutProjectInput> | ProjectLoanCreateWithoutProjectInput[] | ProjectLoanUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectLoanCreateOrConnectWithoutProjectInput | ProjectLoanCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectLoanCreateManyProjectInputEnvelope
    connect?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutProjectInput = {
    create?: XOR<TransactionCreateWithoutProjectInput, TransactionUncheckedCreateWithoutProjectInput> | TransactionCreateWithoutProjectInput[] | TransactionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProjectInput | TransactionCreateOrConnectWithoutProjectInput[]
    createMany?: TransactionCreateManyProjectInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type CircleProjectCreateNestedManyWithoutProjectInput = {
    create?: XOR<CircleProjectCreateWithoutProjectInput, CircleProjectUncheckedCreateWithoutProjectInput> | CircleProjectCreateWithoutProjectInput[] | CircleProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CircleProjectCreateOrConnectWithoutProjectInput | CircleProjectCreateOrConnectWithoutProjectInput[]
    createMany?: CircleProjectCreateManyProjectInputEnvelope
    connect?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<PostCreateWithoutProjectInput, PostUncheckedCreateWithoutProjectInput> | PostCreateWithoutProjectInput[] | PostUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PostCreateOrConnectWithoutProjectInput | PostCreateOrConnectWithoutProjectInput[]
    createMany?: PostCreateManyProjectInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectUpdateCreateWithoutProjectInput, ProjectUpdateUncheckedCreateWithoutProjectInput> | ProjectUpdateCreateWithoutProjectInput[] | ProjectUpdateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutProjectInput | ProjectUpdateCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectUpdateCreateManyProjectInputEnvelope
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
  }

  export type ProjectRewardUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectRewardCreateWithoutProjectInput, ProjectRewardUncheckedCreateWithoutProjectInput> | ProjectRewardCreateWithoutProjectInput[] | ProjectRewardUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectRewardCreateOrConnectWithoutProjectInput | ProjectRewardCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectRewardCreateManyProjectInputEnvelope
    connect?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
  }

  export type ProjectDonationUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectDonationCreateWithoutProjectInput, ProjectDonationUncheckedCreateWithoutProjectInput> | ProjectDonationCreateWithoutProjectInput[] | ProjectDonationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDonationCreateOrConnectWithoutProjectInput | ProjectDonationCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectDonationCreateManyProjectInputEnvelope
    connect?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
  }

  export type ProjectInvestmentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectInvestmentCreateWithoutProjectInput, ProjectInvestmentUncheckedCreateWithoutProjectInput> | ProjectInvestmentCreateWithoutProjectInput[] | ProjectInvestmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectInvestmentCreateOrConnectWithoutProjectInput | ProjectInvestmentCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectInvestmentCreateManyProjectInputEnvelope
    connect?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
  }

  export type ProjectLoanUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectLoanCreateWithoutProjectInput, ProjectLoanUncheckedCreateWithoutProjectInput> | ProjectLoanCreateWithoutProjectInput[] | ProjectLoanUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectLoanCreateOrConnectWithoutProjectInput | ProjectLoanCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectLoanCreateManyProjectInputEnvelope
    connect?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TransactionCreateWithoutProjectInput, TransactionUncheckedCreateWithoutProjectInput> | TransactionCreateWithoutProjectInput[] | TransactionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProjectInput | TransactionCreateOrConnectWithoutProjectInput[]
    createMany?: TransactionCreateManyProjectInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type CircleProjectUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CircleProjectCreateWithoutProjectInput, CircleProjectUncheckedCreateWithoutProjectInput> | CircleProjectCreateWithoutProjectInput[] | CircleProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CircleProjectCreateOrConnectWithoutProjectInput | CircleProjectCreateOrConnectWithoutProjectInput[]
    createMany?: CircleProjectCreateManyProjectInputEnvelope
    connect?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
  }

  export type EnumProjectTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProjectType
  }

  export type EnumProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectStatus
  }

  export type EnumProjectCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ProjectCategory
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateimpactTypesInput = {
    set?: $Enums.ProjectImpactType[]
    push?: $Enums.ProjectImpactType | $Enums.ProjectImpactType[]
  }

  export type ProjectUpdateimpactIndicatorsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdatesdgAlignmentInput = {
    set?: number[]
    push?: number | number[]
  }

  export type ProjectUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdatevideosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdatedocumentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutProjectNestedInput = {
    create?: XOR<UserCreateWithoutProjectInput, UserUncheckedCreateWithoutProjectInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectInput
    upsert?: UserUpsertWithoutProjectInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectInput, UserUpdateWithoutProjectInput>, UserUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type PostUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PostCreateWithoutProjectInput, PostUncheckedCreateWithoutProjectInput> | PostCreateWithoutProjectInput[] | PostUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PostCreateOrConnectWithoutProjectInput | PostCreateOrConnectWithoutProjectInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutProjectInput | PostUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PostCreateManyProjectInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutProjectInput | PostUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PostUpdateManyWithWhereWithoutProjectInput | PostUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ProjectUpdateUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectUpdateCreateWithoutProjectInput, ProjectUpdateUncheckedCreateWithoutProjectInput> | ProjectUpdateCreateWithoutProjectInput[] | ProjectUpdateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutProjectInput | ProjectUpdateCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectUpdateUpsertWithWhereUniqueWithoutProjectInput | ProjectUpdateUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectUpdateCreateManyProjectInputEnvelope
    set?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    disconnect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    delete?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    update?: ProjectUpdateUpdateWithWhereUniqueWithoutProjectInput | ProjectUpdateUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectUpdateUpdateManyWithWhereWithoutProjectInput | ProjectUpdateUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectUpdateScalarWhereInput | ProjectUpdateScalarWhereInput[]
  }

  export type ProjectRewardUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectRewardCreateWithoutProjectInput, ProjectRewardUncheckedCreateWithoutProjectInput> | ProjectRewardCreateWithoutProjectInput[] | ProjectRewardUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectRewardCreateOrConnectWithoutProjectInput | ProjectRewardCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectRewardUpsertWithWhereUniqueWithoutProjectInput | ProjectRewardUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectRewardCreateManyProjectInputEnvelope
    set?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
    disconnect?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
    delete?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
    connect?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
    update?: ProjectRewardUpdateWithWhereUniqueWithoutProjectInput | ProjectRewardUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectRewardUpdateManyWithWhereWithoutProjectInput | ProjectRewardUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectRewardScalarWhereInput | ProjectRewardScalarWhereInput[]
  }

  export type ProjectDonationUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectDonationCreateWithoutProjectInput, ProjectDonationUncheckedCreateWithoutProjectInput> | ProjectDonationCreateWithoutProjectInput[] | ProjectDonationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDonationCreateOrConnectWithoutProjectInput | ProjectDonationCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectDonationUpsertWithWhereUniqueWithoutProjectInput | ProjectDonationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectDonationCreateManyProjectInputEnvelope
    set?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    disconnect?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    delete?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    connect?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    update?: ProjectDonationUpdateWithWhereUniqueWithoutProjectInput | ProjectDonationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectDonationUpdateManyWithWhereWithoutProjectInput | ProjectDonationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectDonationScalarWhereInput | ProjectDonationScalarWhereInput[]
  }

  export type ProjectInvestmentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectInvestmentCreateWithoutProjectInput, ProjectInvestmentUncheckedCreateWithoutProjectInput> | ProjectInvestmentCreateWithoutProjectInput[] | ProjectInvestmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectInvestmentCreateOrConnectWithoutProjectInput | ProjectInvestmentCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectInvestmentUpsertWithWhereUniqueWithoutProjectInput | ProjectInvestmentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectInvestmentCreateManyProjectInputEnvelope
    set?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
    disconnect?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
    delete?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
    connect?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
    update?: ProjectInvestmentUpdateWithWhereUniqueWithoutProjectInput | ProjectInvestmentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectInvestmentUpdateManyWithWhereWithoutProjectInput | ProjectInvestmentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectInvestmentScalarWhereInput | ProjectInvestmentScalarWhereInput[]
  }

  export type ProjectLoanUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectLoanCreateWithoutProjectInput, ProjectLoanUncheckedCreateWithoutProjectInput> | ProjectLoanCreateWithoutProjectInput[] | ProjectLoanUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectLoanCreateOrConnectWithoutProjectInput | ProjectLoanCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectLoanUpsertWithWhereUniqueWithoutProjectInput | ProjectLoanUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectLoanCreateManyProjectInputEnvelope
    set?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
    disconnect?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
    delete?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
    connect?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
    update?: ProjectLoanUpdateWithWhereUniqueWithoutProjectInput | ProjectLoanUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectLoanUpdateManyWithWhereWithoutProjectInput | ProjectLoanUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectLoanScalarWhereInput | ProjectLoanScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TransactionCreateWithoutProjectInput, TransactionUncheckedCreateWithoutProjectInput> | TransactionCreateWithoutProjectInput[] | TransactionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProjectInput | TransactionCreateOrConnectWithoutProjectInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutProjectInput | TransactionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TransactionCreateManyProjectInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutProjectInput | TransactionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutProjectInput | TransactionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CircleProjectUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CircleProjectCreateWithoutProjectInput, CircleProjectUncheckedCreateWithoutProjectInput> | CircleProjectCreateWithoutProjectInput[] | CircleProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CircleProjectCreateOrConnectWithoutProjectInput | CircleProjectCreateOrConnectWithoutProjectInput[]
    upsert?: CircleProjectUpsertWithWhereUniqueWithoutProjectInput | CircleProjectUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CircleProjectCreateManyProjectInputEnvelope
    set?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
    disconnect?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
    delete?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
    connect?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
    update?: CircleProjectUpdateWithWhereUniqueWithoutProjectInput | CircleProjectUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CircleProjectUpdateManyWithWhereWithoutProjectInput | CircleProjectUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CircleProjectScalarWhereInput | CircleProjectScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PostCreateWithoutProjectInput, PostUncheckedCreateWithoutProjectInput> | PostCreateWithoutProjectInput[] | PostUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PostCreateOrConnectWithoutProjectInput | PostCreateOrConnectWithoutProjectInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutProjectInput | PostUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PostCreateManyProjectInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutProjectInput | PostUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PostUpdateManyWithWhereWithoutProjectInput | PostUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectUpdateCreateWithoutProjectInput, ProjectUpdateUncheckedCreateWithoutProjectInput> | ProjectUpdateCreateWithoutProjectInput[] | ProjectUpdateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutProjectInput | ProjectUpdateCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectUpdateUpsertWithWhereUniqueWithoutProjectInput | ProjectUpdateUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectUpdateCreateManyProjectInputEnvelope
    set?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    disconnect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    delete?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    update?: ProjectUpdateUpdateWithWhereUniqueWithoutProjectInput | ProjectUpdateUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectUpdateUpdateManyWithWhereWithoutProjectInput | ProjectUpdateUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectUpdateScalarWhereInput | ProjectUpdateScalarWhereInput[]
  }

  export type ProjectRewardUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectRewardCreateWithoutProjectInput, ProjectRewardUncheckedCreateWithoutProjectInput> | ProjectRewardCreateWithoutProjectInput[] | ProjectRewardUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectRewardCreateOrConnectWithoutProjectInput | ProjectRewardCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectRewardUpsertWithWhereUniqueWithoutProjectInput | ProjectRewardUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectRewardCreateManyProjectInputEnvelope
    set?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
    disconnect?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
    delete?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
    connect?: ProjectRewardWhereUniqueInput | ProjectRewardWhereUniqueInput[]
    update?: ProjectRewardUpdateWithWhereUniqueWithoutProjectInput | ProjectRewardUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectRewardUpdateManyWithWhereWithoutProjectInput | ProjectRewardUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectRewardScalarWhereInput | ProjectRewardScalarWhereInput[]
  }

  export type ProjectDonationUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectDonationCreateWithoutProjectInput, ProjectDonationUncheckedCreateWithoutProjectInput> | ProjectDonationCreateWithoutProjectInput[] | ProjectDonationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDonationCreateOrConnectWithoutProjectInput | ProjectDonationCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectDonationUpsertWithWhereUniqueWithoutProjectInput | ProjectDonationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectDonationCreateManyProjectInputEnvelope
    set?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    disconnect?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    delete?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    connect?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    update?: ProjectDonationUpdateWithWhereUniqueWithoutProjectInput | ProjectDonationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectDonationUpdateManyWithWhereWithoutProjectInput | ProjectDonationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectDonationScalarWhereInput | ProjectDonationScalarWhereInput[]
  }

  export type ProjectInvestmentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectInvestmentCreateWithoutProjectInput, ProjectInvestmentUncheckedCreateWithoutProjectInput> | ProjectInvestmentCreateWithoutProjectInput[] | ProjectInvestmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectInvestmentCreateOrConnectWithoutProjectInput | ProjectInvestmentCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectInvestmentUpsertWithWhereUniqueWithoutProjectInput | ProjectInvestmentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectInvestmentCreateManyProjectInputEnvelope
    set?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
    disconnect?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
    delete?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
    connect?: ProjectInvestmentWhereUniqueInput | ProjectInvestmentWhereUniqueInput[]
    update?: ProjectInvestmentUpdateWithWhereUniqueWithoutProjectInput | ProjectInvestmentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectInvestmentUpdateManyWithWhereWithoutProjectInput | ProjectInvestmentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectInvestmentScalarWhereInput | ProjectInvestmentScalarWhereInput[]
  }

  export type ProjectLoanUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectLoanCreateWithoutProjectInput, ProjectLoanUncheckedCreateWithoutProjectInput> | ProjectLoanCreateWithoutProjectInput[] | ProjectLoanUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectLoanCreateOrConnectWithoutProjectInput | ProjectLoanCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectLoanUpsertWithWhereUniqueWithoutProjectInput | ProjectLoanUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectLoanCreateManyProjectInputEnvelope
    set?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
    disconnect?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
    delete?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
    connect?: ProjectLoanWhereUniqueInput | ProjectLoanWhereUniqueInput[]
    update?: ProjectLoanUpdateWithWhereUniqueWithoutProjectInput | ProjectLoanUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectLoanUpdateManyWithWhereWithoutProjectInput | ProjectLoanUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectLoanScalarWhereInput | ProjectLoanScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TransactionCreateWithoutProjectInput, TransactionUncheckedCreateWithoutProjectInput> | TransactionCreateWithoutProjectInput[] | TransactionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProjectInput | TransactionCreateOrConnectWithoutProjectInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutProjectInput | TransactionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TransactionCreateManyProjectInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutProjectInput | TransactionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutProjectInput | TransactionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CircleProjectUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CircleProjectCreateWithoutProjectInput, CircleProjectUncheckedCreateWithoutProjectInput> | CircleProjectCreateWithoutProjectInput[] | CircleProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CircleProjectCreateOrConnectWithoutProjectInput | CircleProjectCreateOrConnectWithoutProjectInput[]
    upsert?: CircleProjectUpsertWithWhereUniqueWithoutProjectInput | CircleProjectUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CircleProjectCreateManyProjectInputEnvelope
    set?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
    disconnect?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
    delete?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
    connect?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
    update?: CircleProjectUpdateWithWhereUniqueWithoutProjectInput | CircleProjectUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CircleProjectUpdateManyWithWhereWithoutProjectInput | CircleProjectUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CircleProjectScalarWhereInput | CircleProjectScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutMembersInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectMemberInput = {
    create?: XOR<UserCreateWithoutProjectMemberInput, UserUncheckedCreateWithoutProjectMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMemberInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    upsert?: ProjectUpsertWithoutMembersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMembersInput, ProjectUpdateWithoutMembersInput>, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutProjectMemberNestedInput = {
    create?: XOR<UserCreateWithoutProjectMemberInput, UserUncheckedCreateWithoutProjectMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMemberInput
    upsert?: UserUpsertWithoutProjectMemberInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectMemberInput, UserUpdateWithoutProjectMemberInput>, UserUncheckedUpdateWithoutProjectMemberInput>
  }

  export type ProjectUpdateCreateimagesInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutUpdatesInput = {
    create?: XOR<ProjectCreateWithoutUpdatesInput, ProjectUncheckedCreateWithoutUpdatesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutUpdatesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutProjectUpdateInput = {
    create?: XOR<UserCreateWithoutProjectUpdateInput, UserUncheckedCreateWithoutProjectUpdateInput> | UserCreateWithoutProjectUpdateInput[] | UserUncheckedCreateWithoutProjectUpdateInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProjectUpdateInput | UserCreateOrConnectWithoutProjectUpdateInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutProjectUpdateInput = {
    create?: XOR<UserCreateWithoutProjectUpdateInput, UserUncheckedCreateWithoutProjectUpdateInput> | UserCreateWithoutProjectUpdateInput[] | UserUncheckedCreateWithoutProjectUpdateInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProjectUpdateInput | UserCreateOrConnectWithoutProjectUpdateInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProjectUpdateUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdateOneRequiredWithoutUpdatesNestedInput = {
    create?: XOR<ProjectCreateWithoutUpdatesInput, ProjectUncheckedCreateWithoutUpdatesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutUpdatesInput
    upsert?: ProjectUpsertWithoutUpdatesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutUpdatesInput, ProjectUpdateWithoutUpdatesInput>, ProjectUncheckedUpdateWithoutUpdatesInput>
  }

  export type UserUpdateManyWithoutProjectUpdateNestedInput = {
    create?: XOR<UserCreateWithoutProjectUpdateInput, UserUncheckedCreateWithoutProjectUpdateInput> | UserCreateWithoutProjectUpdateInput[] | UserUncheckedCreateWithoutProjectUpdateInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProjectUpdateInput | UserCreateOrConnectWithoutProjectUpdateInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProjectUpdateInput | UserUpsertWithWhereUniqueWithoutProjectUpdateInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProjectUpdateInput | UserUpdateWithWhereUniqueWithoutProjectUpdateInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProjectUpdateInput | UserUpdateManyWithWhereWithoutProjectUpdateInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutProjectUpdateNestedInput = {
    create?: XOR<UserCreateWithoutProjectUpdateInput, UserUncheckedCreateWithoutProjectUpdateInput> | UserCreateWithoutProjectUpdateInput[] | UserUncheckedCreateWithoutProjectUpdateInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProjectUpdateInput | UserCreateOrConnectWithoutProjectUpdateInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProjectUpdateInput | UserUpsertWithWhereUniqueWithoutProjectUpdateInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProjectUpdateInput | UserUpdateWithWhereUniqueWithoutProjectUpdateInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProjectUpdateInput | UserUpdateManyWithWhereWithoutProjectUpdateInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutRewardsInput = {
    create?: XOR<ProjectCreateWithoutRewardsInput, ProjectUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRewardsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectDonationCreateNestedManyWithoutRewardInput = {
    create?: XOR<ProjectDonationCreateWithoutRewardInput, ProjectDonationUncheckedCreateWithoutRewardInput> | ProjectDonationCreateWithoutRewardInput[] | ProjectDonationUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: ProjectDonationCreateOrConnectWithoutRewardInput | ProjectDonationCreateOrConnectWithoutRewardInput[]
    createMany?: ProjectDonationCreateManyRewardInputEnvelope
    connect?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutProjectRewardInput = {
    create?: XOR<UserCreateWithoutProjectRewardInput, UserUncheckedCreateWithoutProjectRewardInput> | UserCreateWithoutProjectRewardInput[] | UserUncheckedCreateWithoutProjectRewardInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProjectRewardInput | UserCreateOrConnectWithoutProjectRewardInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProjectDonationUncheckedCreateNestedManyWithoutRewardInput = {
    create?: XOR<ProjectDonationCreateWithoutRewardInput, ProjectDonationUncheckedCreateWithoutRewardInput> | ProjectDonationCreateWithoutRewardInput[] | ProjectDonationUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: ProjectDonationCreateOrConnectWithoutRewardInput | ProjectDonationCreateOrConnectWithoutRewardInput[]
    createMany?: ProjectDonationCreateManyRewardInputEnvelope
    connect?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutProjectRewardInput = {
    create?: XOR<UserCreateWithoutProjectRewardInput, UserUncheckedCreateWithoutProjectRewardInput> | UserCreateWithoutProjectRewardInput[] | UserUncheckedCreateWithoutProjectRewardInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProjectRewardInput | UserCreateOrConnectWithoutProjectRewardInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateOneRequiredWithoutRewardsNestedInput = {
    create?: XOR<ProjectCreateWithoutRewardsInput, ProjectUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRewardsInput
    upsert?: ProjectUpsertWithoutRewardsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutRewardsInput, ProjectUpdateWithoutRewardsInput>, ProjectUncheckedUpdateWithoutRewardsInput>
  }

  export type ProjectDonationUpdateManyWithoutRewardNestedInput = {
    create?: XOR<ProjectDonationCreateWithoutRewardInput, ProjectDonationUncheckedCreateWithoutRewardInput> | ProjectDonationCreateWithoutRewardInput[] | ProjectDonationUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: ProjectDonationCreateOrConnectWithoutRewardInput | ProjectDonationCreateOrConnectWithoutRewardInput[]
    upsert?: ProjectDonationUpsertWithWhereUniqueWithoutRewardInput | ProjectDonationUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: ProjectDonationCreateManyRewardInputEnvelope
    set?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    disconnect?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    delete?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    connect?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    update?: ProjectDonationUpdateWithWhereUniqueWithoutRewardInput | ProjectDonationUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: ProjectDonationUpdateManyWithWhereWithoutRewardInput | ProjectDonationUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: ProjectDonationScalarWhereInput | ProjectDonationScalarWhereInput[]
  }

  export type UserUpdateManyWithoutProjectRewardNestedInput = {
    create?: XOR<UserCreateWithoutProjectRewardInput, UserUncheckedCreateWithoutProjectRewardInput> | UserCreateWithoutProjectRewardInput[] | UserUncheckedCreateWithoutProjectRewardInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProjectRewardInput | UserCreateOrConnectWithoutProjectRewardInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProjectRewardInput | UserUpsertWithWhereUniqueWithoutProjectRewardInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProjectRewardInput | UserUpdateWithWhereUniqueWithoutProjectRewardInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProjectRewardInput | UserUpdateManyWithWhereWithoutProjectRewardInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProjectDonationUncheckedUpdateManyWithoutRewardNestedInput = {
    create?: XOR<ProjectDonationCreateWithoutRewardInput, ProjectDonationUncheckedCreateWithoutRewardInput> | ProjectDonationCreateWithoutRewardInput[] | ProjectDonationUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: ProjectDonationCreateOrConnectWithoutRewardInput | ProjectDonationCreateOrConnectWithoutRewardInput[]
    upsert?: ProjectDonationUpsertWithWhereUniqueWithoutRewardInput | ProjectDonationUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: ProjectDonationCreateManyRewardInputEnvelope
    set?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    disconnect?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    delete?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    connect?: ProjectDonationWhereUniqueInput | ProjectDonationWhereUniqueInput[]
    update?: ProjectDonationUpdateWithWhereUniqueWithoutRewardInput | ProjectDonationUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: ProjectDonationUpdateManyWithWhereWithoutRewardInput | ProjectDonationUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: ProjectDonationScalarWhereInput | ProjectDonationScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutProjectRewardNestedInput = {
    create?: XOR<UserCreateWithoutProjectRewardInput, UserUncheckedCreateWithoutProjectRewardInput> | UserCreateWithoutProjectRewardInput[] | UserUncheckedCreateWithoutProjectRewardInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProjectRewardInput | UserCreateOrConnectWithoutProjectRewardInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProjectRewardInput | UserUpsertWithWhereUniqueWithoutProjectRewardInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProjectRewardInput | UserUpdateWithWhereUniqueWithoutProjectRewardInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProjectRewardInput | UserUpdateManyWithWhereWithoutProjectRewardInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutDonationsInput = {
    create?: XOR<ProjectCreateWithoutDonationsInput, ProjectUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDonationsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectDonationInput = {
    create?: XOR<UserCreateWithoutProjectDonationInput, UserUncheckedCreateWithoutProjectDonationInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectDonationInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectRewardCreateNestedOneWithoutProjectDonationInput = {
    create?: XOR<ProjectRewardCreateWithoutProjectDonationInput, ProjectRewardUncheckedCreateWithoutProjectDonationInput>
    connectOrCreate?: ProjectRewardCreateOrConnectWithoutProjectDonationInput
    connect?: ProjectRewardWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutDonationsNestedInput = {
    create?: XOR<ProjectCreateWithoutDonationsInput, ProjectUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDonationsInput
    upsert?: ProjectUpsertWithoutDonationsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDonationsInput, ProjectUpdateWithoutDonationsInput>, ProjectUncheckedUpdateWithoutDonationsInput>
  }

  export type UserUpdateOneRequiredWithoutProjectDonationNestedInput = {
    create?: XOR<UserCreateWithoutProjectDonationInput, UserUncheckedCreateWithoutProjectDonationInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectDonationInput
    upsert?: UserUpsertWithoutProjectDonationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectDonationInput, UserUpdateWithoutProjectDonationInput>, UserUncheckedUpdateWithoutProjectDonationInput>
  }

  export type ProjectRewardUpdateOneWithoutProjectDonationNestedInput = {
    create?: XOR<ProjectRewardCreateWithoutProjectDonationInput, ProjectRewardUncheckedCreateWithoutProjectDonationInput>
    connectOrCreate?: ProjectRewardCreateOrConnectWithoutProjectDonationInput
    upsert?: ProjectRewardUpsertWithoutProjectDonationInput
    disconnect?: ProjectRewardWhereInput | boolean
    delete?: ProjectRewardWhereInput | boolean
    connect?: ProjectRewardWhereUniqueInput
    update?: XOR<XOR<ProjectRewardUpdateToOneWithWhereWithoutProjectDonationInput, ProjectRewardUpdateWithoutProjectDonationInput>, ProjectRewardUncheckedUpdateWithoutProjectDonationInput>
  }

  export type ProjectCreateNestedOneWithoutInvestmentsInput = {
    create?: XOR<ProjectCreateWithoutInvestmentsInput, ProjectUncheckedCreateWithoutInvestmentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInvestmentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectInvestmentInput = {
    create?: XOR<UserCreateWithoutProjectInvestmentInput, UserUncheckedCreateWithoutProjectInvestmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectInvestmentInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutInvestmentsNestedInput = {
    create?: XOR<ProjectCreateWithoutInvestmentsInput, ProjectUncheckedCreateWithoutInvestmentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInvestmentsInput
    upsert?: ProjectUpsertWithoutInvestmentsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutInvestmentsInput, ProjectUpdateWithoutInvestmentsInput>, ProjectUncheckedUpdateWithoutInvestmentsInput>
  }

  export type UserUpdateOneRequiredWithoutProjectInvestmentNestedInput = {
    create?: XOR<UserCreateWithoutProjectInvestmentInput, UserUncheckedCreateWithoutProjectInvestmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectInvestmentInput
    upsert?: UserUpsertWithoutProjectInvestmentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectInvestmentInput, UserUpdateWithoutProjectInvestmentInput>, UserUncheckedUpdateWithoutProjectInvestmentInput>
  }

  export type ProjectCreateNestedOneWithoutLoansInput = {
    create?: XOR<ProjectCreateWithoutLoansInput, ProjectUncheckedCreateWithoutLoansInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLoansInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectLoanInput = {
    create?: XOR<UserCreateWithoutProjectLoanInput, UserUncheckedCreateWithoutProjectLoanInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectLoanInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutLoansNestedInput = {
    create?: XOR<ProjectCreateWithoutLoansInput, ProjectUncheckedCreateWithoutLoansInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLoansInput
    upsert?: ProjectUpsertWithoutLoansInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutLoansInput, ProjectUpdateWithoutLoansInput>, ProjectUncheckedUpdateWithoutLoansInput>
  }

  export type UserUpdateOneRequiredWithoutProjectLoanNestedInput = {
    create?: XOR<UserCreateWithoutProjectLoanInput, UserUncheckedCreateWithoutProjectLoanInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectLoanInput
    upsert?: UserUpsertWithoutProjectLoanInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectLoanInput, UserUpdateWithoutProjectLoanInput>, UserUncheckedUpdateWithoutProjectLoanInput>
  }

  export type UserCreateNestedOneWithoutCircleInput = {
    create?: XOR<UserCreateWithoutCircleInput, UserUncheckedCreateWithoutCircleInput>
    connectOrCreate?: UserCreateOrConnectWithoutCircleInput
    connect?: UserWhereUniqueInput
  }

  export type CircleMemberCreateNestedManyWithoutCircleInput = {
    create?: XOR<CircleMemberCreateWithoutCircleInput, CircleMemberUncheckedCreateWithoutCircleInput> | CircleMemberCreateWithoutCircleInput[] | CircleMemberUncheckedCreateWithoutCircleInput[]
    connectOrCreate?: CircleMemberCreateOrConnectWithoutCircleInput | CircleMemberCreateOrConnectWithoutCircleInput[]
    createMany?: CircleMemberCreateManyCircleInputEnvelope
    connect?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
  }

  export type CircleProjectCreateNestedManyWithoutCircleInput = {
    create?: XOR<CircleProjectCreateWithoutCircleInput, CircleProjectUncheckedCreateWithoutCircleInput> | CircleProjectCreateWithoutCircleInput[] | CircleProjectUncheckedCreateWithoutCircleInput[]
    connectOrCreate?: CircleProjectCreateOrConnectWithoutCircleInput | CircleProjectCreateOrConnectWithoutCircleInput[]
    createMany?: CircleProjectCreateManyCircleInputEnvelope
    connect?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutCircleInput = {
    create?: XOR<TransactionCreateWithoutCircleInput, TransactionUncheckedCreateWithoutCircleInput> | TransactionCreateWithoutCircleInput[] | TransactionUncheckedCreateWithoutCircleInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCircleInput | TransactionCreateOrConnectWithoutCircleInput[]
    createMany?: TransactionCreateManyCircleInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type CircleMemberUncheckedCreateNestedManyWithoutCircleInput = {
    create?: XOR<CircleMemberCreateWithoutCircleInput, CircleMemberUncheckedCreateWithoutCircleInput> | CircleMemberCreateWithoutCircleInput[] | CircleMemberUncheckedCreateWithoutCircleInput[]
    connectOrCreate?: CircleMemberCreateOrConnectWithoutCircleInput | CircleMemberCreateOrConnectWithoutCircleInput[]
    createMany?: CircleMemberCreateManyCircleInputEnvelope
    connect?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
  }

  export type CircleProjectUncheckedCreateNestedManyWithoutCircleInput = {
    create?: XOR<CircleProjectCreateWithoutCircleInput, CircleProjectUncheckedCreateWithoutCircleInput> | CircleProjectCreateWithoutCircleInput[] | CircleProjectUncheckedCreateWithoutCircleInput[]
    connectOrCreate?: CircleProjectCreateOrConnectWithoutCircleInput | CircleProjectCreateOrConnectWithoutCircleInput[]
    createMany?: CircleProjectCreateManyCircleInputEnvelope
    connect?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCircleInput = {
    create?: XOR<TransactionCreateWithoutCircleInput, TransactionUncheckedCreateWithoutCircleInput> | TransactionCreateWithoutCircleInput[] | TransactionUncheckedCreateWithoutCircleInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCircleInput | TransactionCreateOrConnectWithoutCircleInput[]
    createMany?: TransactionCreateManyCircleInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EnumCircleTypeFieldUpdateOperationsInput = {
    set?: $Enums.CircleType
  }

  export type EnumCircleParticipationModeFieldUpdateOperationsInput = {
    set?: $Enums.CircleParticipationMode
  }

  export type UserUpdateOneRequiredWithoutCircleNestedInput = {
    create?: XOR<UserCreateWithoutCircleInput, UserUncheckedCreateWithoutCircleInput>
    connectOrCreate?: UserCreateOrConnectWithoutCircleInput
    upsert?: UserUpsertWithoutCircleInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCircleInput, UserUpdateWithoutCircleInput>, UserUncheckedUpdateWithoutCircleInput>
  }

  export type CircleMemberUpdateManyWithoutCircleNestedInput = {
    create?: XOR<CircleMemberCreateWithoutCircleInput, CircleMemberUncheckedCreateWithoutCircleInput> | CircleMemberCreateWithoutCircleInput[] | CircleMemberUncheckedCreateWithoutCircleInput[]
    connectOrCreate?: CircleMemberCreateOrConnectWithoutCircleInput | CircleMemberCreateOrConnectWithoutCircleInput[]
    upsert?: CircleMemberUpsertWithWhereUniqueWithoutCircleInput | CircleMemberUpsertWithWhereUniqueWithoutCircleInput[]
    createMany?: CircleMemberCreateManyCircleInputEnvelope
    set?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
    disconnect?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
    delete?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
    connect?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
    update?: CircleMemberUpdateWithWhereUniqueWithoutCircleInput | CircleMemberUpdateWithWhereUniqueWithoutCircleInput[]
    updateMany?: CircleMemberUpdateManyWithWhereWithoutCircleInput | CircleMemberUpdateManyWithWhereWithoutCircleInput[]
    deleteMany?: CircleMemberScalarWhereInput | CircleMemberScalarWhereInput[]
  }

  export type CircleProjectUpdateManyWithoutCircleNestedInput = {
    create?: XOR<CircleProjectCreateWithoutCircleInput, CircleProjectUncheckedCreateWithoutCircleInput> | CircleProjectCreateWithoutCircleInput[] | CircleProjectUncheckedCreateWithoutCircleInput[]
    connectOrCreate?: CircleProjectCreateOrConnectWithoutCircleInput | CircleProjectCreateOrConnectWithoutCircleInput[]
    upsert?: CircleProjectUpsertWithWhereUniqueWithoutCircleInput | CircleProjectUpsertWithWhereUniqueWithoutCircleInput[]
    createMany?: CircleProjectCreateManyCircleInputEnvelope
    set?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
    disconnect?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
    delete?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
    connect?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
    update?: CircleProjectUpdateWithWhereUniqueWithoutCircleInput | CircleProjectUpdateWithWhereUniqueWithoutCircleInput[]
    updateMany?: CircleProjectUpdateManyWithWhereWithoutCircleInput | CircleProjectUpdateManyWithWhereWithoutCircleInput[]
    deleteMany?: CircleProjectScalarWhereInput | CircleProjectScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutCircleNestedInput = {
    create?: XOR<TransactionCreateWithoutCircleInput, TransactionUncheckedCreateWithoutCircleInput> | TransactionCreateWithoutCircleInput[] | TransactionUncheckedCreateWithoutCircleInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCircleInput | TransactionCreateOrConnectWithoutCircleInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCircleInput | TransactionUpsertWithWhereUniqueWithoutCircleInput[]
    createMany?: TransactionCreateManyCircleInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCircleInput | TransactionUpdateWithWhereUniqueWithoutCircleInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCircleInput | TransactionUpdateManyWithWhereWithoutCircleInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CircleMemberUncheckedUpdateManyWithoutCircleNestedInput = {
    create?: XOR<CircleMemberCreateWithoutCircleInput, CircleMemberUncheckedCreateWithoutCircleInput> | CircleMemberCreateWithoutCircleInput[] | CircleMemberUncheckedCreateWithoutCircleInput[]
    connectOrCreate?: CircleMemberCreateOrConnectWithoutCircleInput | CircleMemberCreateOrConnectWithoutCircleInput[]
    upsert?: CircleMemberUpsertWithWhereUniqueWithoutCircleInput | CircleMemberUpsertWithWhereUniqueWithoutCircleInput[]
    createMany?: CircleMemberCreateManyCircleInputEnvelope
    set?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
    disconnect?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
    delete?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
    connect?: CircleMemberWhereUniqueInput | CircleMemberWhereUniqueInput[]
    update?: CircleMemberUpdateWithWhereUniqueWithoutCircleInput | CircleMemberUpdateWithWhereUniqueWithoutCircleInput[]
    updateMany?: CircleMemberUpdateManyWithWhereWithoutCircleInput | CircleMemberUpdateManyWithWhereWithoutCircleInput[]
    deleteMany?: CircleMemberScalarWhereInput | CircleMemberScalarWhereInput[]
  }

  export type CircleProjectUncheckedUpdateManyWithoutCircleNestedInput = {
    create?: XOR<CircleProjectCreateWithoutCircleInput, CircleProjectUncheckedCreateWithoutCircleInput> | CircleProjectCreateWithoutCircleInput[] | CircleProjectUncheckedCreateWithoutCircleInput[]
    connectOrCreate?: CircleProjectCreateOrConnectWithoutCircleInput | CircleProjectCreateOrConnectWithoutCircleInput[]
    upsert?: CircleProjectUpsertWithWhereUniqueWithoutCircleInput | CircleProjectUpsertWithWhereUniqueWithoutCircleInput[]
    createMany?: CircleProjectCreateManyCircleInputEnvelope
    set?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
    disconnect?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
    delete?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
    connect?: CircleProjectWhereUniqueInput | CircleProjectWhereUniqueInput[]
    update?: CircleProjectUpdateWithWhereUniqueWithoutCircleInput | CircleProjectUpdateWithWhereUniqueWithoutCircleInput[]
    updateMany?: CircleProjectUpdateManyWithWhereWithoutCircleInput | CircleProjectUpdateManyWithWhereWithoutCircleInput[]
    deleteMany?: CircleProjectScalarWhereInput | CircleProjectScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCircleNestedInput = {
    create?: XOR<TransactionCreateWithoutCircleInput, TransactionUncheckedCreateWithoutCircleInput> | TransactionCreateWithoutCircleInput[] | TransactionUncheckedCreateWithoutCircleInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCircleInput | TransactionCreateOrConnectWithoutCircleInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCircleInput | TransactionUpsertWithWhereUniqueWithoutCircleInput[]
    createMany?: TransactionCreateManyCircleInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCircleInput | TransactionUpdateWithWhereUniqueWithoutCircleInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCircleInput | TransactionUpdateManyWithWhereWithoutCircleInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type CircleCreateNestedOneWithoutMembersInput = {
    create?: XOR<CircleCreateWithoutMembersInput, CircleUncheckedCreateWithoutMembersInput>
    connectOrCreate?: CircleCreateOrConnectWithoutMembersInput
    connect?: CircleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCircleMemberInput = {
    create?: XOR<UserCreateWithoutCircleMemberInput, UserUncheckedCreateWithoutCircleMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutCircleMemberInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCircleMemberRoleFieldUpdateOperationsInput = {
    set?: $Enums.CircleMemberRole
  }

  export type CircleUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<CircleCreateWithoutMembersInput, CircleUncheckedCreateWithoutMembersInput>
    connectOrCreate?: CircleCreateOrConnectWithoutMembersInput
    upsert?: CircleUpsertWithoutMembersInput
    connect?: CircleWhereUniqueInput
    update?: XOR<XOR<CircleUpdateToOneWithWhereWithoutMembersInput, CircleUpdateWithoutMembersInput>, CircleUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutCircleMemberNestedInput = {
    create?: XOR<UserCreateWithoutCircleMemberInput, UserUncheckedCreateWithoutCircleMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutCircleMemberInput
    upsert?: UserUpsertWithoutCircleMemberInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCircleMemberInput, UserUpdateWithoutCircleMemberInput>, UserUncheckedUpdateWithoutCircleMemberInput>
  }

  export type CircleCreateNestedOneWithoutProjectsInput = {
    create?: XOR<CircleCreateWithoutProjectsInput, CircleUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: CircleCreateOrConnectWithoutProjectsInput
    connect?: CircleWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutCircleProjectInput = {
    create?: XOR<ProjectCreateWithoutCircleProjectInput, ProjectUncheckedCreateWithoutCircleProjectInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCircleProjectInput
    connect?: ProjectWhereUniqueInput
  }

  export type CircleUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<CircleCreateWithoutProjectsInput, CircleUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: CircleCreateOrConnectWithoutProjectsInput
    upsert?: CircleUpsertWithoutProjectsInput
    connect?: CircleWhereUniqueInput
    update?: XOR<XOR<CircleUpdateToOneWithWhereWithoutProjectsInput, CircleUpdateWithoutProjectsInput>, CircleUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectUpdateOneRequiredWithoutCircleProjectNestedInput = {
    create?: XOR<ProjectCreateWithoutCircleProjectInput, ProjectUncheckedCreateWithoutCircleProjectInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCircleProjectInput
    upsert?: ProjectUpsertWithoutCircleProjectInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCircleProjectInput, ProjectUpdateWithoutCircleProjectInput>, ProjectUncheckedUpdateWithoutCircleProjectInput>
  }

  export type UserCreateNestedOneWithoutTransactionInput = {
    create?: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutTransactionInput = {
    create?: XOR<ProjectCreateWithoutTransactionInput, ProjectUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTransactionInput
    connect?: ProjectWhereUniqueInput
  }

  export type CircleCreateNestedOneWithoutTransactionInput = {
    create?: XOR<CircleCreateWithoutTransactionInput, CircleUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: CircleCreateOrConnectWithoutTransactionInput
    connect?: CircleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInput
    upsert?: UserUpsertWithoutTransactionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionInput, UserUpdateWithoutTransactionInput>, UserUncheckedUpdateWithoutTransactionInput>
  }

  export type ProjectUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<ProjectCreateWithoutTransactionInput, ProjectUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTransactionInput
    upsert?: ProjectUpsertWithoutTransactionInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTransactionInput, ProjectUpdateWithoutTransactionInput>, ProjectUncheckedUpdateWithoutTransactionInput>
  }

  export type CircleUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<CircleCreateWithoutTransactionInput, CircleUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: CircleCreateOrConnectWithoutTransactionInput
    upsert?: CircleUpsertWithoutTransactionInput
    disconnect?: CircleWhereInput | boolean
    delete?: CircleWhereInput | boolean
    connect?: CircleWhereUniqueInput
    update?: XOR<XOR<CircleUpdateToOneWithWhereWithoutTransactionInput, CircleUpdateWithoutTransactionInput>, CircleUncheckedUpdateWithoutTransactionInput>
  }

  export type UserCreateNestedOneWithoutUserXPInput = {
    create?: XOR<UserCreateWithoutUserXPInput, UserUncheckedCreateWithoutUserXPInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserXPInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserXPNestedInput = {
    create?: XOR<UserCreateWithoutUserXPInput, UserUncheckedCreateWithoutUserXPInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserXPInput
    upsert?: UserUpsertWithoutUserXPInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserXPInput, UserUpdateWithoutUserXPInput>, UserUncheckedUpdateWithoutUserXPInput>
  }

  export type UserBadgeCreateNestedManyWithoutBadgeInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserBadgeUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserBadgeUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutBadgeInput | UserBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutBadgeInput | UserBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutBadgeInput | UserBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserBadgeUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutBadgeInput | UserBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutBadgeInput | UserBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutBadgeInput | UserBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserBadgeInput = {
    create?: XOR<UserCreateWithoutUserBadgeInput, UserUncheckedCreateWithoutUserBadgeInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserBadgeInput
    connect?: UserWhereUniqueInput
  }

  export type BadgeCreateNestedOneWithoutUsersInput = {
    create?: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutUsersInput
    connect?: BadgeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserBadgeNestedInput = {
    create?: XOR<UserCreateWithoutUserBadgeInput, UserUncheckedCreateWithoutUserBadgeInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserBadgeInput
    upsert?: UserUpsertWithoutUserBadgeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserBadgeInput, UserUpdateWithoutUserBadgeInput>, UserUncheckedUpdateWithoutUserBadgeInput>
  }

  export type BadgeUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutUsersInput
    upsert?: BadgeUpsertWithoutUsersInput
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutUsersInput, BadgeUpdateWithoutUsersInput>, BadgeUncheckedUpdateWithoutUsersInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type NestedEnumPostVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityFilter<$PrismaModel> | $Enums.PostVisibility
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type NestedEnumPostVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.PostVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostVisibilityFilter<$PrismaModel>
    _max?: NestedEnumPostVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type NestedEnumCommentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentStatus | EnumCommentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommentStatusFilter<$PrismaModel> | $Enums.CommentStatus
  }

  export type NestedEnumCommentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentStatus | EnumCommentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommentStatusWithAggregatesFilter<$PrismaModel> | $Enums.CommentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommentStatusFilter<$PrismaModel>
    _max?: NestedEnumCommentStatusFilter<$PrismaModel>
  }

  export type NestedEnumReactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeFilter<$PrismaModel> | $Enums.ReactionType
  }

  export type NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumProjectTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectType | EnumProjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectTypeFilter<$PrismaModel> | $Enums.ProjectType
  }

  export type NestedEnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type NestedEnumProjectCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectCategory | EnumProjectCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectCategory[] | ListEnumProjectCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectCategory[] | ListEnumProjectCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectCategoryFilter<$PrismaModel> | $Enums.ProjectCategory
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumProjectTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectType | EnumProjectTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectType[] | ListEnumProjectTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProjectType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectTypeFilter<$PrismaModel>
    _max?: NestedEnumProjectTypeFilter<$PrismaModel>
  }

  export type NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type NestedEnumProjectCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectCategory | EnumProjectCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectCategory[] | ListEnumProjectCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectCategory[] | ListEnumProjectCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ProjectCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectCategoryFilter<$PrismaModel>
    _max?: NestedEnumProjectCategoryFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumCircleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CircleType | EnumCircleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CircleType[] | ListEnumCircleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CircleType[] | ListEnumCircleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCircleTypeFilter<$PrismaModel> | $Enums.CircleType
  }

  export type NestedEnumCircleParticipationModeFilter<$PrismaModel = never> = {
    equals?: $Enums.CircleParticipationMode | EnumCircleParticipationModeFieldRefInput<$PrismaModel>
    in?: $Enums.CircleParticipationMode[] | ListEnumCircleParticipationModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CircleParticipationMode[] | ListEnumCircleParticipationModeFieldRefInput<$PrismaModel>
    not?: NestedEnumCircleParticipationModeFilter<$PrismaModel> | $Enums.CircleParticipationMode
  }

  export type NestedEnumCircleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CircleType | EnumCircleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CircleType[] | ListEnumCircleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CircleType[] | ListEnumCircleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCircleTypeWithAggregatesFilter<$PrismaModel> | $Enums.CircleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCircleTypeFilter<$PrismaModel>
    _max?: NestedEnumCircleTypeFilter<$PrismaModel>
  }

  export type NestedEnumCircleParticipationModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CircleParticipationMode | EnumCircleParticipationModeFieldRefInput<$PrismaModel>
    in?: $Enums.CircleParticipationMode[] | ListEnumCircleParticipationModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CircleParticipationMode[] | ListEnumCircleParticipationModeFieldRefInput<$PrismaModel>
    not?: NestedEnumCircleParticipationModeWithAggregatesFilter<$PrismaModel> | $Enums.CircleParticipationMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCircleParticipationModeFilter<$PrismaModel>
    _max?: NestedEnumCircleParticipationModeFilter<$PrismaModel>
  }

  export type NestedEnumCircleMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.CircleMemberRole | EnumCircleMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CircleMemberRole[] | ListEnumCircleMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CircleMemberRole[] | ListEnumCircleMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCircleMemberRoleFilter<$PrismaModel> | $Enums.CircleMemberRole
  }

  export type NestedEnumCircleMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CircleMemberRole | EnumCircleMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CircleMemberRole[] | ListEnumCircleMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CircleMemberRole[] | ListEnumCircleMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCircleMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.CircleMemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCircleMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumCircleMemberRoleFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    age?: number | null
    profession?: string | null
    motivation?: string | null
    interests?: ProfileCreateinterestsInput | string[]
    experience?: string | null
    disponibility?: string | null
    bio?: string | null
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    phoneVerified?: boolean
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    age?: number | null
    profession?: string | null
    motivation?: string | null
    interests?: ProfileCreateinterestsInput | string[]
    experience?: string | null
    disponibility?: string | null
    bio?: string | null
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    phoneVerified?: boolean
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type ProfileCreateManyUserInputEnvelope = {
    data: ProfileCreateManyUserInput | ProfileCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type adressCreateWithoutUserInput = {
    id?: string
    street?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
  }

  export type adressUncheckedCreateWithoutUserInput = {
    id?: string
    street?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
  }

  export type adressCreateOrConnectWithoutUserInput = {
    where: adressWhereUniqueInput
    create: XOR<adressCreateWithoutUserInput, adressUncheckedCreateWithoutUserInput>
  }

  export type adressCreateManyUserInputEnvelope = {
    data: adressCreateManyUserInput | adressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutAuthorInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: PostCreateNestedOneWithoutChildrenInput
    children?: PostCreateNestedManyWithoutParentInput
    attachments?: MediaAssetCreateNestedManyWithoutPostInput
    codeSnippets?: CodeSnippetCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    project?: ProjectCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutAuthorInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    parentId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PostUncheckedCreateNestedManyWithoutParentInput
    attachments?: MediaAssetUncheckedCreateNestedManyWithoutPostInput
    codeSnippets?: CodeSnippetUncheckedCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsUncheckedCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutAuthorInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostCreateManyAuthorInputEnvelope = {
    data: PostCreateManyAuthorInput | PostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutOwnerInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    posts?: PostCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanCreateNestedManyWithoutProjectInput
    Transaction?: TransactionCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    posts?: PostUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardUncheckedCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationUncheckedCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentUncheckedCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanUncheckedCreateNestedManyWithoutProjectInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutOwnerInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput>
  }

  export type ProjectCreateManyOwnerInputEnvelope = {
    data: ProjectCreateManyOwnerInput | ProjectCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type CircleCreateWithoutCreatorInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: $Enums.CircleType
    theme?: string | null
    participationMode: $Enums.CircleParticipationMode
    maxMembers?: number | null
    isPublic?: boolean
    isActive?: boolean
    monthlyFee?: number | null
    funds?: number
    allocatedFunds?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CircleMemberCreateNestedManyWithoutCircleInput
    projects?: CircleProjectCreateNestedManyWithoutCircleInput
    Transaction?: TransactionCreateNestedManyWithoutCircleInput
  }

  export type CircleUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: $Enums.CircleType
    theme?: string | null
    participationMode: $Enums.CircleParticipationMode
    maxMembers?: number | null
    isPublic?: boolean
    isActive?: boolean
    monthlyFee?: number | null
    funds?: number
    allocatedFunds?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CircleMemberUncheckedCreateNestedManyWithoutCircleInput
    projects?: CircleProjectUncheckedCreateNestedManyWithoutCircleInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutCircleInput
  }

  export type CircleCreateOrConnectWithoutCreatorInput = {
    where: CircleWhereUniqueInput
    create: XOR<CircleCreateWithoutCreatorInput, CircleUncheckedCreateWithoutCreatorInput>
  }

  export type CircleCreateManyCreatorInputEnvelope = {
    data: CircleCreateManyCreatorInput | CircleCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ReactionCreateWithoutUserInput = {
    id?: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutReactionsInput
  }

  export type ReactionUncheckedCreateWithoutUserInput = {
    id?: string
    postId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type ReactionCreateOrConnectWithoutUserInput = {
    where: ReactionWhereUniqueInput
    create: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput>
  }

  export type ReactionCreateManyUserInputEnvelope = {
    data: ReactionCreateManyUserInput | ReactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutAuthorInput = {
    id?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    status?: $Enums.CommentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    postId: string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    status?: $Enums.CommentStatus
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMemberCreateWithoutUserInput = {
    id?: string
    role: string
    joinedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
  }

  export type ProjectMemberUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    role: string
    joinedAt?: Date | string
  }

  export type ProjectMemberCreateOrConnectWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberCreateManyUserInputEnvelope = {
    data: ProjectMemberCreateManyUserInput | ProjectMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectDonationCreateWithoutUserInput = {
    id?: string
    amount: number
    isAnonymous?: boolean
    message?: string | null
    status?: string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutDonationsInput
    reward?: ProjectRewardCreateNestedOneWithoutProjectDonationInput
  }

  export type ProjectDonationUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    amount: number
    isAnonymous?: boolean
    message?: string | null
    rewardId?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type ProjectDonationCreateOrConnectWithoutUserInput = {
    where: ProjectDonationWhereUniqueInput
    create: XOR<ProjectDonationCreateWithoutUserInput, ProjectDonationUncheckedCreateWithoutUserInput>
  }

  export type ProjectDonationCreateManyUserInputEnvelope = {
    data: ProjectDonationCreateManyUserInput | ProjectDonationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectInvestmentCreateWithoutUserInput = {
    id?: string
    amount: number
    shares?: number | null
    status?: string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutInvestmentsInput
  }

  export type ProjectInvestmentUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    amount: number
    shares?: number | null
    status?: string
    createdAt?: Date | string
  }

  export type ProjectInvestmentCreateOrConnectWithoutUserInput = {
    where: ProjectInvestmentWhereUniqueInput
    create: XOR<ProjectInvestmentCreateWithoutUserInput, ProjectInvestmentUncheckedCreateWithoutUserInput>
  }

  export type ProjectInvestmentCreateManyUserInputEnvelope = {
    data: ProjectInvestmentCreateManyUserInput | ProjectInvestmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectLoanCreateWithoutUserInput = {
    id?: string
    amount: number
    status?: string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutLoansInput
  }

  export type ProjectLoanUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    amount: number
    status?: string
    createdAt?: Date | string
  }

  export type ProjectLoanCreateOrConnectWithoutUserInput = {
    where: ProjectLoanWhereUniqueInput
    create: XOR<ProjectLoanCreateWithoutUserInput, ProjectLoanUncheckedCreateWithoutUserInput>
  }

  export type ProjectLoanCreateManyUserInputEnvelope = {
    data: ProjectLoanCreateManyUserInput | ProjectLoanCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CircleMemberCreateWithoutUserInput = {
    id?: string
    role: $Enums.CircleMemberRole
    joinedAt?: Date | string
    xp?: number
    level?: number
    circle: CircleCreateNestedOneWithoutMembersInput
  }

  export type CircleMemberUncheckedCreateWithoutUserInput = {
    id?: string
    circleId: string
    role: $Enums.CircleMemberRole
    joinedAt?: Date | string
    xp?: number
    level?: number
  }

  export type CircleMemberCreateOrConnectWithoutUserInput = {
    where: CircleMemberWhereUniqueInput
    create: XOR<CircleMemberCreateWithoutUserInput, CircleMemberUncheckedCreateWithoutUserInput>
  }

  export type CircleMemberCreateManyUserInputEnvelope = {
    data: CircleMemberCreateManyUserInput | CircleMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpdateCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    images?: ProjectUpdateCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutUpdatesInput
  }

  export type ProjectUpdateUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    title: string
    content: string
    images?: ProjectUpdateCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateCreateOrConnectWithoutUserInput = {
    where: ProjectUpdateWhereUniqueInput
    create: XOR<ProjectUpdateCreateWithoutUserInput, ProjectUpdateUncheckedCreateWithoutUserInput>
  }

  export type ProjectRewardCreateWithoutUserInput = {
    id?: string
    amount: number
    title: string
    description: string
    image?: string | null
    deliveryDate?: Date | string | null
    quantity?: number | null
    claimed?: number
    project: ProjectCreateNestedOneWithoutRewardsInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutRewardInput
  }

  export type ProjectRewardUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    amount: number
    title: string
    description: string
    image?: string | null
    deliveryDate?: Date | string | null
    quantity?: number | null
    claimed?: number
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutRewardInput
  }

  export type ProjectRewardCreateOrConnectWithoutUserInput = {
    where: ProjectRewardWhereUniqueInput
    create: XOR<ProjectRewardCreateWithoutUserInput, ProjectRewardUncheckedCreateWithoutUserInput>
  }

  export type UserBadgeCreateWithoutUserInput = {
    id?: string
    earnedAt?: Date | string
    badge: BadgeCreateNestedOneWithoutUsersInput
  }

  export type UserBadgeUncheckedCreateWithoutUserInput = {
    id?: string
    badgeId: string
    earnedAt?: Date | string
  }

  export type UserBadgeCreateOrConnectWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    create: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput>
  }

  export type UserBadgeCreateManyUserInputEnvelope = {
    data: UserBadgeCreateManyUserInput | UserBadgeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserXPCreateWithoutUserInput = {
    id?: string
    totalXP?: number
    level?: number
    impactRank?: string | null
    donationXP?: number
    investmentXP?: number
    contentXP?: number
    communityXP?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserXPUncheckedCreateWithoutUserInput = {
    id?: string
    totalXP?: number
    level?: number
    impactRank?: string | null
    donationXP?: number
    investmentXP?: number
    contentXP?: number
    communityXP?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserXPCreateOrConnectWithoutUserInput = {
    where: UserXPWhereUniqueInput
    create: XOR<UserXPCreateWithoutUserInput, UserXPUncheckedCreateWithoutUserInput>
  }

  export type UserXPCreateManyUserInputEnvelope = {
    data: UserXPCreateManyUserInput | UserXPCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    type: string
    amount: number
    currency?: string
    status?: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutTransactionInput
    circle?: CircleCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    amount: number
    currency?: string
    status?: string
    description?: string | null
    projectId?: string | null
    circleId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type ProfileUpsertWithWhereUniqueWithoutUserInput = {
    where: ProfileWhereUniqueInput
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type ProfileUpdateWithWhereUniqueWithoutUserInput = {
    where: ProfileWhereUniqueInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateManyWithWhereWithoutUserInput = {
    where: ProfileScalarWhereInput
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyWithoutUserInput>
  }

  export type ProfileScalarWhereInput = {
    AND?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    OR?: ProfileScalarWhereInput[]
    NOT?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    id?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    age?: IntNullableFilter<"Profile"> | number | null
    profession?: StringNullableFilter<"Profile"> | string | null
    motivation?: StringNullableFilter<"Profile"> | string | null
    interests?: StringNullableListFilter<"Profile">
    experience?: StringNullableFilter<"Profile"> | string | null
    disponibility?: StringNullableFilter<"Profile"> | string | null
    bio?: StringNullableFilter<"Profile"> | string | null
    firstName?: StringNullableFilter<"Profile"> | string | null
    lastName?: StringNullableFilter<"Profile"> | string | null
    phone?: StringNullableFilter<"Profile"> | string | null
    phoneVerified?: BoolFilter<"Profile"> | boolean
  }

  export type adressUpsertWithWhereUniqueWithoutUserInput = {
    where: adressWhereUniqueInput
    update: XOR<adressUpdateWithoutUserInput, adressUncheckedUpdateWithoutUserInput>
    create: XOR<adressCreateWithoutUserInput, adressUncheckedCreateWithoutUserInput>
  }

  export type adressUpdateWithWhereUniqueWithoutUserInput = {
    where: adressWhereUniqueInput
    data: XOR<adressUpdateWithoutUserInput, adressUncheckedUpdateWithoutUserInput>
  }

  export type adressUpdateManyWithWhereWithoutUserInput = {
    where: adressScalarWhereInput
    data: XOR<adressUpdateManyMutationInput, adressUncheckedUpdateManyWithoutUserInput>
  }

  export type adressScalarWhereInput = {
    AND?: adressScalarWhereInput | adressScalarWhereInput[]
    OR?: adressScalarWhereInput[]
    NOT?: adressScalarWhereInput | adressScalarWhereInput[]
    id?: StringFilter<"adress"> | string
    userId?: StringFilter<"adress"> | string
    street?: StringNullableFilter<"adress"> | string | null
    city?: StringNullableFilter<"adress"> | string | null
    state?: StringNullableFilter<"adress"> | string | null
    postalCode?: StringNullableFilter<"adress"> | string | null
    country?: StringNullableFilter<"adress"> | string | null
  }

  export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
  }

  export type PostUpdateManyWithWhereWithoutAuthorInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: StringFilter<"Post"> | string
    slug?: StringFilter<"Post"> | string
    title?: StringFilter<"Post"> | string
    subtitle?: StringNullableFilter<"Post"> | string | null
    content?: JsonNullableFilter<"Post">
    contentText?: StringNullableFilter<"Post"> | string | null
    excerpt?: StringNullableFilter<"Post"> | string | null
    coverImageUrl?: StringNullableFilter<"Post"> | string | null
    canonicalUrl?: StringNullableFilter<"Post"> | string | null
    ogImageUrl?: StringNullableFilter<"Post"> | string | null
    status?: EnumPostStatusFilter<"Post"> | $Enums.PostStatus
    visibility?: EnumPostVisibilityFilter<"Post"> | $Enums.PostVisibility
    publishedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    scheduledAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    readingTime?: IntNullableFilter<"Post"> | number | null
    wordCount?: IntNullableFilter<"Post"> | number | null
    language?: StringNullableFilter<"Post"> | string | null
    authorId?: StringFilter<"Post"> | string
    parentId?: StringNullableFilter<"Post"> | string | null
    projectId?: StringNullableFilter<"Post"> | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutOwnerInput, ProjectUncheckedUpdateWithoutOwnerInput>
    create: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutOwnerInput, ProjectUncheckedUpdateWithoutOwnerInput>
  }

  export type ProjectUpdateManyWithWhereWithoutOwnerInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    slug?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    shortDescription?: StringNullableFilter<"Project"> | string | null
    type?: EnumProjectTypeFilter<"Project"> | $Enums.ProjectType
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    category?: EnumProjectCategoryFilter<"Project"> | $Enums.ProjectCategory
    location?: StringNullableFilter<"Project"> | string | null
    fundingGoal?: FloatFilter<"Project"> | number
    amountRaised?: FloatFilter<"Project"> | number
    currency?: StringFilter<"Project"> | string
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    duration?: IntNullableFilter<"Project"> | number | null
    ownerId?: StringFilter<"Project"> | string
    organization?: StringNullableFilter<"Project"> | string | null
    legalStatus?: StringNullableFilter<"Project"> | string | null
    website?: StringNullableFilter<"Project"> | string | null
    socialMedia?: JsonNullableFilter<"Project">
    contactEmail?: StringNullableFilter<"Project"> | string | null
    contactPhone?: StringNullableFilter<"Project"> | string | null
    impactTypes?: EnumProjectImpactTypeNullableListFilter<"Project">
    impactDescription?: StringNullableFilter<"Project"> | string | null
    impactIndicators?: StringNullableListFilter<"Project">
    sdgAlignment?: IntNullableListFilter<"Project">
    images?: StringNullableListFilter<"Project">
    videos?: StringNullableListFilter<"Project">
    documents?: StringNullableListFilter<"Project">
    visibility?: EnumPostVisibilityFilter<"Project"> | $Enums.PostVisibility
    allowComments?: BoolFilter<"Project"> | boolean
    enableImpactSprint?: BoolFilter<"Project"> | boolean
    valuation?: FloatNullableFilter<"Project"> | number | null
    minInvestment?: FloatNullableFilter<"Project"> | number | null
    capitalPercentage?: FloatNullableFilter<"Project"> | number | null
    expectedInvestors?: IntNullableFilter<"Project"> | number | null
    taxAdvantages?: StringNullableFilter<"Project"> | string | null
    interestRate?: FloatNullableFilter<"Project"> | number | null
    loanDuration?: IntNullableFilter<"Project"> | number | null
    repaymentFrequency?: StringNullableFilter<"Project"> | string | null
    minLoanAmount?: FloatNullableFilter<"Project"> | number | null
    guarantees?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type CircleUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CircleWhereUniqueInput
    update: XOR<CircleUpdateWithoutCreatorInput, CircleUncheckedUpdateWithoutCreatorInput>
    create: XOR<CircleCreateWithoutCreatorInput, CircleUncheckedCreateWithoutCreatorInput>
  }

  export type CircleUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CircleWhereUniqueInput
    data: XOR<CircleUpdateWithoutCreatorInput, CircleUncheckedUpdateWithoutCreatorInput>
  }

  export type CircleUpdateManyWithWhereWithoutCreatorInput = {
    where: CircleScalarWhereInput
    data: XOR<CircleUpdateManyMutationInput, CircleUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CircleScalarWhereInput = {
    AND?: CircleScalarWhereInput | CircleScalarWhereInput[]
    OR?: CircleScalarWhereInput[]
    NOT?: CircleScalarWhereInput | CircleScalarWhereInput[]
    id?: StringFilter<"Circle"> | string
    name?: StringFilter<"Circle"> | string
    slug?: StringFilter<"Circle"> | string
    description?: StringNullableFilter<"Circle"> | string | null
    type?: EnumCircleTypeFilter<"Circle"> | $Enums.CircleType
    theme?: StringNullableFilter<"Circle"> | string | null
    participationMode?: EnumCircleParticipationModeFilter<"Circle"> | $Enums.CircleParticipationMode
    maxMembers?: IntNullableFilter<"Circle"> | number | null
    isPublic?: BoolFilter<"Circle"> | boolean
    isActive?: BoolFilter<"Circle"> | boolean
    monthlyFee?: FloatNullableFilter<"Circle"> | number | null
    funds?: FloatFilter<"Circle"> | number
    allocatedFunds?: FloatFilter<"Circle"> | number
    creatorId?: StringFilter<"Circle"> | string
    createdAt?: DateTimeFilter<"Circle"> | Date | string
    updatedAt?: DateTimeFilter<"Circle"> | Date | string
  }

  export type ReactionUpsertWithWhereUniqueWithoutUserInput = {
    where: ReactionWhereUniqueInput
    update: XOR<ReactionUpdateWithoutUserInput, ReactionUncheckedUpdateWithoutUserInput>
    create: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput>
  }

  export type ReactionUpdateWithWhereUniqueWithoutUserInput = {
    where: ReactionWhereUniqueInput
    data: XOR<ReactionUpdateWithoutUserInput, ReactionUncheckedUpdateWithoutUserInput>
  }

  export type ReactionUpdateManyWithWhereWithoutUserInput = {
    where: ReactionScalarWhereInput
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyWithoutUserInput>
  }

  export type ReactionScalarWhereInput = {
    AND?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
    OR?: ReactionScalarWhereInput[]
    NOT?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
    id?: StringFilter<"Reaction"> | string
    postId?: StringFilter<"Reaction"> | string
    userId?: StringFilter<"Reaction"> | string
    type?: EnumReactionTypeFilter<"Reaction"> | $Enums.ReactionType
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    content?: JsonNullableFilter<"Comment">
    contentText?: StringNullableFilter<"Comment"> | string | null
    status?: EnumCommentStatusFilter<"Comment"> | $Enums.CommentStatus
    parentId?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutUserInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectMemberScalarWhereInput = {
    AND?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    OR?: ProjectMemberScalarWhereInput[]
    NOT?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    id?: StringFilter<"ProjectMember"> | string
    projectId?: StringFilter<"ProjectMember"> | string
    userId?: StringFilter<"ProjectMember"> | string
    role?: StringFilter<"ProjectMember"> | string
    joinedAt?: DateTimeFilter<"ProjectMember"> | Date | string
  }

  export type ProjectDonationUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectDonationWhereUniqueInput
    update: XOR<ProjectDonationUpdateWithoutUserInput, ProjectDonationUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectDonationCreateWithoutUserInput, ProjectDonationUncheckedCreateWithoutUserInput>
  }

  export type ProjectDonationUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectDonationWhereUniqueInput
    data: XOR<ProjectDonationUpdateWithoutUserInput, ProjectDonationUncheckedUpdateWithoutUserInput>
  }

  export type ProjectDonationUpdateManyWithWhereWithoutUserInput = {
    where: ProjectDonationScalarWhereInput
    data: XOR<ProjectDonationUpdateManyMutationInput, ProjectDonationUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectDonationScalarWhereInput = {
    AND?: ProjectDonationScalarWhereInput | ProjectDonationScalarWhereInput[]
    OR?: ProjectDonationScalarWhereInput[]
    NOT?: ProjectDonationScalarWhereInput | ProjectDonationScalarWhereInput[]
    id?: StringFilter<"ProjectDonation"> | string
    projectId?: StringFilter<"ProjectDonation"> | string
    userId?: StringFilter<"ProjectDonation"> | string
    amount?: FloatFilter<"ProjectDonation"> | number
    isAnonymous?: BoolFilter<"ProjectDonation"> | boolean
    message?: StringNullableFilter<"ProjectDonation"> | string | null
    rewardId?: StringNullableFilter<"ProjectDonation"> | string | null
    status?: StringFilter<"ProjectDonation"> | string
    createdAt?: DateTimeFilter<"ProjectDonation"> | Date | string
  }

  export type ProjectInvestmentUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectInvestmentWhereUniqueInput
    update: XOR<ProjectInvestmentUpdateWithoutUserInput, ProjectInvestmentUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectInvestmentCreateWithoutUserInput, ProjectInvestmentUncheckedCreateWithoutUserInput>
  }

  export type ProjectInvestmentUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectInvestmentWhereUniqueInput
    data: XOR<ProjectInvestmentUpdateWithoutUserInput, ProjectInvestmentUncheckedUpdateWithoutUserInput>
  }

  export type ProjectInvestmentUpdateManyWithWhereWithoutUserInput = {
    where: ProjectInvestmentScalarWhereInput
    data: XOR<ProjectInvestmentUpdateManyMutationInput, ProjectInvestmentUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectInvestmentScalarWhereInput = {
    AND?: ProjectInvestmentScalarWhereInput | ProjectInvestmentScalarWhereInput[]
    OR?: ProjectInvestmentScalarWhereInput[]
    NOT?: ProjectInvestmentScalarWhereInput | ProjectInvestmentScalarWhereInput[]
    id?: StringFilter<"ProjectInvestment"> | string
    projectId?: StringFilter<"ProjectInvestment"> | string
    userId?: StringFilter<"ProjectInvestment"> | string
    amount?: FloatFilter<"ProjectInvestment"> | number
    shares?: FloatNullableFilter<"ProjectInvestment"> | number | null
    status?: StringFilter<"ProjectInvestment"> | string
    createdAt?: DateTimeFilter<"ProjectInvestment"> | Date | string
  }

  export type ProjectLoanUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectLoanWhereUniqueInput
    update: XOR<ProjectLoanUpdateWithoutUserInput, ProjectLoanUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectLoanCreateWithoutUserInput, ProjectLoanUncheckedCreateWithoutUserInput>
  }

  export type ProjectLoanUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectLoanWhereUniqueInput
    data: XOR<ProjectLoanUpdateWithoutUserInput, ProjectLoanUncheckedUpdateWithoutUserInput>
  }

  export type ProjectLoanUpdateManyWithWhereWithoutUserInput = {
    where: ProjectLoanScalarWhereInput
    data: XOR<ProjectLoanUpdateManyMutationInput, ProjectLoanUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectLoanScalarWhereInput = {
    AND?: ProjectLoanScalarWhereInput | ProjectLoanScalarWhereInput[]
    OR?: ProjectLoanScalarWhereInput[]
    NOT?: ProjectLoanScalarWhereInput | ProjectLoanScalarWhereInput[]
    id?: StringFilter<"ProjectLoan"> | string
    projectId?: StringFilter<"ProjectLoan"> | string
    userId?: StringFilter<"ProjectLoan"> | string
    amount?: FloatFilter<"ProjectLoan"> | number
    status?: StringFilter<"ProjectLoan"> | string
    createdAt?: DateTimeFilter<"ProjectLoan"> | Date | string
  }

  export type CircleMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: CircleMemberWhereUniqueInput
    update: XOR<CircleMemberUpdateWithoutUserInput, CircleMemberUncheckedUpdateWithoutUserInput>
    create: XOR<CircleMemberCreateWithoutUserInput, CircleMemberUncheckedCreateWithoutUserInput>
  }

  export type CircleMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: CircleMemberWhereUniqueInput
    data: XOR<CircleMemberUpdateWithoutUserInput, CircleMemberUncheckedUpdateWithoutUserInput>
  }

  export type CircleMemberUpdateManyWithWhereWithoutUserInput = {
    where: CircleMemberScalarWhereInput
    data: XOR<CircleMemberUpdateManyMutationInput, CircleMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type CircleMemberScalarWhereInput = {
    AND?: CircleMemberScalarWhereInput | CircleMemberScalarWhereInput[]
    OR?: CircleMemberScalarWhereInput[]
    NOT?: CircleMemberScalarWhereInput | CircleMemberScalarWhereInput[]
    id?: StringFilter<"CircleMember"> | string
    circleId?: StringFilter<"CircleMember"> | string
    userId?: StringFilter<"CircleMember"> | string
    role?: EnumCircleMemberRoleFilter<"CircleMember"> | $Enums.CircleMemberRole
    joinedAt?: DateTimeFilter<"CircleMember"> | Date | string
    xp?: IntFilter<"CircleMember"> | number
    level?: IntFilter<"CircleMember"> | number
  }

  export type ProjectUpdateUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectUpdateWhereUniqueInput
    update: XOR<ProjectUpdateUpdateWithoutUserInput, ProjectUpdateUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectUpdateCreateWithoutUserInput, ProjectUpdateUncheckedCreateWithoutUserInput>
  }

  export type ProjectUpdateUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectUpdateWhereUniqueInput
    data: XOR<ProjectUpdateUpdateWithoutUserInput, ProjectUpdateUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUpdateUpdateManyWithWhereWithoutUserInput = {
    where: ProjectUpdateScalarWhereInput
    data: XOR<ProjectUpdateUpdateManyMutationInput, ProjectUpdateUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectUpdateScalarWhereInput = {
    AND?: ProjectUpdateScalarWhereInput | ProjectUpdateScalarWhereInput[]
    OR?: ProjectUpdateScalarWhereInput[]
    NOT?: ProjectUpdateScalarWhereInput | ProjectUpdateScalarWhereInput[]
    id?: StringFilter<"ProjectUpdate"> | string
    projectId?: StringFilter<"ProjectUpdate"> | string
    title?: StringFilter<"ProjectUpdate"> | string
    content?: StringFilter<"ProjectUpdate"> | string
    images?: StringNullableListFilter<"ProjectUpdate">
    createdAt?: DateTimeFilter<"ProjectUpdate"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectUpdate"> | Date | string
  }

  export type ProjectRewardUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectRewardWhereUniqueInput
    update: XOR<ProjectRewardUpdateWithoutUserInput, ProjectRewardUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectRewardCreateWithoutUserInput, ProjectRewardUncheckedCreateWithoutUserInput>
  }

  export type ProjectRewardUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectRewardWhereUniqueInput
    data: XOR<ProjectRewardUpdateWithoutUserInput, ProjectRewardUncheckedUpdateWithoutUserInput>
  }

  export type ProjectRewardUpdateManyWithWhereWithoutUserInput = {
    where: ProjectRewardScalarWhereInput
    data: XOR<ProjectRewardUpdateManyMutationInput, ProjectRewardUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectRewardScalarWhereInput = {
    AND?: ProjectRewardScalarWhereInput | ProjectRewardScalarWhereInput[]
    OR?: ProjectRewardScalarWhereInput[]
    NOT?: ProjectRewardScalarWhereInput | ProjectRewardScalarWhereInput[]
    id?: StringFilter<"ProjectReward"> | string
    projectId?: StringFilter<"ProjectReward"> | string
    amount?: FloatFilter<"ProjectReward"> | number
    title?: StringFilter<"ProjectReward"> | string
    description?: StringFilter<"ProjectReward"> | string
    image?: StringNullableFilter<"ProjectReward"> | string | null
    deliveryDate?: DateTimeNullableFilter<"ProjectReward"> | Date | string | null
    quantity?: IntNullableFilter<"ProjectReward"> | number | null
    claimed?: IntFilter<"ProjectReward"> | number
  }

  export type UserBadgeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    update: XOR<UserBadgeUpdateWithoutUserInput, UserBadgeUncheckedUpdateWithoutUserInput>
    create: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput>
  }

  export type UserBadgeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    data: XOR<UserBadgeUpdateWithoutUserInput, UserBadgeUncheckedUpdateWithoutUserInput>
  }

  export type UserBadgeUpdateManyWithWhereWithoutUserInput = {
    where: UserBadgeScalarWhereInput
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyWithoutUserInput>
  }

  export type UserBadgeScalarWhereInput = {
    AND?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    OR?: UserBadgeScalarWhereInput[]
    NOT?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    id?: StringFilter<"UserBadge"> | string
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: StringFilter<"UserBadge"> | string
    earnedAt?: DateTimeFilter<"UserBadge"> | Date | string
  }

  export type UserXPUpsertWithWhereUniqueWithoutUserInput = {
    where: UserXPWhereUniqueInput
    update: XOR<UserXPUpdateWithoutUserInput, UserXPUncheckedUpdateWithoutUserInput>
    create: XOR<UserXPCreateWithoutUserInput, UserXPUncheckedCreateWithoutUserInput>
  }

  export type UserXPUpdateWithWhereUniqueWithoutUserInput = {
    where: UserXPWhereUniqueInput
    data: XOR<UserXPUpdateWithoutUserInput, UserXPUncheckedUpdateWithoutUserInput>
  }

  export type UserXPUpdateManyWithWhereWithoutUserInput = {
    where: UserXPScalarWhereInput
    data: XOR<UserXPUpdateManyMutationInput, UserXPUncheckedUpdateManyWithoutUserInput>
  }

  export type UserXPScalarWhereInput = {
    AND?: UserXPScalarWhereInput | UserXPScalarWhereInput[]
    OR?: UserXPScalarWhereInput[]
    NOT?: UserXPScalarWhereInput | UserXPScalarWhereInput[]
    id?: StringFilter<"UserXP"> | string
    userId?: StringFilter<"UserXP"> | string
    totalXP?: IntFilter<"UserXP"> | number
    level?: IntFilter<"UserXP"> | number
    impactRank?: StringNullableFilter<"UserXP"> | string | null
    donationXP?: IntFilter<"UserXP"> | number
    investmentXP?: IntFilter<"UserXP"> | number
    contentXP?: IntFilter<"UserXP"> | number
    communityXP?: IntFilter<"UserXP"> | number
    createdAt?: DateTimeFilter<"UserXP"> | Date | string
    updatedAt?: DateTimeFilter<"UserXP"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    type?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    currency?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    description?: StringNullableFilter<"Transaction"> | string | null
    projectId?: StringNullableFilter<"Transaction"> | string | null
    circleId?: StringNullableFilter<"Transaction"> | string | null
    metadata?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedManyWithoutUserInput
    adress?: adressCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutAuthorInput
    Project?: ProjectCreateNestedManyWithoutOwnerInput
    Circle?: CircleCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeCreateNestedManyWithoutUserInput
    UserXP?: UserXPCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    adress?: adressUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutAuthorInput
    Project?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    Circle?: CircleUncheckedCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanUncheckedCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateUncheckedCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardUncheckedCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    UserXP?: UserXPUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateManyWithoutUserNestedInput
    adress?: adressUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    adress?: adressUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUncheckedUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUncheckedUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUncheckedUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    sessions?: SessionCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedManyWithoutUserInput
    adress?: adressCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutAuthorInput
    Project?: ProjectCreateNestedManyWithoutOwnerInput
    Circle?: CircleCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeCreateNestedManyWithoutUserInput
    UserXP?: UserXPCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    adress?: adressUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutAuthorInput
    Project?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    Circle?: CircleUncheckedCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanUncheckedCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateUncheckedCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardUncheckedCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    UserXP?: UserXPUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateManyWithoutUserNestedInput
    adress?: adressUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    adress?: adressUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUncheckedUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUncheckedUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUncheckedUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    adress?: adressCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutAuthorInput
    Project?: ProjectCreateNestedManyWithoutOwnerInput
    Circle?: CircleCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeCreateNestedManyWithoutUserInput
    UserXP?: UserXPCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    adress?: adressUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutAuthorInput
    Project?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    Circle?: CircleUncheckedCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanUncheckedCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateUncheckedCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardUncheckedCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    UserXP?: UserXPUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    adress?: adressUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    adress?: adressUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUncheckedUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUncheckedUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUncheckedUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAdressInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutAuthorInput
    Project?: ProjectCreateNestedManyWithoutOwnerInput
    Circle?: CircleCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeCreateNestedManyWithoutUserInput
    UserXP?: UserXPCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdressInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutAuthorInput
    Project?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    Circle?: CircleUncheckedCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanUncheckedCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateUncheckedCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardUncheckedCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    UserXP?: UserXPUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdressInput, UserUncheckedCreateWithoutAdressInput>
  }

  export type UserUpsertWithoutAdressInput = {
    update: XOR<UserUpdateWithoutAdressInput, UserUncheckedUpdateWithoutAdressInput>
    create: XOR<UserCreateWithoutAdressInput, UserUncheckedCreateWithoutAdressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdressInput, UserUncheckedUpdateWithoutAdressInput>
  }

  export type UserUpdateWithoutAdressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUncheckedUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUncheckedUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUncheckedUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPostInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedManyWithoutUserInput
    adress?: adressCreateNestedManyWithoutUserInput
    Project?: ProjectCreateNestedManyWithoutOwnerInput
    Circle?: CircleCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeCreateNestedManyWithoutUserInput
    UserXP?: UserXPCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    adress?: adressUncheckedCreateNestedManyWithoutUserInput
    Project?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    Circle?: CircleUncheckedCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanUncheckedCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateUncheckedCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardUncheckedCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    UserXP?: UserXPUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostInput, UserUncheckedCreateWithoutPostInput>
  }

  export type PostCreateWithoutChildrenInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostInput
    parent?: PostCreateNestedOneWithoutChildrenInput
    attachments?: MediaAssetCreateNestedManyWithoutPostInput
    codeSnippets?: CodeSnippetCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    project?: ProjectCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutChildrenInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    authorId: string
    parentId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: MediaAssetUncheckedCreateNestedManyWithoutPostInput
    codeSnippets?: CodeSnippetUncheckedCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsUncheckedCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutChildrenInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutChildrenInput, PostUncheckedCreateWithoutChildrenInput>
  }

  export type PostCreateWithoutParentInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostInput
    children?: PostCreateNestedManyWithoutParentInput
    attachments?: MediaAssetCreateNestedManyWithoutPostInput
    codeSnippets?: CodeSnippetCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    project?: ProjectCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutParentInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    authorId: string
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PostUncheckedCreateNestedManyWithoutParentInput
    attachments?: MediaAssetUncheckedCreateNestedManyWithoutPostInput
    codeSnippets?: CodeSnippetUncheckedCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsUncheckedCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutParentInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutParentInput, PostUncheckedCreateWithoutParentInput>
  }

  export type PostCreateManyParentInputEnvelope = {
    data: PostCreateManyParentInput | PostCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type MediaAssetCreateWithoutPostInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    provider?: string | null
    title?: string | null
    alt?: string | null
    caption?: string | null
    position?: number | null
    mimeType?: string | null
    sizeBytes?: number | null
    width?: number | null
    height?: number | null
    durationMs?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaAssetUncheckedCreateWithoutPostInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    provider?: string | null
    title?: string | null
    alt?: string | null
    caption?: string | null
    position?: number | null
    mimeType?: string | null
    sizeBytes?: number | null
    width?: number | null
    height?: number | null
    durationMs?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaAssetCreateOrConnectWithoutPostInput = {
    where: MediaAssetWhereUniqueInput
    create: XOR<MediaAssetCreateWithoutPostInput, MediaAssetUncheckedCreateWithoutPostInput>
  }

  export type MediaAssetCreateManyPostInputEnvelope = {
    data: MediaAssetCreateManyPostInput | MediaAssetCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type CodeSnippetCreateWithoutPostInput = {
    id?: string
    title?: string | null
    language: string
    filename?: string | null
    code: string
    highlightedHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeSnippetUncheckedCreateWithoutPostInput = {
    id?: string
    title?: string | null
    language: string
    filename?: string | null
    code: string
    highlightedHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeSnippetCreateOrConnectWithoutPostInput = {
    where: CodeSnippetWhereUniqueInput
    create: XOR<CodeSnippetCreateWithoutPostInput, CodeSnippetUncheckedCreateWithoutPostInput>
  }

  export type CodeSnippetCreateManyPostInputEnvelope = {
    data: CodeSnippetCreateManyPostInput | CodeSnippetCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostsOnTagsCreateWithoutPostInput = {
    assignedAt?: Date | string
    assignedBy?: string | null
    tag: TagCreateNestedOneWithoutPostsInput
  }

  export type PostsOnTagsUncheckedCreateWithoutPostInput = {
    tagId: string
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type PostsOnTagsCreateOrConnectWithoutPostInput = {
    where: PostsOnTagsWhereUniqueInput
    create: XOR<PostsOnTagsCreateWithoutPostInput, PostsOnTagsUncheckedCreateWithoutPostInput>
  }

  export type PostsOnTagsCreateManyPostInputEnvelope = {
    data: PostsOnTagsCreateManyPostInput | PostsOnTagsCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostsOnCategoriesCreateWithoutPostInput = {
    position?: number | null
    assignedAt?: Date | string
    category: CategoryCreateNestedOneWithoutPostsInput
  }

  export type PostsOnCategoriesUncheckedCreateWithoutPostInput = {
    categoryId: string
    position?: number | null
    assignedAt?: Date | string
  }

  export type PostsOnCategoriesCreateOrConnectWithoutPostInput = {
    where: PostsOnCategoriesWhereUniqueInput
    create: XOR<PostsOnCategoriesCreateWithoutPostInput, PostsOnCategoriesUncheckedCreateWithoutPostInput>
  }

  export type PostsOnCategoriesCreateManyPostInputEnvelope = {
    data: PostsOnCategoriesCreateManyPostInput | PostsOnCategoriesCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    status?: $Enums.CommentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutCommentInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    authorId: string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    status?: $Enums.CommentStatus
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type ReactionCreateWithoutPostInput = {
    id?: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReactionInput
  }

  export type ReactionUncheckedCreateWithoutPostInput = {
    id?: string
    userId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type ReactionCreateOrConnectWithoutPostInput = {
    where: ReactionWhereUniqueInput
    create: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput>
  }

  export type ReactionCreateManyPostInputEnvelope = {
    data: ReactionCreateManyPostInput | ReactionCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutProjectInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanCreateNestedManyWithoutProjectInput
    Transaction?: TransactionCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    ownerId: string
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardUncheckedCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationUncheckedCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentUncheckedCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanUncheckedCreateNestedManyWithoutProjectInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPostsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPostsInput, ProjectUncheckedCreateWithoutPostsInput>
  }

  export type UserUpsertWithoutPostInput = {
    update: XOR<UserUpdateWithoutPostInput, UserUncheckedUpdateWithoutPostInput>
    create: XOR<UserCreateWithoutPostInput, UserUncheckedCreateWithoutPostInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostInput, UserUncheckedUpdateWithoutPostInput>
  }

  export type UserUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateManyWithoutUserNestedInput
    adress?: adressUpdateManyWithoutUserNestedInput
    Project?: ProjectUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    adress?: adressUncheckedUpdateManyWithoutUserNestedInput
    Project?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUncheckedUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUncheckedUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUncheckedUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostUpsertWithoutChildrenInput = {
    update: XOR<PostUpdateWithoutChildrenInput, PostUncheckedUpdateWithoutChildrenInput>
    create: XOR<PostCreateWithoutChildrenInput, PostUncheckedCreateWithoutChildrenInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutChildrenInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutChildrenInput, PostUncheckedUpdateWithoutChildrenInput>
  }

  export type PostUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostNestedInput
    parent?: PostUpdateOneWithoutChildrenNestedInput
    attachments?: MediaAssetUpdateManyWithoutPostNestedInput
    codeSnippets?: CodeSnippetUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    project?: ProjectUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: MediaAssetUncheckedUpdateManyWithoutPostNestedInput
    codeSnippets?: CodeSnippetUncheckedUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUncheckedUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUpsertWithWhereUniqueWithoutParentInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutParentInput, PostUncheckedUpdateWithoutParentInput>
    create: XOR<PostCreateWithoutParentInput, PostUncheckedCreateWithoutParentInput>
  }

  export type PostUpdateWithWhereUniqueWithoutParentInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutParentInput, PostUncheckedUpdateWithoutParentInput>
  }

  export type PostUpdateManyWithWhereWithoutParentInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutParentInput>
  }

  export type MediaAssetUpsertWithWhereUniqueWithoutPostInput = {
    where: MediaAssetWhereUniqueInput
    update: XOR<MediaAssetUpdateWithoutPostInput, MediaAssetUncheckedUpdateWithoutPostInput>
    create: XOR<MediaAssetCreateWithoutPostInput, MediaAssetUncheckedCreateWithoutPostInput>
  }

  export type MediaAssetUpdateWithWhereUniqueWithoutPostInput = {
    where: MediaAssetWhereUniqueInput
    data: XOR<MediaAssetUpdateWithoutPostInput, MediaAssetUncheckedUpdateWithoutPostInput>
  }

  export type MediaAssetUpdateManyWithWhereWithoutPostInput = {
    where: MediaAssetScalarWhereInput
    data: XOR<MediaAssetUpdateManyMutationInput, MediaAssetUncheckedUpdateManyWithoutPostInput>
  }

  export type MediaAssetScalarWhereInput = {
    AND?: MediaAssetScalarWhereInput | MediaAssetScalarWhereInput[]
    OR?: MediaAssetScalarWhereInput[]
    NOT?: MediaAssetScalarWhereInput | MediaAssetScalarWhereInput[]
    id?: StringFilter<"MediaAsset"> | string
    postId?: StringFilter<"MediaAsset"> | string
    type?: EnumMediaTypeFilter<"MediaAsset"> | $Enums.MediaType
    url?: StringFilter<"MediaAsset"> | string
    provider?: StringNullableFilter<"MediaAsset"> | string | null
    title?: StringNullableFilter<"MediaAsset"> | string | null
    alt?: StringNullableFilter<"MediaAsset"> | string | null
    caption?: StringNullableFilter<"MediaAsset"> | string | null
    position?: IntNullableFilter<"MediaAsset"> | number | null
    mimeType?: StringNullableFilter<"MediaAsset"> | string | null
    sizeBytes?: IntNullableFilter<"MediaAsset"> | number | null
    width?: IntNullableFilter<"MediaAsset"> | number | null
    height?: IntNullableFilter<"MediaAsset"> | number | null
    durationMs?: IntNullableFilter<"MediaAsset"> | number | null
    meta?: JsonNullableFilter<"MediaAsset">
    createdAt?: DateTimeFilter<"MediaAsset"> | Date | string
    updatedAt?: DateTimeFilter<"MediaAsset"> | Date | string
  }

  export type CodeSnippetUpsertWithWhereUniqueWithoutPostInput = {
    where: CodeSnippetWhereUniqueInput
    update: XOR<CodeSnippetUpdateWithoutPostInput, CodeSnippetUncheckedUpdateWithoutPostInput>
    create: XOR<CodeSnippetCreateWithoutPostInput, CodeSnippetUncheckedCreateWithoutPostInput>
  }

  export type CodeSnippetUpdateWithWhereUniqueWithoutPostInput = {
    where: CodeSnippetWhereUniqueInput
    data: XOR<CodeSnippetUpdateWithoutPostInput, CodeSnippetUncheckedUpdateWithoutPostInput>
  }

  export type CodeSnippetUpdateManyWithWhereWithoutPostInput = {
    where: CodeSnippetScalarWhereInput
    data: XOR<CodeSnippetUpdateManyMutationInput, CodeSnippetUncheckedUpdateManyWithoutPostInput>
  }

  export type CodeSnippetScalarWhereInput = {
    AND?: CodeSnippetScalarWhereInput | CodeSnippetScalarWhereInput[]
    OR?: CodeSnippetScalarWhereInput[]
    NOT?: CodeSnippetScalarWhereInput | CodeSnippetScalarWhereInput[]
    id?: StringFilter<"CodeSnippet"> | string
    postId?: StringFilter<"CodeSnippet"> | string
    title?: StringNullableFilter<"CodeSnippet"> | string | null
    language?: StringFilter<"CodeSnippet"> | string
    filename?: StringNullableFilter<"CodeSnippet"> | string | null
    code?: StringFilter<"CodeSnippet"> | string
    highlightedHtml?: StringNullableFilter<"CodeSnippet"> | string | null
    createdAt?: DateTimeFilter<"CodeSnippet"> | Date | string
    updatedAt?: DateTimeFilter<"CodeSnippet"> | Date | string
  }

  export type PostsOnTagsUpsertWithWhereUniqueWithoutPostInput = {
    where: PostsOnTagsWhereUniqueInput
    update: XOR<PostsOnTagsUpdateWithoutPostInput, PostsOnTagsUncheckedUpdateWithoutPostInput>
    create: XOR<PostsOnTagsCreateWithoutPostInput, PostsOnTagsUncheckedCreateWithoutPostInput>
  }

  export type PostsOnTagsUpdateWithWhereUniqueWithoutPostInput = {
    where: PostsOnTagsWhereUniqueInput
    data: XOR<PostsOnTagsUpdateWithoutPostInput, PostsOnTagsUncheckedUpdateWithoutPostInput>
  }

  export type PostsOnTagsUpdateManyWithWhereWithoutPostInput = {
    where: PostsOnTagsScalarWhereInput
    data: XOR<PostsOnTagsUpdateManyMutationInput, PostsOnTagsUncheckedUpdateManyWithoutPostInput>
  }

  export type PostsOnTagsScalarWhereInput = {
    AND?: PostsOnTagsScalarWhereInput | PostsOnTagsScalarWhereInput[]
    OR?: PostsOnTagsScalarWhereInput[]
    NOT?: PostsOnTagsScalarWhereInput | PostsOnTagsScalarWhereInput[]
    postId?: StringFilter<"PostsOnTags"> | string
    tagId?: StringFilter<"PostsOnTags"> | string
    assignedAt?: DateTimeFilter<"PostsOnTags"> | Date | string
    assignedBy?: StringNullableFilter<"PostsOnTags"> | string | null
  }

  export type PostsOnCategoriesUpsertWithWhereUniqueWithoutPostInput = {
    where: PostsOnCategoriesWhereUniqueInput
    update: XOR<PostsOnCategoriesUpdateWithoutPostInput, PostsOnCategoriesUncheckedUpdateWithoutPostInput>
    create: XOR<PostsOnCategoriesCreateWithoutPostInput, PostsOnCategoriesUncheckedCreateWithoutPostInput>
  }

  export type PostsOnCategoriesUpdateWithWhereUniqueWithoutPostInput = {
    where: PostsOnCategoriesWhereUniqueInput
    data: XOR<PostsOnCategoriesUpdateWithoutPostInput, PostsOnCategoriesUncheckedUpdateWithoutPostInput>
  }

  export type PostsOnCategoriesUpdateManyWithWhereWithoutPostInput = {
    where: PostsOnCategoriesScalarWhereInput
    data: XOR<PostsOnCategoriesUpdateManyMutationInput, PostsOnCategoriesUncheckedUpdateManyWithoutPostInput>
  }

  export type PostsOnCategoriesScalarWhereInput = {
    AND?: PostsOnCategoriesScalarWhereInput | PostsOnCategoriesScalarWhereInput[]
    OR?: PostsOnCategoriesScalarWhereInput[]
    NOT?: PostsOnCategoriesScalarWhereInput | PostsOnCategoriesScalarWhereInput[]
    postId?: StringFilter<"PostsOnCategories"> | string
    categoryId?: StringFilter<"PostsOnCategories"> | string
    position?: IntNullableFilter<"PostsOnCategories"> | number | null
    assignedAt?: DateTimeFilter<"PostsOnCategories"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type ReactionUpsertWithWhereUniqueWithoutPostInput = {
    where: ReactionWhereUniqueInput
    update: XOR<ReactionUpdateWithoutPostInput, ReactionUncheckedUpdateWithoutPostInput>
    create: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput>
  }

  export type ReactionUpdateWithWhereUniqueWithoutPostInput = {
    where: ReactionWhereUniqueInput
    data: XOR<ReactionUpdateWithoutPostInput, ReactionUncheckedUpdateWithoutPostInput>
  }

  export type ReactionUpdateManyWithWhereWithoutPostInput = {
    where: ReactionScalarWhereInput
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyWithoutPostInput>
  }

  export type ProjectUpsertWithoutPostsInput = {
    update: XOR<ProjectUpdateWithoutPostsInput, ProjectUncheckedUpdateWithoutPostsInput>
    create: XOR<ProjectCreateWithoutPostsInput, ProjectUncheckedCreateWithoutPostsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPostsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPostsInput, ProjectUncheckedUpdateWithoutPostsInput>
  }

  export type ProjectUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutProjectNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUncheckedUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUncheckedUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUncheckedUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUncheckedUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type PostCreateWithoutAttachmentsInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostInput
    parent?: PostCreateNestedOneWithoutChildrenInput
    children?: PostCreateNestedManyWithoutParentInput
    codeSnippets?: CodeSnippetCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    project?: ProjectCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    authorId: string
    parentId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PostUncheckedCreateNestedManyWithoutParentInput
    codeSnippets?: CodeSnippetUncheckedCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsUncheckedCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutAttachmentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAttachmentsInput, PostUncheckedCreateWithoutAttachmentsInput>
  }

  export type PostUpsertWithoutAttachmentsInput = {
    update: XOR<PostUpdateWithoutAttachmentsInput, PostUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<PostCreateWithoutAttachmentsInput, PostUncheckedCreateWithoutAttachmentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutAttachmentsInput, PostUncheckedUpdateWithoutAttachmentsInput>
  }

  export type PostUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostNestedInput
    parent?: PostUpdateOneWithoutChildrenNestedInput
    children?: PostUpdateManyWithoutParentNestedInput
    codeSnippets?: CodeSnippetUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    project?: ProjectUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PostUncheckedUpdateManyWithoutParentNestedInput
    codeSnippets?: CodeSnippetUncheckedUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUncheckedUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateWithoutCodeSnippetsInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostInput
    parent?: PostCreateNestedOneWithoutChildrenInput
    children?: PostCreateNestedManyWithoutParentInput
    attachments?: MediaAssetCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    project?: ProjectCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutCodeSnippetsInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    authorId: string
    parentId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PostUncheckedCreateNestedManyWithoutParentInput
    attachments?: MediaAssetUncheckedCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsUncheckedCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCodeSnippetsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCodeSnippetsInput, PostUncheckedCreateWithoutCodeSnippetsInput>
  }

  export type PostUpsertWithoutCodeSnippetsInput = {
    update: XOR<PostUpdateWithoutCodeSnippetsInput, PostUncheckedUpdateWithoutCodeSnippetsInput>
    create: XOR<PostCreateWithoutCodeSnippetsInput, PostUncheckedCreateWithoutCodeSnippetsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCodeSnippetsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCodeSnippetsInput, PostUncheckedUpdateWithoutCodeSnippetsInput>
  }

  export type PostUpdateWithoutCodeSnippetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostNestedInput
    parent?: PostUpdateOneWithoutChildrenNestedInput
    children?: PostUpdateManyWithoutParentNestedInput
    attachments?: MediaAssetUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    project?: ProjectUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutCodeSnippetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PostUncheckedUpdateManyWithoutParentNestedInput
    attachments?: MediaAssetUncheckedUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUncheckedUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostsOnTagsCreateWithoutTagInput = {
    assignedAt?: Date | string
    assignedBy?: string | null
    post: PostCreateNestedOneWithoutTagsInput
  }

  export type PostsOnTagsUncheckedCreateWithoutTagInput = {
    postId: string
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type PostsOnTagsCreateOrConnectWithoutTagInput = {
    where: PostsOnTagsWhereUniqueInput
    create: XOR<PostsOnTagsCreateWithoutTagInput, PostsOnTagsUncheckedCreateWithoutTagInput>
  }

  export type PostsOnTagsCreateManyTagInputEnvelope = {
    data: PostsOnTagsCreateManyTagInput | PostsOnTagsCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type PostsOnTagsUpsertWithWhereUniqueWithoutTagInput = {
    where: PostsOnTagsWhereUniqueInput
    update: XOR<PostsOnTagsUpdateWithoutTagInput, PostsOnTagsUncheckedUpdateWithoutTagInput>
    create: XOR<PostsOnTagsCreateWithoutTagInput, PostsOnTagsUncheckedCreateWithoutTagInput>
  }

  export type PostsOnTagsUpdateWithWhereUniqueWithoutTagInput = {
    where: PostsOnTagsWhereUniqueInput
    data: XOR<PostsOnTagsUpdateWithoutTagInput, PostsOnTagsUncheckedUpdateWithoutTagInput>
  }

  export type PostsOnTagsUpdateManyWithWhereWithoutTagInput = {
    where: PostsOnTagsScalarWhereInput
    data: XOR<PostsOnTagsUpdateManyMutationInput, PostsOnTagsUncheckedUpdateManyWithoutTagInput>
  }

  export type PostCreateWithoutTagsInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostInput
    parent?: PostCreateNestedOneWithoutChildrenInput
    children?: PostCreateNestedManyWithoutParentInput
    attachments?: MediaAssetCreateNestedManyWithoutPostInput
    codeSnippets?: CodeSnippetCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    project?: ProjectCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutTagsInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    authorId: string
    parentId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PostUncheckedCreateNestedManyWithoutParentInput
    attachments?: MediaAssetUncheckedCreateNestedManyWithoutPostInput
    codeSnippets?: CodeSnippetUncheckedCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutTagsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagCreateOrConnectWithoutPostsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
  }

  export type PostUpsertWithoutTagsInput = {
    update: XOR<PostUpdateWithoutTagsInput, PostUncheckedUpdateWithoutTagsInput>
    create: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutTagsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutTagsInput, PostUncheckedUpdateWithoutTagsInput>
  }

  export type PostUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostNestedInput
    parent?: PostUpdateOneWithoutChildrenNestedInput
    children?: PostUpdateManyWithoutParentNestedInput
    attachments?: MediaAssetUpdateManyWithoutPostNestedInput
    codeSnippets?: CodeSnippetUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    project?: ProjectUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PostUncheckedUpdateManyWithoutParentNestedInput
    attachments?: MediaAssetUncheckedUpdateManyWithoutPostNestedInput
    codeSnippets?: CodeSnippetUncheckedUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type TagUpsertWithoutPostsInput = {
    update: XOR<TagUpdateWithoutPostsInput, TagUncheckedUpdateWithoutPostsInput>
    create: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutPostsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutPostsInput, TagUncheckedUpdateWithoutPostsInput>
  }

  export type TagUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    posts?: PostsOnCategoriesCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsOnCategoriesUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutChildrenInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type CategoryCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryCreateNestedManyWithoutParentInput
    posts?: PostsOnCategoriesCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    posts?: PostsOnCategoriesUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryCreateManyParentInputEnvelope = {
    data: CategoryCreateManyParentInput | CategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type PostsOnCategoriesCreateWithoutCategoryInput = {
    position?: number | null
    assignedAt?: Date | string
    post: PostCreateNestedOneWithoutCategoriesInput
  }

  export type PostsOnCategoriesUncheckedCreateWithoutCategoryInput = {
    postId: string
    position?: number | null
    assignedAt?: Date | string
  }

  export type PostsOnCategoriesCreateOrConnectWithoutCategoryInput = {
    where: PostsOnCategoriesWhereUniqueInput
    create: XOR<PostsOnCategoriesCreateWithoutCategoryInput, PostsOnCategoriesUncheckedCreateWithoutCategoryInput>
  }

  export type PostsOnCategoriesCreateManyCategoryInputEnvelope = {
    data: PostsOnCategoriesCreateManyCategoryInput | PostsOnCategoriesCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutChildrenInput = {
    update: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    posts?: PostsOnCategoriesUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsOnCategoriesUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
  }

  export type PostsOnCategoriesUpsertWithWhereUniqueWithoutCategoryInput = {
    where: PostsOnCategoriesWhereUniqueInput
    update: XOR<PostsOnCategoriesUpdateWithoutCategoryInput, PostsOnCategoriesUncheckedUpdateWithoutCategoryInput>
    create: XOR<PostsOnCategoriesCreateWithoutCategoryInput, PostsOnCategoriesUncheckedCreateWithoutCategoryInput>
  }

  export type PostsOnCategoriesUpdateWithWhereUniqueWithoutCategoryInput = {
    where: PostsOnCategoriesWhereUniqueInput
    data: XOR<PostsOnCategoriesUpdateWithoutCategoryInput, PostsOnCategoriesUncheckedUpdateWithoutCategoryInput>
  }

  export type PostsOnCategoriesUpdateManyWithWhereWithoutCategoryInput = {
    where: PostsOnCategoriesScalarWhereInput
    data: XOR<PostsOnCategoriesUpdateManyMutationInput, PostsOnCategoriesUncheckedUpdateManyWithoutCategoryInput>
  }

  export type PostCreateWithoutCategoriesInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostInput
    parent?: PostCreateNestedOneWithoutChildrenInput
    children?: PostCreateNestedManyWithoutParentInput
    attachments?: MediaAssetCreateNestedManyWithoutPostInput
    codeSnippets?: CodeSnippetCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    project?: ProjectCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutCategoriesInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    authorId: string
    parentId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PostUncheckedCreateNestedManyWithoutParentInput
    attachments?: MediaAssetUncheckedCreateNestedManyWithoutPostInput
    codeSnippets?: CodeSnippetUncheckedCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCategoriesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCategoriesInput, PostUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
  }

  export type CategoryUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type CategoryCreateOrConnectWithoutPostsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
  }

  export type PostUpsertWithoutCategoriesInput = {
    update: XOR<PostUpdateWithoutCategoriesInput, PostUncheckedUpdateWithoutCategoriesInput>
    create: XOR<PostCreateWithoutCategoriesInput, PostUncheckedCreateWithoutCategoriesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCategoriesInput, PostUncheckedUpdateWithoutCategoriesInput>
  }

  export type PostUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostNestedInput
    parent?: PostUpdateOneWithoutChildrenNestedInput
    children?: PostUpdateManyWithoutParentNestedInput
    attachments?: MediaAssetUpdateManyWithoutPostNestedInput
    codeSnippets?: CodeSnippetUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    project?: ProjectUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PostUncheckedUpdateManyWithoutParentNestedInput
    attachments?: MediaAssetUncheckedUpdateManyWithoutPostNestedInput
    codeSnippets?: CodeSnippetUncheckedUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CategoryUpsertWithoutPostsInput = {
    update: XOR<CategoryUpdateWithoutPostsInput, CategoryUncheckedUpdateWithoutPostsInput>
    create: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutPostsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutPostsInput, CategoryUncheckedUpdateWithoutPostsInput>
  }

  export type CategoryUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
  }

  export type CategoryUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type PostCreateWithoutCommentsInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostInput
    parent?: PostCreateNestedOneWithoutChildrenInput
    children?: PostCreateNestedManyWithoutParentInput
    attachments?: MediaAssetCreateNestedManyWithoutPostInput
    codeSnippets?: CodeSnippetCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    project?: ProjectCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    authorId: string
    parentId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PostUncheckedCreateNestedManyWithoutParentInput
    attachments?: MediaAssetUncheckedCreateNestedManyWithoutPostInput
    codeSnippets?: CodeSnippetUncheckedCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsUncheckedCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedManyWithoutUserInput
    adress?: adressCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutAuthorInput
    Project?: ProjectCreateNestedManyWithoutOwnerInput
    Circle?: CircleCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionCreateNestedManyWithoutUserInput
    ProjectMember?: ProjectMemberCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeCreateNestedManyWithoutUserInput
    UserXP?: UserXPCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    adress?: adressUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutAuthorInput
    Project?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    Circle?: CircleUncheckedCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutUserInput
    ProjectMember?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanUncheckedCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateUncheckedCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardUncheckedCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    UserXP?: UserXPUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
  }

  export type CommentCreateWithoutChildrenInput = {
    id?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    status?: $Enums.CommentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
  }

  export type CommentUncheckedCreateWithoutChildrenInput = {
    id?: string
    postId: string
    authorId: string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    status?: $Enums.CommentStatus
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutChildrenInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
  }

  export type CommentCreateWithoutParentInput = {
    id?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    status?: $Enums.CommentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentInput
    children?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutParentInput = {
    id?: string
    postId: string
    authorId: string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    status?: $Enums.CommentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutParentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentCreateManyParentInputEnvelope = {
    data: CommentCreateManyParentInput | CommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostNestedInput
    parent?: PostUpdateOneWithoutChildrenNestedInput
    children?: PostUpdateManyWithoutParentNestedInput
    attachments?: MediaAssetUpdateManyWithoutPostNestedInput
    codeSnippets?: CodeSnippetUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    project?: ProjectUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PostUncheckedUpdateManyWithoutParentNestedInput
    attachments?: MediaAssetUncheckedUpdateManyWithoutPostNestedInput
    codeSnippets?: CodeSnippetUncheckedUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUncheckedUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutCommentInput = {
    update: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
  }

  export type UserUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateManyWithoutUserNestedInput
    adress?: adressUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUpdateManyWithoutUserNestedInput
    ProjectMember?: ProjectMemberUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    adress?: adressUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUncheckedUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    ProjectMember?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUncheckedUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUncheckedUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentUpsertWithoutChildrenInput = {
    update: XOR<CommentUpdateWithoutChildrenInput, CommentUncheckedUpdateWithoutChildrenInput>
    create: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutChildrenInput, CommentUncheckedUpdateWithoutChildrenInput>
  }

  export type CommentUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
  }

  export type CommentUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentInput>
  }

  export type PostCreateWithoutReactionsInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostInput
    parent?: PostCreateNestedOneWithoutChildrenInput
    children?: PostCreateNestedManyWithoutParentInput
    attachments?: MediaAssetCreateNestedManyWithoutPostInput
    codeSnippets?: CodeSnippetCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    project?: ProjectCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutReactionsInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    authorId: string
    parentId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PostUncheckedCreateNestedManyWithoutParentInput
    attachments?: MediaAssetUncheckedCreateNestedManyWithoutPostInput
    codeSnippets?: CodeSnippetUncheckedCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsUncheckedCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutReactionsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
  }

  export type UserCreateWithoutReactionInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedManyWithoutUserInput
    adress?: adressCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutAuthorInput
    Project?: ProjectCreateNestedManyWithoutOwnerInput
    Circle?: CircleCreateNestedManyWithoutCreatorInput
    Comment?: CommentCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeCreateNestedManyWithoutUserInput
    UserXP?: UserXPCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReactionInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    adress?: adressUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutAuthorInput
    Project?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    Circle?: CircleUncheckedCreateNestedManyWithoutCreatorInput
    Comment?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanUncheckedCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateUncheckedCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardUncheckedCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    UserXP?: UserXPUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReactionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReactionInput, UserUncheckedCreateWithoutReactionInput>
  }

  export type PostUpsertWithoutReactionsInput = {
    update: XOR<PostUpdateWithoutReactionsInput, PostUncheckedUpdateWithoutReactionsInput>
    create: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutReactionsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutReactionsInput, PostUncheckedUpdateWithoutReactionsInput>
  }

  export type PostUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostNestedInput
    parent?: PostUpdateOneWithoutChildrenNestedInput
    children?: PostUpdateManyWithoutParentNestedInput
    attachments?: MediaAssetUpdateManyWithoutPostNestedInput
    codeSnippets?: CodeSnippetUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    project?: ProjectUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PostUncheckedUpdateManyWithoutParentNestedInput
    attachments?: MediaAssetUncheckedUpdateManyWithoutPostNestedInput
    codeSnippets?: CodeSnippetUncheckedUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUncheckedUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutReactionInput = {
    update: XOR<UserUpdateWithoutReactionInput, UserUncheckedUpdateWithoutReactionInput>
    create: XOR<UserCreateWithoutReactionInput, UserUncheckedCreateWithoutReactionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReactionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReactionInput, UserUncheckedUpdateWithoutReactionInput>
  }

  export type UserUpdateWithoutReactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateManyWithoutUserNestedInput
    adress?: adressUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUpdateManyWithoutCreatorNestedInput
    Comment?: CommentUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    adress?: adressUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUncheckedUpdateManyWithoutCreatorNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUncheckedUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUncheckedUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProjectInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedManyWithoutUserInput
    adress?: adressCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutAuthorInput
    Circle?: CircleCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeCreateNestedManyWithoutUserInput
    UserXP?: UserXPCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    adress?: adressUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutAuthorInput
    Circle?: CircleUncheckedCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanUncheckedCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateUncheckedCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardUncheckedCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    UserXP?: UserXPUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectInput, UserUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberCreateWithoutProjectInput = {
    id?: string
    role: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectMemberInput
  }

  export type ProjectMemberUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
  }

  export type ProjectMemberCreateOrConnectWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberCreateManyProjectInputEnvelope = {
    data: ProjectMemberCreateManyProjectInput | ProjectMemberCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutProjectInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostInput
    parent?: PostCreateNestedOneWithoutChildrenInput
    children?: PostCreateNestedManyWithoutParentInput
    attachments?: MediaAssetCreateNestedManyWithoutPostInput
    codeSnippets?: CodeSnippetCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutProjectInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    authorId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PostUncheckedCreateNestedManyWithoutParentInput
    attachments?: MediaAssetUncheckedCreateNestedManyWithoutPostInput
    codeSnippets?: CodeSnippetUncheckedCreateNestedManyWithoutPostInput
    tags?: PostsOnTagsUncheckedCreateNestedManyWithoutPostInput
    categories?: PostsOnCategoriesUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutProjectInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutProjectInput, PostUncheckedCreateWithoutProjectInput>
  }

  export type PostCreateManyProjectInputEnvelope = {
    data: PostCreateManyProjectInput | PostCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpdateCreateWithoutProjectInput = {
    id?: string
    title: string
    content: string
    images?: ProjectUpdateCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    User?: UserCreateNestedManyWithoutProjectUpdateInput
  }

  export type ProjectUpdateUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    content: string
    images?: ProjectUpdateCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    User?: UserUncheckedCreateNestedManyWithoutProjectUpdateInput
  }

  export type ProjectUpdateCreateOrConnectWithoutProjectInput = {
    where: ProjectUpdateWhereUniqueInput
    create: XOR<ProjectUpdateCreateWithoutProjectInput, ProjectUpdateUncheckedCreateWithoutProjectInput>
  }

  export type ProjectUpdateCreateManyProjectInputEnvelope = {
    data: ProjectUpdateCreateManyProjectInput | ProjectUpdateCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectRewardCreateWithoutProjectInput = {
    id?: string
    amount: number
    title: string
    description: string
    image?: string | null
    deliveryDate?: Date | string | null
    quantity?: number | null
    claimed?: number
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutRewardInput
    User?: UserCreateNestedManyWithoutProjectRewardInput
  }

  export type ProjectRewardUncheckedCreateWithoutProjectInput = {
    id?: string
    amount: number
    title: string
    description: string
    image?: string | null
    deliveryDate?: Date | string | null
    quantity?: number | null
    claimed?: number
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutRewardInput
    User?: UserUncheckedCreateNestedManyWithoutProjectRewardInput
  }

  export type ProjectRewardCreateOrConnectWithoutProjectInput = {
    where: ProjectRewardWhereUniqueInput
    create: XOR<ProjectRewardCreateWithoutProjectInput, ProjectRewardUncheckedCreateWithoutProjectInput>
  }

  export type ProjectRewardCreateManyProjectInputEnvelope = {
    data: ProjectRewardCreateManyProjectInput | ProjectRewardCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectDonationCreateWithoutProjectInput = {
    id?: string
    amount: number
    isAnonymous?: boolean
    message?: string | null
    status?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutProjectDonationInput
    reward?: ProjectRewardCreateNestedOneWithoutProjectDonationInput
  }

  export type ProjectDonationUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    amount: number
    isAnonymous?: boolean
    message?: string | null
    rewardId?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type ProjectDonationCreateOrConnectWithoutProjectInput = {
    where: ProjectDonationWhereUniqueInput
    create: XOR<ProjectDonationCreateWithoutProjectInput, ProjectDonationUncheckedCreateWithoutProjectInput>
  }

  export type ProjectDonationCreateManyProjectInputEnvelope = {
    data: ProjectDonationCreateManyProjectInput | ProjectDonationCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectInvestmentCreateWithoutProjectInput = {
    id?: string
    amount: number
    shares?: number | null
    status?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutProjectInvestmentInput
  }

  export type ProjectInvestmentUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    amount: number
    shares?: number | null
    status?: string
    createdAt?: Date | string
  }

  export type ProjectInvestmentCreateOrConnectWithoutProjectInput = {
    where: ProjectInvestmentWhereUniqueInput
    create: XOR<ProjectInvestmentCreateWithoutProjectInput, ProjectInvestmentUncheckedCreateWithoutProjectInput>
  }

  export type ProjectInvestmentCreateManyProjectInputEnvelope = {
    data: ProjectInvestmentCreateManyProjectInput | ProjectInvestmentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectLoanCreateWithoutProjectInput = {
    id?: string
    amount: number
    status?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutProjectLoanInput
  }

  export type ProjectLoanUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    amount: number
    status?: string
    createdAt?: Date | string
  }

  export type ProjectLoanCreateOrConnectWithoutProjectInput = {
    where: ProjectLoanWhereUniqueInput
    create: XOR<ProjectLoanCreateWithoutProjectInput, ProjectLoanUncheckedCreateWithoutProjectInput>
  }

  export type ProjectLoanCreateManyProjectInputEnvelope = {
    data: ProjectLoanCreateManyProjectInput | ProjectLoanCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutProjectInput = {
    id?: string
    type: string
    amount: number
    currency?: string
    status?: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionInput
    circle?: CircleCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    type: string
    amount: number
    currency?: string
    status?: string
    description?: string | null
    circleId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutProjectInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutProjectInput, TransactionUncheckedCreateWithoutProjectInput>
  }

  export type TransactionCreateManyProjectInputEnvelope = {
    data: TransactionCreateManyProjectInput | TransactionCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type CircleProjectCreateWithoutProjectInput = {
    id?: string
    allocatedAmount?: number
    supportType: string
    votedAt?: Date | string | null
    status?: string
    circle: CircleCreateNestedOneWithoutProjectsInput
  }

  export type CircleProjectUncheckedCreateWithoutProjectInput = {
    id?: string
    circleId: string
    allocatedAmount?: number
    supportType: string
    votedAt?: Date | string | null
    status?: string
  }

  export type CircleProjectCreateOrConnectWithoutProjectInput = {
    where: CircleProjectWhereUniqueInput
    create: XOR<CircleProjectCreateWithoutProjectInput, CircleProjectUncheckedCreateWithoutProjectInput>
  }

  export type CircleProjectCreateManyProjectInputEnvelope = {
    data: CircleProjectCreateManyProjectInput | CircleProjectCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProjectInput = {
    update: XOR<UserUpdateWithoutProjectInput, UserUncheckedUpdateWithoutProjectInput>
    create: XOR<UserCreateWithoutProjectInput, UserUncheckedCreateWithoutProjectInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectInput, UserUncheckedUpdateWithoutProjectInput>
  }

  export type UserUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateManyWithoutUserNestedInput
    adress?: adressUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutAuthorNestedInput
    Circle?: CircleUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    adress?: adressUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    Circle?: CircleUncheckedUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUncheckedUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUncheckedUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type PostUpsertWithWhereUniqueWithoutProjectInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutProjectInput, PostUncheckedUpdateWithoutProjectInput>
    create: XOR<PostCreateWithoutProjectInput, PostUncheckedCreateWithoutProjectInput>
  }

  export type PostUpdateWithWhereUniqueWithoutProjectInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutProjectInput, PostUncheckedUpdateWithoutProjectInput>
  }

  export type PostUpdateManyWithWhereWithoutProjectInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectUpdateUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectUpdateWhereUniqueInput
    update: XOR<ProjectUpdateUpdateWithoutProjectInput, ProjectUpdateUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectUpdateCreateWithoutProjectInput, ProjectUpdateUncheckedCreateWithoutProjectInput>
  }

  export type ProjectUpdateUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectUpdateWhereUniqueInput
    data: XOR<ProjectUpdateUpdateWithoutProjectInput, ProjectUpdateUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectUpdateUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectUpdateScalarWhereInput
    data: XOR<ProjectUpdateUpdateManyMutationInput, ProjectUpdateUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectRewardUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectRewardWhereUniqueInput
    update: XOR<ProjectRewardUpdateWithoutProjectInput, ProjectRewardUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectRewardCreateWithoutProjectInput, ProjectRewardUncheckedCreateWithoutProjectInput>
  }

  export type ProjectRewardUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectRewardWhereUniqueInput
    data: XOR<ProjectRewardUpdateWithoutProjectInput, ProjectRewardUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectRewardUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectRewardScalarWhereInput
    data: XOR<ProjectRewardUpdateManyMutationInput, ProjectRewardUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectDonationUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectDonationWhereUniqueInput
    update: XOR<ProjectDonationUpdateWithoutProjectInput, ProjectDonationUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectDonationCreateWithoutProjectInput, ProjectDonationUncheckedCreateWithoutProjectInput>
  }

  export type ProjectDonationUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectDonationWhereUniqueInput
    data: XOR<ProjectDonationUpdateWithoutProjectInput, ProjectDonationUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectDonationUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectDonationScalarWhereInput
    data: XOR<ProjectDonationUpdateManyMutationInput, ProjectDonationUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectInvestmentUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectInvestmentWhereUniqueInput
    update: XOR<ProjectInvestmentUpdateWithoutProjectInput, ProjectInvestmentUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectInvestmentCreateWithoutProjectInput, ProjectInvestmentUncheckedCreateWithoutProjectInput>
  }

  export type ProjectInvestmentUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectInvestmentWhereUniqueInput
    data: XOR<ProjectInvestmentUpdateWithoutProjectInput, ProjectInvestmentUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectInvestmentUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectInvestmentScalarWhereInput
    data: XOR<ProjectInvestmentUpdateManyMutationInput, ProjectInvestmentUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectLoanUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectLoanWhereUniqueInput
    update: XOR<ProjectLoanUpdateWithoutProjectInput, ProjectLoanUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectLoanCreateWithoutProjectInput, ProjectLoanUncheckedCreateWithoutProjectInput>
  }

  export type ProjectLoanUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectLoanWhereUniqueInput
    data: XOR<ProjectLoanUpdateWithoutProjectInput, ProjectLoanUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectLoanUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectLoanScalarWhereInput
    data: XOR<ProjectLoanUpdateManyMutationInput, ProjectLoanUncheckedUpdateManyWithoutProjectInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutProjectInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutProjectInput, TransactionUncheckedUpdateWithoutProjectInput>
    create: XOR<TransactionCreateWithoutProjectInput, TransactionUncheckedCreateWithoutProjectInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutProjectInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutProjectInput, TransactionUncheckedUpdateWithoutProjectInput>
  }

  export type TransactionUpdateManyWithWhereWithoutProjectInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutProjectInput>
  }

  export type CircleProjectUpsertWithWhereUniqueWithoutProjectInput = {
    where: CircleProjectWhereUniqueInput
    update: XOR<CircleProjectUpdateWithoutProjectInput, CircleProjectUncheckedUpdateWithoutProjectInput>
    create: XOR<CircleProjectCreateWithoutProjectInput, CircleProjectUncheckedCreateWithoutProjectInput>
  }

  export type CircleProjectUpdateWithWhereUniqueWithoutProjectInput = {
    where: CircleProjectWhereUniqueInput
    data: XOR<CircleProjectUpdateWithoutProjectInput, CircleProjectUncheckedUpdateWithoutProjectInput>
  }

  export type CircleProjectUpdateManyWithWhereWithoutProjectInput = {
    where: CircleProjectScalarWhereInput
    data: XOR<CircleProjectUpdateManyMutationInput, CircleProjectUncheckedUpdateManyWithoutProjectInput>
  }

  export type CircleProjectScalarWhereInput = {
    AND?: CircleProjectScalarWhereInput | CircleProjectScalarWhereInput[]
    OR?: CircleProjectScalarWhereInput[]
    NOT?: CircleProjectScalarWhereInput | CircleProjectScalarWhereInput[]
    id?: StringFilter<"CircleProject"> | string
    circleId?: StringFilter<"CircleProject"> | string
    projectId?: StringFilter<"CircleProject"> | string
    allocatedAmount?: FloatFilter<"CircleProject"> | number
    supportType?: StringFilter<"CircleProject"> | string
    votedAt?: DateTimeNullableFilter<"CircleProject"> | Date | string | null
    status?: StringFilter<"CircleProject"> | string
  }

  export type ProjectCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutProjectInput
    posts?: PostCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanCreateNestedManyWithoutProjectInput
    Transaction?: TransactionCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    ownerId: string
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardUncheckedCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationUncheckedCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentUncheckedCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanUncheckedCreateNestedManyWithoutProjectInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutProjectMemberInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedManyWithoutUserInput
    adress?: adressCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutAuthorInput
    Project?: ProjectCreateNestedManyWithoutOwnerInput
    Circle?: CircleCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutAuthorInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeCreateNestedManyWithoutUserInput
    UserXP?: UserXPCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectMemberInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    adress?: adressUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutAuthorInput
    Project?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    Circle?: CircleUncheckedCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanUncheckedCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateUncheckedCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardUncheckedCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    UserXP?: UserXPUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectMemberInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectMemberInput, UserUncheckedCreateWithoutProjectMemberInput>
  }

  export type ProjectUpsertWithoutMembersInput = {
    update: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMembersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type ProjectUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutProjectNestedInput
    posts?: PostUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUncheckedUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUncheckedUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUncheckedUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUncheckedUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectMemberInput = {
    update: XOR<UserUpdateWithoutProjectMemberInput, UserUncheckedUpdateWithoutProjectMemberInput>
    create: XOR<UserCreateWithoutProjectMemberInput, UserUncheckedCreateWithoutProjectMemberInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectMemberInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectMemberInput, UserUncheckedUpdateWithoutProjectMemberInput>
  }

  export type UserUpdateWithoutProjectMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateManyWithoutUserNestedInput
    adress?: adressUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutAuthorNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    adress?: adressUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUncheckedUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUncheckedUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUncheckedUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutUpdatesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutProjectInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    posts?: PostCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanCreateNestedManyWithoutProjectInput
    Transaction?: TransactionCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutUpdatesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    ownerId: string
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    posts?: PostUncheckedCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardUncheckedCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationUncheckedCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentUncheckedCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanUncheckedCreateNestedManyWithoutProjectInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutUpdatesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUpdatesInput, ProjectUncheckedCreateWithoutUpdatesInput>
  }

  export type UserCreateWithoutProjectUpdateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedManyWithoutUserInput
    adress?: adressCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutAuthorInput
    Project?: ProjectCreateNestedManyWithoutOwnerInput
    Circle?: CircleCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeCreateNestedManyWithoutUserInput
    UserXP?: UserXPCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectUpdateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    adress?: adressUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutAuthorInput
    Project?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    Circle?: CircleUncheckedCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanUncheckedCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardUncheckedCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    UserXP?: UserXPUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectUpdateInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectUpdateInput, UserUncheckedCreateWithoutProjectUpdateInput>
  }

  export type ProjectUpsertWithoutUpdatesInput = {
    update: XOR<ProjectUpdateWithoutUpdatesInput, ProjectUncheckedUpdateWithoutUpdatesInput>
    create: XOR<ProjectCreateWithoutUpdatesInput, ProjectUncheckedCreateWithoutUpdatesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutUpdatesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutUpdatesInput, ProjectUncheckedUpdateWithoutUpdatesInput>
  }

  export type ProjectUpdateWithoutUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutProjectNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    posts?: PostUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    posts?: PostUncheckedUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUncheckedUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUncheckedUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUncheckedUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUncheckedUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutProjectUpdateInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutProjectUpdateInput, UserUncheckedUpdateWithoutProjectUpdateInput>
    create: XOR<UserCreateWithoutProjectUpdateInput, UserUncheckedCreateWithoutProjectUpdateInput>
  }

  export type UserUpdateWithWhereUniqueWithoutProjectUpdateInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutProjectUpdateInput, UserUncheckedUpdateWithoutProjectUpdateInput>
  }

  export type UserUpdateManyWithWhereWithoutProjectUpdateInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutProjectUpdateInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    roles?: EnumRoleNullableListFilter<"User">
  }

  export type ProjectCreateWithoutRewardsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutProjectInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    posts?: PostCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanCreateNestedManyWithoutProjectInput
    Transaction?: TransactionCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutRewardsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    ownerId: string
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    posts?: PostUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationUncheckedCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentUncheckedCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanUncheckedCreateNestedManyWithoutProjectInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutRewardsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutRewardsInput, ProjectUncheckedCreateWithoutRewardsInput>
  }

  export type ProjectDonationCreateWithoutRewardInput = {
    id?: string
    amount: number
    isAnonymous?: boolean
    message?: string | null
    status?: string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutDonationsInput
    user: UserCreateNestedOneWithoutProjectDonationInput
  }

  export type ProjectDonationUncheckedCreateWithoutRewardInput = {
    id?: string
    projectId: string
    userId: string
    amount: number
    isAnonymous?: boolean
    message?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type ProjectDonationCreateOrConnectWithoutRewardInput = {
    where: ProjectDonationWhereUniqueInput
    create: XOR<ProjectDonationCreateWithoutRewardInput, ProjectDonationUncheckedCreateWithoutRewardInput>
  }

  export type ProjectDonationCreateManyRewardInputEnvelope = {
    data: ProjectDonationCreateManyRewardInput | ProjectDonationCreateManyRewardInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutProjectRewardInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedManyWithoutUserInput
    adress?: adressCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutAuthorInput
    Project?: ProjectCreateNestedManyWithoutOwnerInput
    Circle?: CircleCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeCreateNestedManyWithoutUserInput
    UserXP?: UserXPCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectRewardInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    adress?: adressUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutAuthorInput
    Project?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    Circle?: CircleUncheckedCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanUncheckedCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateUncheckedCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    UserXP?: UserXPUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectRewardInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectRewardInput, UserUncheckedCreateWithoutProjectRewardInput>
  }

  export type ProjectUpsertWithoutRewardsInput = {
    update: XOR<ProjectUpdateWithoutRewardsInput, ProjectUncheckedUpdateWithoutRewardsInput>
    create: XOR<ProjectCreateWithoutRewardsInput, ProjectUncheckedCreateWithoutRewardsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutRewardsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutRewardsInput, ProjectUncheckedUpdateWithoutRewardsInput>
  }

  export type ProjectUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutProjectNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    posts?: PostUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    posts?: PostUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUncheckedUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUncheckedUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUncheckedUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectDonationUpsertWithWhereUniqueWithoutRewardInput = {
    where: ProjectDonationWhereUniqueInput
    update: XOR<ProjectDonationUpdateWithoutRewardInput, ProjectDonationUncheckedUpdateWithoutRewardInput>
    create: XOR<ProjectDonationCreateWithoutRewardInput, ProjectDonationUncheckedCreateWithoutRewardInput>
  }

  export type ProjectDonationUpdateWithWhereUniqueWithoutRewardInput = {
    where: ProjectDonationWhereUniqueInput
    data: XOR<ProjectDonationUpdateWithoutRewardInput, ProjectDonationUncheckedUpdateWithoutRewardInput>
  }

  export type ProjectDonationUpdateManyWithWhereWithoutRewardInput = {
    where: ProjectDonationScalarWhereInput
    data: XOR<ProjectDonationUpdateManyMutationInput, ProjectDonationUncheckedUpdateManyWithoutRewardInput>
  }

  export type UserUpsertWithWhereUniqueWithoutProjectRewardInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutProjectRewardInput, UserUncheckedUpdateWithoutProjectRewardInput>
    create: XOR<UserCreateWithoutProjectRewardInput, UserUncheckedCreateWithoutProjectRewardInput>
  }

  export type UserUpdateWithWhereUniqueWithoutProjectRewardInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutProjectRewardInput, UserUncheckedUpdateWithoutProjectRewardInput>
  }

  export type UserUpdateManyWithWhereWithoutProjectRewardInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutProjectRewardInput>
  }

  export type ProjectCreateWithoutDonationsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutProjectInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    posts?: PostCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanCreateNestedManyWithoutProjectInput
    Transaction?: TransactionCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutDonationsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    ownerId: string
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    posts?: PostUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardUncheckedCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentUncheckedCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanUncheckedCreateNestedManyWithoutProjectInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDonationsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDonationsInput, ProjectUncheckedCreateWithoutDonationsInput>
  }

  export type UserCreateWithoutProjectDonationInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedManyWithoutUserInput
    adress?: adressCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutAuthorInput
    Project?: ProjectCreateNestedManyWithoutOwnerInput
    Circle?: CircleCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeCreateNestedManyWithoutUserInput
    UserXP?: UserXPCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectDonationInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    adress?: adressUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutAuthorInput
    Project?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    Circle?: CircleUncheckedCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanUncheckedCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateUncheckedCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardUncheckedCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    UserXP?: UserXPUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectDonationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectDonationInput, UserUncheckedCreateWithoutProjectDonationInput>
  }

  export type ProjectRewardCreateWithoutProjectDonationInput = {
    id?: string
    amount: number
    title: string
    description: string
    image?: string | null
    deliveryDate?: Date | string | null
    quantity?: number | null
    claimed?: number
    project: ProjectCreateNestedOneWithoutRewardsInput
    User?: UserCreateNestedManyWithoutProjectRewardInput
  }

  export type ProjectRewardUncheckedCreateWithoutProjectDonationInput = {
    id?: string
    projectId: string
    amount: number
    title: string
    description: string
    image?: string | null
    deliveryDate?: Date | string | null
    quantity?: number | null
    claimed?: number
    User?: UserUncheckedCreateNestedManyWithoutProjectRewardInput
  }

  export type ProjectRewardCreateOrConnectWithoutProjectDonationInput = {
    where: ProjectRewardWhereUniqueInput
    create: XOR<ProjectRewardCreateWithoutProjectDonationInput, ProjectRewardUncheckedCreateWithoutProjectDonationInput>
  }

  export type ProjectUpsertWithoutDonationsInput = {
    update: XOR<ProjectUpdateWithoutDonationsInput, ProjectUncheckedUpdateWithoutDonationsInput>
    create: XOR<ProjectCreateWithoutDonationsInput, ProjectUncheckedCreateWithoutDonationsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDonationsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDonationsInput, ProjectUncheckedUpdateWithoutDonationsInput>
  }

  export type ProjectUpdateWithoutDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutProjectNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    posts?: PostUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    posts?: PostUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUncheckedUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUncheckedUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUncheckedUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectDonationInput = {
    update: XOR<UserUpdateWithoutProjectDonationInput, UserUncheckedUpdateWithoutProjectDonationInput>
    create: XOR<UserCreateWithoutProjectDonationInput, UserUncheckedCreateWithoutProjectDonationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectDonationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectDonationInput, UserUncheckedUpdateWithoutProjectDonationInput>
  }

  export type UserUpdateWithoutProjectDonationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateManyWithoutUserNestedInput
    adress?: adressUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectDonationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    adress?: adressUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUncheckedUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUncheckedUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUncheckedUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectRewardUpsertWithoutProjectDonationInput = {
    update: XOR<ProjectRewardUpdateWithoutProjectDonationInput, ProjectRewardUncheckedUpdateWithoutProjectDonationInput>
    create: XOR<ProjectRewardCreateWithoutProjectDonationInput, ProjectRewardUncheckedCreateWithoutProjectDonationInput>
    where?: ProjectRewardWhereInput
  }

  export type ProjectRewardUpdateToOneWithWhereWithoutProjectDonationInput = {
    where?: ProjectRewardWhereInput
    data: XOR<ProjectRewardUpdateWithoutProjectDonationInput, ProjectRewardUncheckedUpdateWithoutProjectDonationInput>
  }

  export type ProjectRewardUpdateWithoutProjectDonationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    claimed?: IntFieldUpdateOperationsInput | number
    project?: ProjectUpdateOneRequiredWithoutRewardsNestedInput
    User?: UserUpdateManyWithoutProjectRewardNestedInput
  }

  export type ProjectRewardUncheckedUpdateWithoutProjectDonationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    claimed?: IntFieldUpdateOperationsInput | number
    User?: UserUncheckedUpdateManyWithoutProjectRewardNestedInput
  }

  export type ProjectCreateWithoutInvestmentsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutProjectInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    posts?: PostCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanCreateNestedManyWithoutProjectInput
    Transaction?: TransactionCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutInvestmentsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    ownerId: string
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    posts?: PostUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardUncheckedCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationUncheckedCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanUncheckedCreateNestedManyWithoutProjectInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutInvestmentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutInvestmentsInput, ProjectUncheckedCreateWithoutInvestmentsInput>
  }

  export type UserCreateWithoutProjectInvestmentInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedManyWithoutUserInput
    adress?: adressCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutAuthorInput
    Project?: ProjectCreateNestedManyWithoutOwnerInput
    Circle?: CircleCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeCreateNestedManyWithoutUserInput
    UserXP?: UserXPCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectInvestmentInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    adress?: adressUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutAuthorInput
    Project?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    Circle?: CircleUncheckedCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanUncheckedCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateUncheckedCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardUncheckedCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    UserXP?: UserXPUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectInvestmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectInvestmentInput, UserUncheckedCreateWithoutProjectInvestmentInput>
  }

  export type ProjectUpsertWithoutInvestmentsInput = {
    update: XOR<ProjectUpdateWithoutInvestmentsInput, ProjectUncheckedUpdateWithoutInvestmentsInput>
    create: XOR<ProjectCreateWithoutInvestmentsInput, ProjectUncheckedCreateWithoutInvestmentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutInvestmentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutInvestmentsInput, ProjectUncheckedUpdateWithoutInvestmentsInput>
  }

  export type ProjectUpdateWithoutInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutProjectNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    posts?: PostUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    posts?: PostUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUncheckedUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUncheckedUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUncheckedUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectInvestmentInput = {
    update: XOR<UserUpdateWithoutProjectInvestmentInput, UserUncheckedUpdateWithoutProjectInvestmentInput>
    create: XOR<UserCreateWithoutProjectInvestmentInput, UserUncheckedCreateWithoutProjectInvestmentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectInvestmentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectInvestmentInput, UserUncheckedUpdateWithoutProjectInvestmentInput>
  }

  export type UserUpdateWithoutProjectInvestmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateManyWithoutUserNestedInput
    adress?: adressUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectInvestmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    adress?: adressUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUncheckedUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUncheckedUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUncheckedUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutLoansInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutProjectInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    posts?: PostCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentCreateNestedManyWithoutProjectInput
    Transaction?: TransactionCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutLoansInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    ownerId: string
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    posts?: PostUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardUncheckedCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationUncheckedCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentUncheckedCreateNestedManyWithoutProjectInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutLoansInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutLoansInput, ProjectUncheckedCreateWithoutLoansInput>
  }

  export type UserCreateWithoutProjectLoanInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedManyWithoutUserInput
    adress?: adressCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutAuthorInput
    Project?: ProjectCreateNestedManyWithoutOwnerInput
    Circle?: CircleCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeCreateNestedManyWithoutUserInput
    UserXP?: UserXPCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectLoanInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    adress?: adressUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutAuthorInput
    Project?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    Circle?: CircleUncheckedCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateUncheckedCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardUncheckedCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    UserXP?: UserXPUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectLoanInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectLoanInput, UserUncheckedCreateWithoutProjectLoanInput>
  }

  export type ProjectUpsertWithoutLoansInput = {
    update: XOR<ProjectUpdateWithoutLoansInput, ProjectUncheckedUpdateWithoutLoansInput>
    create: XOR<ProjectCreateWithoutLoansInput, ProjectUncheckedCreateWithoutLoansInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutLoansInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutLoansInput, ProjectUncheckedUpdateWithoutLoansInput>
  }

  export type ProjectUpdateWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutProjectNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    posts?: PostUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutLoansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    posts?: PostUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUncheckedUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUncheckedUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUncheckedUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectLoanInput = {
    update: XOR<UserUpdateWithoutProjectLoanInput, UserUncheckedUpdateWithoutProjectLoanInput>
    create: XOR<UserCreateWithoutProjectLoanInput, UserUncheckedCreateWithoutProjectLoanInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectLoanInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectLoanInput, UserUncheckedUpdateWithoutProjectLoanInput>
  }

  export type UserUpdateWithoutProjectLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateManyWithoutUserNestedInput
    adress?: adressUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectLoanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    adress?: adressUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUncheckedUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUncheckedUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCircleInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedManyWithoutUserInput
    adress?: adressCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutAuthorInput
    Project?: ProjectCreateNestedManyWithoutOwnerInput
    Reaction?: ReactionCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeCreateNestedManyWithoutUserInput
    UserXP?: UserXPCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCircleInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    adress?: adressUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutAuthorInput
    Project?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanUncheckedCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateUncheckedCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardUncheckedCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    UserXP?: UserXPUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCircleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCircleInput, UserUncheckedCreateWithoutCircleInput>
  }

  export type CircleMemberCreateWithoutCircleInput = {
    id?: string
    role: $Enums.CircleMemberRole
    joinedAt?: Date | string
    xp?: number
    level?: number
    user: UserCreateNestedOneWithoutCircleMemberInput
  }

  export type CircleMemberUncheckedCreateWithoutCircleInput = {
    id?: string
    userId: string
    role: $Enums.CircleMemberRole
    joinedAt?: Date | string
    xp?: number
    level?: number
  }

  export type CircleMemberCreateOrConnectWithoutCircleInput = {
    where: CircleMemberWhereUniqueInput
    create: XOR<CircleMemberCreateWithoutCircleInput, CircleMemberUncheckedCreateWithoutCircleInput>
  }

  export type CircleMemberCreateManyCircleInputEnvelope = {
    data: CircleMemberCreateManyCircleInput | CircleMemberCreateManyCircleInput[]
    skipDuplicates?: boolean
  }

  export type CircleProjectCreateWithoutCircleInput = {
    id?: string
    allocatedAmount?: number
    supportType: string
    votedAt?: Date | string | null
    status?: string
    project: ProjectCreateNestedOneWithoutCircleProjectInput
  }

  export type CircleProjectUncheckedCreateWithoutCircleInput = {
    id?: string
    projectId: string
    allocatedAmount?: number
    supportType: string
    votedAt?: Date | string | null
    status?: string
  }

  export type CircleProjectCreateOrConnectWithoutCircleInput = {
    where: CircleProjectWhereUniqueInput
    create: XOR<CircleProjectCreateWithoutCircleInput, CircleProjectUncheckedCreateWithoutCircleInput>
  }

  export type CircleProjectCreateManyCircleInputEnvelope = {
    data: CircleProjectCreateManyCircleInput | CircleProjectCreateManyCircleInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutCircleInput = {
    id?: string
    type: string
    amount: number
    currency?: string
    status?: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionInput
    project?: ProjectCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCircleInput = {
    id?: string
    userId: string
    type: string
    amount: number
    currency?: string
    status?: string
    description?: string | null
    projectId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutCircleInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCircleInput, TransactionUncheckedCreateWithoutCircleInput>
  }

  export type TransactionCreateManyCircleInputEnvelope = {
    data: TransactionCreateManyCircleInput | TransactionCreateManyCircleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCircleInput = {
    update: XOR<UserUpdateWithoutCircleInput, UserUncheckedUpdateWithoutCircleInput>
    create: XOR<UserCreateWithoutCircleInput, UserUncheckedCreateWithoutCircleInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCircleInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCircleInput, UserUncheckedUpdateWithoutCircleInput>
  }

  export type UserUpdateWithoutCircleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateManyWithoutUserNestedInput
    adress?: adressUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUpdateManyWithoutOwnerNestedInput
    Reaction?: ReactionUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCircleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    adress?: adressUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUncheckedUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUncheckedUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CircleMemberUpsertWithWhereUniqueWithoutCircleInput = {
    where: CircleMemberWhereUniqueInput
    update: XOR<CircleMemberUpdateWithoutCircleInput, CircleMemberUncheckedUpdateWithoutCircleInput>
    create: XOR<CircleMemberCreateWithoutCircleInput, CircleMemberUncheckedCreateWithoutCircleInput>
  }

  export type CircleMemberUpdateWithWhereUniqueWithoutCircleInput = {
    where: CircleMemberWhereUniqueInput
    data: XOR<CircleMemberUpdateWithoutCircleInput, CircleMemberUncheckedUpdateWithoutCircleInput>
  }

  export type CircleMemberUpdateManyWithWhereWithoutCircleInput = {
    where: CircleMemberScalarWhereInput
    data: XOR<CircleMemberUpdateManyMutationInput, CircleMemberUncheckedUpdateManyWithoutCircleInput>
  }

  export type CircleProjectUpsertWithWhereUniqueWithoutCircleInput = {
    where: CircleProjectWhereUniqueInput
    update: XOR<CircleProjectUpdateWithoutCircleInput, CircleProjectUncheckedUpdateWithoutCircleInput>
    create: XOR<CircleProjectCreateWithoutCircleInput, CircleProjectUncheckedCreateWithoutCircleInput>
  }

  export type CircleProjectUpdateWithWhereUniqueWithoutCircleInput = {
    where: CircleProjectWhereUniqueInput
    data: XOR<CircleProjectUpdateWithoutCircleInput, CircleProjectUncheckedUpdateWithoutCircleInput>
  }

  export type CircleProjectUpdateManyWithWhereWithoutCircleInput = {
    where: CircleProjectScalarWhereInput
    data: XOR<CircleProjectUpdateManyMutationInput, CircleProjectUncheckedUpdateManyWithoutCircleInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutCircleInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCircleInput, TransactionUncheckedUpdateWithoutCircleInput>
    create: XOR<TransactionCreateWithoutCircleInput, TransactionUncheckedCreateWithoutCircleInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCircleInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCircleInput, TransactionUncheckedUpdateWithoutCircleInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCircleInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCircleInput>
  }

  export type CircleCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: $Enums.CircleType
    theme?: string | null
    participationMode: $Enums.CircleParticipationMode
    maxMembers?: number | null
    isPublic?: boolean
    isActive?: boolean
    monthlyFee?: number | null
    funds?: number
    allocatedFunds?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCircleInput
    projects?: CircleProjectCreateNestedManyWithoutCircleInput
    Transaction?: TransactionCreateNestedManyWithoutCircleInput
  }

  export type CircleUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: $Enums.CircleType
    theme?: string | null
    participationMode: $Enums.CircleParticipationMode
    maxMembers?: number | null
    isPublic?: boolean
    isActive?: boolean
    monthlyFee?: number | null
    funds?: number
    allocatedFunds?: number
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: CircleProjectUncheckedCreateNestedManyWithoutCircleInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutCircleInput
  }

  export type CircleCreateOrConnectWithoutMembersInput = {
    where: CircleWhereUniqueInput
    create: XOR<CircleCreateWithoutMembersInput, CircleUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutCircleMemberInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedManyWithoutUserInput
    adress?: adressCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutAuthorInput
    Project?: ProjectCreateNestedManyWithoutOwnerInput
    Circle?: CircleCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeCreateNestedManyWithoutUserInput
    UserXP?: UserXPCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCircleMemberInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    adress?: adressUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutAuthorInput
    Project?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    Circle?: CircleUncheckedCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanUncheckedCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateUncheckedCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardUncheckedCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    UserXP?: UserXPUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCircleMemberInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCircleMemberInput, UserUncheckedCreateWithoutCircleMemberInput>
  }

  export type CircleUpsertWithoutMembersInput = {
    update: XOR<CircleUpdateWithoutMembersInput, CircleUncheckedUpdateWithoutMembersInput>
    create: XOR<CircleCreateWithoutMembersInput, CircleUncheckedCreateWithoutMembersInput>
    where?: CircleWhereInput
  }

  export type CircleUpdateToOneWithWhereWithoutMembersInput = {
    where?: CircleWhereInput
    data: XOR<CircleUpdateWithoutMembersInput, CircleUncheckedUpdateWithoutMembersInput>
  }

  export type CircleUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCircleTypeFieldUpdateOperationsInput | $Enums.CircleType
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    participationMode?: EnumCircleParticipationModeFieldUpdateOperationsInput | $Enums.CircleParticipationMode
    maxMembers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    funds?: FloatFieldUpdateOperationsInput | number
    allocatedFunds?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCircleNestedInput
    projects?: CircleProjectUpdateManyWithoutCircleNestedInput
    Transaction?: TransactionUpdateManyWithoutCircleNestedInput
  }

  export type CircleUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCircleTypeFieldUpdateOperationsInput | $Enums.CircleType
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    participationMode?: EnumCircleParticipationModeFieldUpdateOperationsInput | $Enums.CircleParticipationMode
    maxMembers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    funds?: FloatFieldUpdateOperationsInput | number
    allocatedFunds?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: CircleProjectUncheckedUpdateManyWithoutCircleNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutCircleNestedInput
  }

  export type UserUpsertWithoutCircleMemberInput = {
    update: XOR<UserUpdateWithoutCircleMemberInput, UserUncheckedUpdateWithoutCircleMemberInput>
    create: XOR<UserCreateWithoutCircleMemberInput, UserUncheckedCreateWithoutCircleMemberInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCircleMemberInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCircleMemberInput, UserUncheckedUpdateWithoutCircleMemberInput>
  }

  export type UserUpdateWithoutCircleMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateManyWithoutUserNestedInput
    adress?: adressUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCircleMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    adress?: adressUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUncheckedUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUncheckedUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUncheckedUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CircleCreateWithoutProjectsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: $Enums.CircleType
    theme?: string | null
    participationMode: $Enums.CircleParticipationMode
    maxMembers?: number | null
    isPublic?: boolean
    isActive?: boolean
    monthlyFee?: number | null
    funds?: number
    allocatedFunds?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCircleInput
    members?: CircleMemberCreateNestedManyWithoutCircleInput
    Transaction?: TransactionCreateNestedManyWithoutCircleInput
  }

  export type CircleUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: $Enums.CircleType
    theme?: string | null
    participationMode: $Enums.CircleParticipationMode
    maxMembers?: number | null
    isPublic?: boolean
    isActive?: boolean
    monthlyFee?: number | null
    funds?: number
    allocatedFunds?: number
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CircleMemberUncheckedCreateNestedManyWithoutCircleInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutCircleInput
  }

  export type CircleCreateOrConnectWithoutProjectsInput = {
    where: CircleWhereUniqueInput
    create: XOR<CircleCreateWithoutProjectsInput, CircleUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectCreateWithoutCircleProjectInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutProjectInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    posts?: PostCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanCreateNestedManyWithoutProjectInput
    Transaction?: TransactionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCircleProjectInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    ownerId: string
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    posts?: PostUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardUncheckedCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationUncheckedCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentUncheckedCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanUncheckedCreateNestedManyWithoutProjectInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCircleProjectInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCircleProjectInput, ProjectUncheckedCreateWithoutCircleProjectInput>
  }

  export type CircleUpsertWithoutProjectsInput = {
    update: XOR<CircleUpdateWithoutProjectsInput, CircleUncheckedUpdateWithoutProjectsInput>
    create: XOR<CircleCreateWithoutProjectsInput, CircleUncheckedCreateWithoutProjectsInput>
    where?: CircleWhereInput
  }

  export type CircleUpdateToOneWithWhereWithoutProjectsInput = {
    where?: CircleWhereInput
    data: XOR<CircleUpdateWithoutProjectsInput, CircleUncheckedUpdateWithoutProjectsInput>
  }

  export type CircleUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCircleTypeFieldUpdateOperationsInput | $Enums.CircleType
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    participationMode?: EnumCircleParticipationModeFieldUpdateOperationsInput | $Enums.CircleParticipationMode
    maxMembers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    funds?: FloatFieldUpdateOperationsInput | number
    allocatedFunds?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCircleNestedInput
    members?: CircleMemberUpdateManyWithoutCircleNestedInput
    Transaction?: TransactionUpdateManyWithoutCircleNestedInput
  }

  export type CircleUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCircleTypeFieldUpdateOperationsInput | $Enums.CircleType
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    participationMode?: EnumCircleParticipationModeFieldUpdateOperationsInput | $Enums.CircleParticipationMode
    maxMembers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    funds?: FloatFieldUpdateOperationsInput | number
    allocatedFunds?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CircleMemberUncheckedUpdateManyWithoutCircleNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutCircleNestedInput
  }

  export type ProjectUpsertWithoutCircleProjectInput = {
    update: XOR<ProjectUpdateWithoutCircleProjectInput, ProjectUncheckedUpdateWithoutCircleProjectInput>
    create: XOR<ProjectCreateWithoutCircleProjectInput, ProjectUncheckedCreateWithoutCircleProjectInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCircleProjectInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCircleProjectInput, ProjectUncheckedUpdateWithoutCircleProjectInput>
  }

  export type ProjectUpdateWithoutCircleProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutProjectNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    posts?: PostUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCircleProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    posts?: PostUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUncheckedUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUncheckedUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUncheckedUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUncheckedUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserCreateWithoutTransactionInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedManyWithoutUserInput
    adress?: adressCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutAuthorInput
    Project?: ProjectCreateNestedManyWithoutOwnerInput
    Circle?: CircleCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeCreateNestedManyWithoutUserInput
    UserXP?: UserXPCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    adress?: adressUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutAuthorInput
    Project?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    Circle?: CircleUncheckedCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanUncheckedCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateUncheckedCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardUncheckedCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    UserXP?: UserXPUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
  }

  export type ProjectCreateWithoutTransactionInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutProjectInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    posts?: PostCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTransactionInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    ownerId: string
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    posts?: PostUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    rewards?: ProjectRewardUncheckedCreateNestedManyWithoutProjectInput
    donations?: ProjectDonationUncheckedCreateNestedManyWithoutProjectInput
    investments?: ProjectInvestmentUncheckedCreateNestedManyWithoutProjectInput
    loans?: ProjectLoanUncheckedCreateNestedManyWithoutProjectInput
    CircleProject?: CircleProjectUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTransactionInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTransactionInput, ProjectUncheckedCreateWithoutTransactionInput>
  }

  export type CircleCreateWithoutTransactionInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: $Enums.CircleType
    theme?: string | null
    participationMode: $Enums.CircleParticipationMode
    maxMembers?: number | null
    isPublic?: boolean
    isActive?: boolean
    monthlyFee?: number | null
    funds?: number
    allocatedFunds?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCircleInput
    members?: CircleMemberCreateNestedManyWithoutCircleInput
    projects?: CircleProjectCreateNestedManyWithoutCircleInput
  }

  export type CircleUncheckedCreateWithoutTransactionInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: $Enums.CircleType
    theme?: string | null
    participationMode: $Enums.CircleParticipationMode
    maxMembers?: number | null
    isPublic?: boolean
    isActive?: boolean
    monthlyFee?: number | null
    funds?: number
    allocatedFunds?: number
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CircleMemberUncheckedCreateNestedManyWithoutCircleInput
    projects?: CircleProjectUncheckedCreateNestedManyWithoutCircleInput
  }

  export type CircleCreateOrConnectWithoutTransactionInput = {
    where: CircleWhereUniqueInput
    create: XOR<CircleCreateWithoutTransactionInput, CircleUncheckedCreateWithoutTransactionInput>
  }

  export type UserUpsertWithoutTransactionInput = {
    update: XOR<UserUpdateWithoutTransactionInput, UserUncheckedUpdateWithoutTransactionInput>
    create: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionInput, UserUncheckedUpdateWithoutTransactionInput>
  }

  export type UserUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateManyWithoutUserNestedInput
    adress?: adressUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    adress?: adressUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUncheckedUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUncheckedUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUncheckedUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutTransactionInput = {
    update: XOR<ProjectUpdateWithoutTransactionInput, ProjectUncheckedUpdateWithoutTransactionInput>
    create: XOR<ProjectCreateWithoutTransactionInput, ProjectUncheckedCreateWithoutTransactionInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTransactionInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTransactionInput, ProjectUncheckedUpdateWithoutTransactionInput>
  }

  export type ProjectUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutProjectNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    posts?: PostUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: StringFieldUpdateOperationsInput | string
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    posts?: PostUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUncheckedUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUncheckedUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUncheckedUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUncheckedUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type CircleUpsertWithoutTransactionInput = {
    update: XOR<CircleUpdateWithoutTransactionInput, CircleUncheckedUpdateWithoutTransactionInput>
    create: XOR<CircleCreateWithoutTransactionInput, CircleUncheckedCreateWithoutTransactionInput>
    where?: CircleWhereInput
  }

  export type CircleUpdateToOneWithWhereWithoutTransactionInput = {
    where?: CircleWhereInput
    data: XOR<CircleUpdateWithoutTransactionInput, CircleUncheckedUpdateWithoutTransactionInput>
  }

  export type CircleUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCircleTypeFieldUpdateOperationsInput | $Enums.CircleType
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    participationMode?: EnumCircleParticipationModeFieldUpdateOperationsInput | $Enums.CircleParticipationMode
    maxMembers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    funds?: FloatFieldUpdateOperationsInput | number
    allocatedFunds?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCircleNestedInput
    members?: CircleMemberUpdateManyWithoutCircleNestedInput
    projects?: CircleProjectUpdateManyWithoutCircleNestedInput
  }

  export type CircleUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCircleTypeFieldUpdateOperationsInput | $Enums.CircleType
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    participationMode?: EnumCircleParticipationModeFieldUpdateOperationsInput | $Enums.CircleParticipationMode
    maxMembers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    funds?: FloatFieldUpdateOperationsInput | number
    allocatedFunds?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CircleMemberUncheckedUpdateManyWithoutCircleNestedInput
    projects?: CircleProjectUncheckedUpdateManyWithoutCircleNestedInput
  }

  export type UserCreateWithoutUserXPInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedManyWithoutUserInput
    adress?: adressCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutAuthorInput
    Project?: ProjectCreateNestedManyWithoutOwnerInput
    Circle?: CircleCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserXPInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    adress?: adressUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutAuthorInput
    Project?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    Circle?: CircleUncheckedCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanUncheckedCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateUncheckedCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardUncheckedCreateNestedManyWithoutUserInput
    UserBadge?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserXPInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserXPInput, UserUncheckedCreateWithoutUserXPInput>
  }

  export type UserUpsertWithoutUserXPInput = {
    update: XOR<UserUpdateWithoutUserXPInput, UserUncheckedUpdateWithoutUserXPInput>
    create: XOR<UserCreateWithoutUserXPInput, UserUncheckedCreateWithoutUserXPInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserXPInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserXPInput, UserUncheckedUpdateWithoutUserXPInput>
  }

  export type UserUpdateWithoutUserXPInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateManyWithoutUserNestedInput
    adress?: adressUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserXPInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    adress?: adressUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUncheckedUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUncheckedUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUncheckedUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserBadgeCreateWithoutBadgeInput = {
    id?: string
    earnedAt?: Date | string
    user: UserCreateNestedOneWithoutUserBadgeInput
  }

  export type UserBadgeUncheckedCreateWithoutBadgeInput = {
    id?: string
    userId: string
    earnedAt?: Date | string
  }

  export type UserBadgeCreateOrConnectWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    create: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type UserBadgeCreateManyBadgeInputEnvelope = {
    data: UserBadgeCreateManyBadgeInput | UserBadgeCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type UserBadgeUpsertWithWhereUniqueWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    update: XOR<UserBadgeUpdateWithoutBadgeInput, UserBadgeUncheckedUpdateWithoutBadgeInput>
    create: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type UserBadgeUpdateWithWhereUniqueWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    data: XOR<UserBadgeUpdateWithoutBadgeInput, UserBadgeUncheckedUpdateWithoutBadgeInput>
  }

  export type UserBadgeUpdateManyWithWhereWithoutBadgeInput = {
    where: UserBadgeScalarWhereInput
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyWithoutBadgeInput>
  }

  export type UserCreateWithoutUserBadgeInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedManyWithoutUserInput
    adress?: adressCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutAuthorInput
    Project?: ProjectCreateNestedManyWithoutOwnerInput
    Circle?: CircleCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardCreateNestedManyWithoutUserInput
    UserXP?: UserXPCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserBadgeInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: UserCreaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedManyWithoutUserInput
    adress?: adressUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutAuthorInput
    Project?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    Circle?: CircleUncheckedCreateNestedManyWithoutCreatorInput
    Reaction?: ReactionUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ProjectMember?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectDonation?: ProjectDonationUncheckedCreateNestedManyWithoutUserInput
    ProjectInvestment?: ProjectInvestmentUncheckedCreateNestedManyWithoutUserInput
    ProjectLoan?: ProjectLoanUncheckedCreateNestedManyWithoutUserInput
    CircleMember?: CircleMemberUncheckedCreateNestedManyWithoutUserInput
    ProjectUpdate?: ProjectUpdateUncheckedCreateNestedManyWithoutUserInput
    ProjectReward?: ProjectRewardUncheckedCreateNestedManyWithoutUserInput
    UserXP?: UserXPUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserBadgeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserBadgeInput, UserUncheckedCreateWithoutUserBadgeInput>
  }

  export type BadgeCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    criteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BadgeUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    criteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BadgeCreateOrConnectWithoutUsersInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutUserBadgeInput = {
    update: XOR<UserUpdateWithoutUserBadgeInput, UserUncheckedUpdateWithoutUserBadgeInput>
    create: XOR<UserCreateWithoutUserBadgeInput, UserUncheckedCreateWithoutUserBadgeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserBadgeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserBadgeInput, UserUncheckedUpdateWithoutUserBadgeInput>
  }

  export type UserUpdateWithoutUserBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateManyWithoutUserNestedInput
    adress?: adressUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    adress?: adressUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUncheckedUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUncheckedUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUncheckedUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BadgeUpsertWithoutUsersInput = {
    update: XOR<BadgeUpdateWithoutUsersInput, BadgeUncheckedUpdateWithoutUsersInput>
    create: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutUsersInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutUsersInput, BadgeUncheckedUpdateWithoutUsersInput>
  }

  export type BadgeUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    criteria?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileCreateManyUserInput = {
    id?: string
    age?: number | null
    profession?: string | null
    motivation?: string | null
    interests?: ProfileCreateinterestsInput | string[]
    experience?: string | null
    disponibility?: string | null
    bio?: string | null
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    phoneVerified?: boolean
  }

  export type adressCreateManyUserInput = {
    id?: string
    street?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
  }

  export type PostCreateManyAuthorInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    parentId?: string | null
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateManyOwnerInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    type: $Enums.ProjectType
    status?: $Enums.ProjectStatus
    category: $Enums.ProjectCategory
    location?: string | null
    fundingGoal: number
    amountRaised?: number
    currency?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    duration?: number | null
    organization?: string | null
    legalStatus?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: string | null
    contactPhone?: string | null
    impactTypes?: ProjectCreateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: string | null
    impactIndicators?: ProjectCreateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectCreatesdgAlignmentInput | number[]
    images?: ProjectCreateimagesInput | string[]
    videos?: ProjectCreatevideosInput | string[]
    documents?: ProjectCreatedocumentsInput | string[]
    visibility?: $Enums.PostVisibility
    allowComments?: boolean
    enableImpactSprint?: boolean
    valuation?: number | null
    minInvestment?: number | null
    capitalPercentage?: number | null
    expectedInvestors?: number | null
    taxAdvantages?: string | null
    interestRate?: number | null
    loanDuration?: number | null
    repaymentFrequency?: string | null
    minLoanAmount?: number | null
    guarantees?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CircleCreateManyCreatorInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    type: $Enums.CircleType
    theme?: string | null
    participationMode: $Enums.CircleParticipationMode
    maxMembers?: number | null
    isPublic?: boolean
    isActive?: boolean
    monthlyFee?: number | null
    funds?: number
    allocatedFunds?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReactionCreateManyUserInput = {
    id?: string
    postId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type CommentCreateManyAuthorInput = {
    id?: string
    postId: string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    status?: $Enums.CommentStatus
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMemberCreateManyUserInput = {
    id?: string
    projectId: string
    role: string
    joinedAt?: Date | string
  }

  export type ProjectDonationCreateManyUserInput = {
    id?: string
    projectId: string
    amount: number
    isAnonymous?: boolean
    message?: string | null
    rewardId?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type ProjectInvestmentCreateManyUserInput = {
    id?: string
    projectId: string
    amount: number
    shares?: number | null
    status?: string
    createdAt?: Date | string
  }

  export type ProjectLoanCreateManyUserInput = {
    id?: string
    projectId: string
    amount: number
    status?: string
    createdAt?: Date | string
  }

  export type CircleMemberCreateManyUserInput = {
    id?: string
    circleId: string
    role: $Enums.CircleMemberRole
    joinedAt?: Date | string
    xp?: number
    level?: number
  }

  export type UserBadgeCreateManyUserInput = {
    id?: string
    badgeId: string
    earnedAt?: Date | string
  }

  export type UserXPCreateManyUserInput = {
    id?: string
    totalXP?: number
    level?: number
    impactRank?: string | null
    donationXP?: number
    investmentXP?: number
    contentXP?: number
    communityXP?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    type: string
    amount: number
    currency?: string
    status?: string
    description?: string | null
    projectId?: string | null
    circleId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    motivation?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: ProfileUpdateinterestsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    disponibility?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    motivation?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: ProfileUpdateinterestsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    disponibility?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProfileUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    motivation?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: ProfileUpdateinterestsInput | string[]
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    disponibility?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type adressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type adressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type adressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: PostUpdateOneWithoutChildrenNestedInput
    children?: PostUpdateManyWithoutParentNestedInput
    attachments?: MediaAssetUpdateManyWithoutPostNestedInput
    codeSnippets?: CodeSnippetUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    project?: ProjectUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PostUncheckedUpdateManyWithoutParentNestedInput
    attachments?: MediaAssetUncheckedUpdateManyWithoutPostNestedInput
    codeSnippets?: CodeSnippetUncheckedUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUncheckedUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    posts?: PostUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    posts?: PostUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    rewards?: ProjectRewardUncheckedUpdateManyWithoutProjectNestedInput
    donations?: ProjectDonationUncheckedUpdateManyWithoutProjectNestedInput
    investments?: ProjectInvestmentUncheckedUpdateManyWithoutProjectNestedInput
    loans?: ProjectLoanUncheckedUpdateManyWithoutProjectNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutProjectNestedInput
    CircleProject?: CircleProjectUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProjectTypeFieldUpdateOperationsInput | $Enums.ProjectType
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    category?: EnumProjectCategoryFieldUpdateOperationsInput | $Enums.ProjectCategory
    location?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: FloatFieldUpdateOperationsInput | number
    amountRaised?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    legalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    impactTypes?: ProjectUpdateimpactTypesInput | $Enums.ProjectImpactType[]
    impactDescription?: NullableStringFieldUpdateOperationsInput | string | null
    impactIndicators?: ProjectUpdateimpactIndicatorsInput | string[]
    sdgAlignment?: ProjectUpdatesdgAlignmentInput | number[]
    images?: ProjectUpdateimagesInput | string[]
    videos?: ProjectUpdatevideosInput | string[]
    documents?: ProjectUpdatedocumentsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    enableImpactSprint?: BoolFieldUpdateOperationsInput | boolean
    valuation?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableFloatFieldUpdateOperationsInput | number | null
    capitalPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedInvestors?: NullableIntFieldUpdateOperationsInput | number | null
    taxAdvantages?: NullableStringFieldUpdateOperationsInput | string | null
    interestRate?: NullableFloatFieldUpdateOperationsInput | number | null
    loanDuration?: NullableIntFieldUpdateOperationsInput | number | null
    repaymentFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    minLoanAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    guarantees?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CircleUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCircleTypeFieldUpdateOperationsInput | $Enums.CircleType
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    participationMode?: EnumCircleParticipationModeFieldUpdateOperationsInput | $Enums.CircleParticipationMode
    maxMembers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    funds?: FloatFieldUpdateOperationsInput | number
    allocatedFunds?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CircleMemberUpdateManyWithoutCircleNestedInput
    projects?: CircleProjectUpdateManyWithoutCircleNestedInput
    Transaction?: TransactionUpdateManyWithoutCircleNestedInput
  }

  export type CircleUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCircleTypeFieldUpdateOperationsInput | $Enums.CircleType
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    participationMode?: EnumCircleParticipationModeFieldUpdateOperationsInput | $Enums.CircleParticipationMode
    maxMembers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    funds?: FloatFieldUpdateOperationsInput | number
    allocatedFunds?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CircleMemberUncheckedUpdateManyWithoutCircleNestedInput
    projects?: CircleProjectUncheckedUpdateManyWithoutCircleNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutCircleNestedInput
  }

  export type CircleUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCircleTypeFieldUpdateOperationsInput | $Enums.CircleType
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    participationMode?: EnumCircleParticipationModeFieldUpdateOperationsInput | $Enums.CircleParticipationMode
    maxMembers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    monthlyFee?: NullableFloatFieldUpdateOperationsInput | number | null
    funds?: FloatFieldUpdateOperationsInput | number
    allocatedFunds?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type ReactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDonationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDonationsNestedInput
    reward?: ProjectRewardUpdateOneWithoutProjectDonationNestedInput
  }

  export type ProjectDonationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    rewardId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDonationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    rewardId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInvestmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    shares?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutInvestmentsNestedInput
  }

  export type ProjectInvestmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    shares?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInvestmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    shares?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectLoanUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutLoansNestedInput
  }

  export type ProjectLoanUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectLoanUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CircleMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumCircleMemberRoleFieldUpdateOperationsInput | $Enums.CircleMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    circle?: CircleUpdateOneRequiredWithoutMembersNestedInput
  }

  export type CircleMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    circleId?: StringFieldUpdateOperationsInput | string
    role?: EnumCircleMemberRoleFieldUpdateOperationsInput | $Enums.CircleMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type CircleMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    circleId?: StringFieldUpdateOperationsInput | string
    role?: EnumCircleMemberRoleFieldUpdateOperationsInput | $Enums.CircleMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectUpdateUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ProjectUpdateUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUpdatesNestedInput
  }

  export type ProjectUpdateUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ProjectUpdateUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ProjectUpdateUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectRewardUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    claimed?: IntFieldUpdateOperationsInput | number
    project?: ProjectUpdateOneRequiredWithoutRewardsNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutRewardNestedInput
  }

  export type ProjectRewardUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    claimed?: IntFieldUpdateOperationsInput | number
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutRewardNestedInput
  }

  export type ProjectRewardUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    claimed?: IntFieldUpdateOperationsInput | number
  }

  export type UserBadgeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    badge?: BadgeUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserBadgeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserXPUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    impactRank?: NullableStringFieldUpdateOperationsInput | string | null
    donationXP?: IntFieldUpdateOperationsInput | number
    investmentXP?: IntFieldUpdateOperationsInput | number
    contentXP?: IntFieldUpdateOperationsInput | number
    communityXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserXPUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    impactRank?: NullableStringFieldUpdateOperationsInput | string | null
    donationXP?: IntFieldUpdateOperationsInput | number
    investmentXP?: IntFieldUpdateOperationsInput | number
    contentXP?: IntFieldUpdateOperationsInput | number
    communityXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserXPUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalXP?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    impactRank?: NullableStringFieldUpdateOperationsInput | string | null
    donationXP?: IntFieldUpdateOperationsInput | number
    investmentXP?: IntFieldUpdateOperationsInput | number
    contentXP?: IntFieldUpdateOperationsInput | number
    communityXP?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutTransactionNestedInput
    circle?: CircleUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    circleId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    circleId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateManyParentInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    authorId: string
    projectId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaAssetCreateManyPostInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    provider?: string | null
    title?: string | null
    alt?: string | null
    caption?: string | null
    position?: number | null
    mimeType?: string | null
    sizeBytes?: number | null
    width?: number | null
    height?: number | null
    durationMs?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CodeSnippetCreateManyPostInput = {
    id?: string
    title?: string | null
    language: string
    filename?: string | null
    code: string
    highlightedHtml?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostsOnTagsCreateManyPostInput = {
    tagId: string
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type PostsOnCategoriesCreateManyPostInput = {
    categoryId: string
    position?: number | null
    assignedAt?: Date | string
  }

  export type CommentCreateManyPostInput = {
    id?: string
    authorId: string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    status?: $Enums.CommentStatus
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReactionCreateManyPostInput = {
    id?: string
    userId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type PostUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostNestedInput
    children?: PostUpdateManyWithoutParentNestedInput
    attachments?: MediaAssetUpdateManyWithoutPostNestedInput
    codeSnippets?: CodeSnippetUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    project?: ProjectUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PostUncheckedUpdateManyWithoutParentNestedInput
    attachments?: MediaAssetUncheckedUpdateManyWithoutPostNestedInput
    codeSnippets?: CodeSnippetUncheckedUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUncheckedUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAssetUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAssetUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaAssetUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSnippetUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    highlightedHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSnippetUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    highlightedHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CodeSnippetUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    highlightedHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsOnTagsUpdateWithoutPostInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: TagUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostsOnTagsUncheckedUpdateWithoutPostInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostsOnTagsUncheckedUpdateManyWithoutPostInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostsOnCategoriesUpdateWithoutPostInput = {
    position?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostsOnCategoriesUncheckedUpdateWithoutPostInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsOnCategoriesUncheckedUpdateManyWithoutPostInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReactionNestedInput
  }

  export type ReactionUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsOnTagsCreateManyTagInput = {
    postId: string
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type PostsOnTagsUpdateWithoutTagInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    post?: PostUpdateOneRequiredWithoutTagsNestedInput
  }

  export type PostsOnTagsUncheckedUpdateWithoutTagInput = {
    postId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostsOnTagsUncheckedUpdateManyWithoutTagInput = {
    postId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryCreateManyParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostsOnCategoriesCreateManyCategoryInput = {
    postId: string
    position?: number | null
    assignedAt?: Date | string
  }

  export type CategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUpdateManyWithoutParentNestedInput
    posts?: PostsOnCategoriesUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    posts?: PostsOnCategoriesUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsOnCategoriesUpdateWithoutCategoryInput = {
    position?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type PostsOnCategoriesUncheckedUpdateWithoutCategoryInput = {
    postId?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsOnCategoriesUncheckedUpdateManyWithoutCategoryInput = {
    postId?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyParentInput = {
    id?: string
    postId: string
    authorId: string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    status?: $Enums.CommentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateManyProjectInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
  }

  export type PostCreateManyProjectInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: string | null
    excerpt?: string | null
    coverImageUrl?: string | null
    canonicalUrl?: string | null
    ogImageUrl?: string | null
    status?: $Enums.PostStatus
    visibility?: $Enums.PostVisibility
    publishedAt?: Date | string | null
    scheduledAt?: Date | string | null
    readingTime?: number | null
    wordCount?: number | null
    language?: string | null
    authorId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateCreateManyProjectInput = {
    id?: string
    title: string
    content: string
    images?: ProjectUpdateCreateimagesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectRewardCreateManyProjectInput = {
    id?: string
    amount: number
    title: string
    description: string
    image?: string | null
    deliveryDate?: Date | string | null
    quantity?: number | null
    claimed?: number
  }

  export type ProjectDonationCreateManyProjectInput = {
    id?: string
    userId: string
    amount: number
    isAnonymous?: boolean
    message?: string | null
    rewardId?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type ProjectInvestmentCreateManyProjectInput = {
    id?: string
    userId: string
    amount: number
    shares?: number | null
    status?: string
    createdAt?: Date | string
  }

  export type ProjectLoanCreateManyProjectInput = {
    id?: string
    userId: string
    amount: number
    status?: string
    createdAt?: Date | string
  }

  export type TransactionCreateManyProjectInput = {
    id?: string
    userId: string
    type: string
    amount: number
    currency?: string
    status?: string
    description?: string | null
    circleId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CircleProjectCreateManyProjectInput = {
    id?: string
    circleId: string
    allocatedAmount?: number
    supportType: string
    votedAt?: Date | string | null
    status?: string
  }

  export type ProjectMemberUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectMemberNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostNestedInput
    parent?: PostUpdateOneWithoutChildrenNestedInput
    children?: PostUpdateManyWithoutParentNestedInput
    attachments?: MediaAssetUpdateManyWithoutPostNestedInput
    codeSnippets?: CodeSnippetUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PostUncheckedUpdateManyWithoutParentNestedInput
    attachments?: MediaAssetUncheckedUpdateManyWithoutPostNestedInput
    codeSnippets?: CodeSnippetUncheckedUpdateManyWithoutPostNestedInput
    tags?: PostsOnTagsUncheckedUpdateManyWithoutPostNestedInput
    categories?: PostsOnCategoriesUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ogImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readingTime?: NullableIntFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ProjectUpdateUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateManyWithoutProjectUpdateNestedInput
  }

  export type ProjectUpdateUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ProjectUpdateUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUncheckedUpdateManyWithoutProjectUpdateNestedInput
  }

  export type ProjectUpdateUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ProjectUpdateUpdateimagesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectRewardUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    claimed?: IntFieldUpdateOperationsInput | number
    ProjectDonation?: ProjectDonationUpdateManyWithoutRewardNestedInput
    User?: UserUpdateManyWithoutProjectRewardNestedInput
  }

  export type ProjectRewardUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    claimed?: IntFieldUpdateOperationsInput | number
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutRewardNestedInput
    User?: UserUncheckedUpdateManyWithoutProjectRewardNestedInput
  }

  export type ProjectRewardUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    claimed?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectDonationUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectDonationNestedInput
    reward?: ProjectRewardUpdateOneWithoutProjectDonationNestedInput
  }

  export type ProjectDonationUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    rewardId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDonationUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    rewardId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInvestmentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    shares?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectInvestmentNestedInput
  }

  export type ProjectInvestmentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    shares?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectInvestmentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    shares?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectLoanUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectLoanNestedInput
  }

  export type ProjectLoanUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectLoanUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionNestedInput
    circle?: CircleUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    circleId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    circleId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CircleProjectUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: FloatFieldUpdateOperationsInput | number
    supportType?: StringFieldUpdateOperationsInput | string
    votedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    circle?: CircleUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type CircleProjectUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    circleId?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: FloatFieldUpdateOperationsInput | number
    supportType?: StringFieldUpdateOperationsInput | string
    votedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type CircleProjectUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    circleId?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: FloatFieldUpdateOperationsInput | number
    supportType?: StringFieldUpdateOperationsInput | string
    votedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateManyWithoutUserNestedInput
    adress?: adressUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    adress?: adressUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUncheckedUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUncheckedUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectReward?: ProjectRewardUncheckedUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
  }

  export type ProjectDonationCreateManyRewardInput = {
    id?: string
    projectId: string
    userId: string
    amount: number
    isAnonymous?: boolean
    message?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type ProjectDonationUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDonationsNestedInput
    user?: UserUpdateOneRequiredWithoutProjectDonationNestedInput
  }

  export type ProjectDonationUncheckedUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDonationUncheckedUpdateManyWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutProjectRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateManyWithoutUserNestedInput
    adress?: adressUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateManyWithoutUserNestedInput
    adress?: adressUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    Project?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    Circle?: CircleUncheckedUpdateManyWithoutCreatorNestedInput
    Reaction?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    ProjectMember?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectDonation?: ProjectDonationUncheckedUpdateManyWithoutUserNestedInput
    ProjectInvestment?: ProjectInvestmentUncheckedUpdateManyWithoutUserNestedInput
    ProjectLoan?: ProjectLoanUncheckedUpdateManyWithoutUserNestedInput
    CircleMember?: CircleMemberUncheckedUpdateManyWithoutUserNestedInput
    ProjectUpdate?: ProjectUpdateUncheckedUpdateManyWithoutUserNestedInput
    UserBadge?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    UserXP?: UserXPUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutProjectRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
  }

  export type CircleMemberCreateManyCircleInput = {
    id?: string
    userId: string
    role: $Enums.CircleMemberRole
    joinedAt?: Date | string
    xp?: number
    level?: number
  }

  export type CircleProjectCreateManyCircleInput = {
    id?: string
    projectId: string
    allocatedAmount?: number
    supportType: string
    votedAt?: Date | string | null
    status?: string
  }

  export type TransactionCreateManyCircleInput = {
    id?: string
    userId: string
    type: string
    amount: number
    currency?: string
    status?: string
    description?: string | null
    projectId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CircleMemberUpdateWithoutCircleInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumCircleMemberRoleFieldUpdateOperationsInput | $Enums.CircleMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutCircleMemberNestedInput
  }

  export type CircleMemberUncheckedUpdateWithoutCircleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumCircleMemberRoleFieldUpdateOperationsInput | $Enums.CircleMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type CircleMemberUncheckedUpdateManyWithoutCircleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumCircleMemberRoleFieldUpdateOperationsInput | $Enums.CircleMemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type CircleProjectUpdateWithoutCircleInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: FloatFieldUpdateOperationsInput | number
    supportType?: StringFieldUpdateOperationsInput | string
    votedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutCircleProjectNestedInput
  }

  export type CircleProjectUncheckedUpdateWithoutCircleInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: FloatFieldUpdateOperationsInput | number
    supportType?: StringFieldUpdateOperationsInput | string
    votedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type CircleProjectUncheckedUpdateManyWithoutCircleInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    allocatedAmount?: FloatFieldUpdateOperationsInput | number
    supportType?: StringFieldUpdateOperationsInput | string
    votedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionUpdateWithoutCircleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionNestedInput
    project?: ProjectUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCircleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutCircleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateManyBadgeInput = {
    id?: string
    userId: string
    earnedAt?: Date | string
  }

  export type UserBadgeUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserBadgeNestedInput
  }

  export type UserBadgeUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}